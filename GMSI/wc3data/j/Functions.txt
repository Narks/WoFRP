function GetLength takes string B returns integer
local integer L
if B == "" then
return 0
endif
set L = 1
loop
exitwhen SubStringBJ(B,L,L) == ""
set L = L + 1
endloop
return L - 1
endfunction
function CamSetPid takes nothing returns nothing
set udg_zz_CamPid[udg_zz_CamPidIndex] = GetPlayerId(GetEnumPlayer())
set udg_zz_CamPidIndex = udg_zz_CamPidIndex + 1
endfunction
function Abilcode2Heroskillcode takes integer I returns integer
return I
endfunction
function SetUnitIndex takes nothing returns integer
set udg_zz_UnitIndex = udg_zz_UnitIndex + 1
return udg_zz_UnitIndex
endfunction
function InArrayGebenEinheit takes unit Hinzu returns nothing
set udg_zz_AllUnits[SetUnitIndex()] = Hinzu
endfunction
function GetUniqueEinheitsnummer takes unit U returns integer
local integer Index = 1
local integer Id = udg_zz_UnitIndex + 1
local integer Free = -1
loop
exitwhen Index > udg_zz_UnitIndex
if udg_zz_AllUnits[Index] == null then
set Free = Index
endif
if udg_zz_AllUnits[Index] == U then
set Id = Index
set Index = udg_zz_UnitIndex + 1
else
set Index = Index + 1
endif
endloop
if Id == udg_zz_UnitIndex + 1 then
if Free != -1 then
set udg_zz_AllUnits[Free] = U
return Free
endif
call InArrayGebenEinheit(U)
endif
return Id
endfunction
function returnubersplat takes ubersplat a returns ubersplat
return a
endfunction
function returnimage takes image a returns image
return a
endfunction
function returnlightning takes lightning a returns lightning
return a
endfunction
function returntrackable takes trackable a returns trackable
return a
endfunction
function returnabilcode takes integer a returns integer
return a
endfunction
function returnboolean takes boolean a returns boolean
return a
endfunction
function returndestructable takes destructable a returns destructable
return a
endfunction
function returndestructablecode takes integer a returns integer
return a
endfunction
function returndialog takes dialog a returns dialog
return a
endfunction
function returnbutton takes button a returns button
return a
endfunction
function returneventid takes eventid a returns eventid
return a
endfunction
function returntexttag takes texttag a returns texttag
return a
endfunction
function returninteger takes integer a returns integer
return a
endfunction
function returnitem takes item a returns item
return a
endfunction
function returnitemcode takes integer a returns integer
return a
endfunction
function returnleaderboard takes leaderboard a returns leaderboard
return a
endfunction
function returnmultiboard takes multiboard a returns multiboard
return a
endfunction
function returnmultiboarditem takes multiboarditem a returns multiboarditem
return a
endfunction
function returnordercode takes integer a returns integer
return a
endfunction
function returnplayer takes player a returns player
return a
endfunction
function returnforce takes force a returns force
return a
endfunction
function returnlocation takes location a returns location
return a
endfunction
function returnreal takes real a returns real
return a
endfunction
function returnrect takes rect a returns rect
return a
endfunction
function returnregion takes region a returns region
return a
endfunction
function returneffect takes effect a returns effect
return a
endfunction
function returnstring takes string a returns string
return a
endfunction
function returnterraindeformation takes terraindeformation a returns terraindeformation
return a
endfunction
function returntimer takes timer a returns timer
return a
endfunction
function returntimerdialog takes timerdialog a returns timerdialog
return a
endfunction
function returntrigger takes trigger a returns trigger
return a
endfunction
function returntriggeraction takes triggeraction a returns triggeraction
return a
endfunction
function returntriggercondition takes triggercondition a returns triggercondition
return a
endfunction
function returnunit takes unit a returns unit
return a
endfunction
function returngroup takes group a returns group
return a
endfunction
function returnunitcode takes integer a returns integer
return a
endfunction
function returnmusicfile takes string a returns string
return a
endfunction
function returnheroskillcode takes integer a returns integer
return a
endfunction
function WEUCache takes nothing returns gamecache
return InitGameCache("WEU.w3v")
endfunction
function Rect2Unit takes rect R returns unit
return R
return null
endfunction
function Unit2Rect takes unit U returns rect
return U
return null
endfunction
function Loc2Unit takes location L returns unit
return L
return null
endfunction
function Unit2Loc takes unit U returns location
return U
return null
endfunction
function Handle2Int takes handle H returns integer
if H != null then
return H
endif
return 0
endfunction
function Boo2Int takes boolean B returns integer
if B then
return 1
endif
return 0
endfunction
function Real2Int takes real R returns integer
if R != 0 then
return R
endif
return 0
endfunction
function Str2Int takes string S returns integer
if S != "" then
return S
endif
return 0
endfunction
function Int2Unit takes integer I returns unit
if I != 0 then
return I
endif
return null
endfunction
function Int2Item takes integer I returns item
if I != 0 then
return I
endif
return null
endfunction
function Int2Dest takes integer I returns destructable
if I != 0 then
return I
endif
return null
endfunction
function Int2Track takes integer I returns trackable
if I != 0 then
return I
endif
return null
endfunction
function Int2Player takes integer I returns player
if I != 0 then
return I
endif
return null
endfunction
function Int2Force takes integer I returns force
if I != 0 then
return I
endif
return null
endfunction
function Int2Group takes integer I returns group
if I != 0 then
return I
endif
return null
endfunction
function Int2Trigger takes integer I returns trigger
if I != 0 then
return I
endif
return null
endfunction
function Int2Loc takes integer I returns location
if I != 0 then
return I
endif
return null
endfunction
function Int2Region takes integer I returns region
if I != 0 then
return I
endif
return null
endfunction
function Int2Rect takes integer I returns rect
if I != 0 then
return I
endif
return null
endfunction
function Int2Sound takes integer I returns sound
if I != 0 then
return I
endif
return null
endfunction
function Int2Effect takes integer I returns effect
if I != 0 then
return I
endif
return null
endfunction
function Int2Dialog takes integer I returns dialog
if I != 0 then
return I
endif
return null
endfunction
function Int2Button takes integer I returns button
if I != 0 then
return I
endif
return null
endfunction
function Int2Quest takes integer I returns quest
if I != 0 then
return I
endif
return null
endfunction
function Int2Timer takes integer I returns timer
if I != 0 then
return I
endif
return null
endfunction
function Int2Lboard takes integer I returns leaderboard
if I != 0 then
return I
endif
return null
endfunction
function Int2Mboard takes integer I returns multiboard
if I != 0 then
return I
endif
return null
endfunction
function Int2Texttag takes integer I returns texttag
if I != 0 then
return I
endif
return null
endfunction
function Int2Boo takes integer I returns boolean
if I != 0 then
return true
endif
return false
endfunction
function Int2Real takes integer I returns real
if I != 0 then
return I
endif
return 0.00
endfunction
function Int2Str takes integer I returns string
if I != 0 then
return I
endif
return ""
endfunction
function CinematicModeExBJAdvanced takes boolean cineMode, force forForce, real interfaceFadeTime returns nothing
local integer Index = 0
set udg_zz_CamPidIndex = 0
call ForForce(forForce,function CamSetPid)
if (not bj_gameStarted) then
set interfaceFadeTime = 0
endif
if (cineMode) then
if (not bj_cineModeAlreadyIn) then
set bj_cineModeAlreadyIn = true
set bj_cineModePriorFogSetting = IsFogEnabled()
set bj_cineModePriorMaskSetting = IsFogMaskEnabled()
set bj_cineModePriorDawnDusk = IsDawnDuskEnabled()
loop
exitwhen Index == udg_zz_CamPidIndex
if udg_zz_AdjustCam[udg_zz_CamPid[Index]] == false then
set udg_zz_CamAlreadyOff[udg_zz_CamPid[Index]] = true
endif
set Index = Index + 1
endloop
endif
set Index = 0
loop
exitwhen Index == udg_zz_CamPidIndex
set udg_zz_AdjustCam[udg_zz_CamPid[Index]] = false
set Index = Index + 1
endloop
if (IsPlayerInForce(GetLocalPlayer(), forForce)) then
call ClearTextMessages()
call ShowInterface(false, interfaceFadeTime)
call EnableUserControl(false)
call EnableOcclusion(false)
call FogMaskEnable(false)
call FogEnable(false)
call EnableWorldFogBoundary(false)
call EnableDawnDusk(false)
call SetCineModeVolumeGroupsBJ()
endif
else
set bj_cineModeAlreadyIn = false
set Index = 0
loop
exitwhen Index == udg_zz_CamPidIndex
if udg_zz_CamAlreadyOff[udg_zz_CamPid[Index]] == true then
set udg_zz_CamAlreadyOff[udg_zz_CamPid[Index]] = false
else
set udg_zz_AdjustCam[udg_zz_CamPid[Index]] = true
set udg_zz_CamAlreadyOff[udg_zz_CamPid[Index]] = false
endif
set Index = Index + 1
endloop
if (IsPlayerInForce(GetLocalPlayer(), forForce)) then
call ShowInterface(true, interfaceFadeTime)
call EnableUserControl(true)
call EnableOcclusion(true)
call FogMaskEnable(bj_cineModePriorMaskSetting)
call FogEnable(bj_cineModePriorFogSetting)
call EnableWorldFogBoundary(true)
call EnableDawnDusk(bj_cineModePriorDawnDusk)
call VolumeGroupReset()
call EndThematicMusic()
call CameraResetSmoothingFactorBJ()
endif
endif
endfunction
function CinematicModeBJAdvanced takes boolean cineMode, player P, real FadeTime returns nothing
local force F = CreateForce()
call ForceAddPlayer(F,P)
call CinematicModeExBJAdvanced(cineMode,F,FadeTime)
set F = null
endfunction
function ErrorMsg takes player ForPlayer, string Msg returns nothing
local sound Error = CreateSound("Sound\\Interface\\Error.wav", false, false, false, 10, 10,"HeroAcksEAX")
if (GetLocalPlayer() == ForPlayer) then
call ClearTextMessages()
call DisplayTimedTextToPlayer(ForPlayer,0.52,-1.00,2.00,"|cffffcc00"+Msg+"|r")
call SetSoundParamsFromLabel(Error,"InterfaceError")
call SetSoundDuration(Error,614)
call SetSoundChannel(Error,6)
call PlaySoundBJ(Error)
endif
endfunction
function InitShortcuts takes nothing returns nothing
set udg_zz_ShortcutId[32] = "Leertaste"
set udg_zz_ShortcutId[48] = "0"
set udg_zz_ShortcutId[49] = "1"
set udg_zz_ShortcutId[50] = "2"
set udg_zz_ShortcutId[51] = "3"
set udg_zz_ShortcutId[52] = "4"
set udg_zz_ShortcutId[53] = "5"
set udg_zz_ShortcutId[54] = "6"
set udg_zz_ShortcutId[55] = "7"
set udg_zz_ShortcutId[56] = "8"
set udg_zz_ShortcutId[57] = "9"
set udg_zz_ShortcutId[65] = "A"
set udg_zz_ShortcutId[66] = "B"
set udg_zz_ShortcutId[67] = "C"
set udg_zz_ShortcutId[68] = "D"
set udg_zz_ShortcutId[69] = "E"
set udg_zz_ShortcutId[70] = "F"
set udg_zz_ShortcutId[71] = "G"
set udg_zz_ShortcutId[72] = "H"
set udg_zz_ShortcutId[73] = "I"
set udg_zz_ShortcutId[74] = "J"
set udg_zz_ShortcutId[75] = "K"
set udg_zz_ShortcutId[76] = "L"
set udg_zz_ShortcutId[77] = "M"
set udg_zz_ShortcutId[78] = "N"
set udg_zz_ShortcutId[79] = "O"
set udg_zz_ShortcutId[80] = "P"
set udg_zz_ShortcutId[81] = "Q"
set udg_zz_ShortcutId[82] = "R"
set udg_zz_ShortcutId[83] = "S"
set udg_zz_ShortcutId[84] = "T"
set udg_zz_ShortcutId[85] = "U"
set udg_zz_ShortcutId[86] = "V"
set udg_zz_ShortcutId[87] = "W"
set udg_zz_ShortcutId[88] = "X"
set udg_zz_ShortcutId[89] = "Y"
set udg_zz_ShortcutId[90] = "Z"
set udg_zz_ShortcutId[96] = "Numpad0"
set udg_zz_ShortcutId[97] = "Numpad1"
set udg_zz_ShortcutId[98] = "Numpad2"
set udg_zz_ShortcutId[99] = "Numpad3"
set udg_zz_ShortcutId[100] = "Numpad4"
set udg_zz_ShortcutId[101] = "Numpad5"
set udg_zz_ShortcutId[102] = "Numpad6"
set udg_zz_ShortcutId[103] = "Numpad7"
set udg_zz_ShortcutId[104] = "Numpad8"
set udg_zz_ShortcutId[105] = "Numpad9"
set udg_zz_ShortcutId[512] = "Escape"
endfunction
function Klickaktionen takes nothing returns nothing
local integer Index = GetPlayerId(GetTriggerPlayer()) * 12
call DialogDisplayBJ(false,udg_zz_DialogSpieler[GetPlayerId(GetTriggerPlayer())],GetTriggerPlayer())
loop
set udg_zz_DialogShortcut[Index] = 0
exitwhen Index == (GetPlayerId(GetTriggerPlayer()) * 12) + 11
set Index = Index + 1
endloop
set Index = 0
loop
exitwhen GetClickedButtonBJ() == udg_zz_DialogButton[Index]
set Index = Index + 1
endloop
set udg_zz_LastClickedButtonNr[GetPlayerId(GetTriggerPlayer())] = Index + 1 - GetPlayerId(GetTriggerPlayer()) * 12
call ExecuteFunc(udg_zz_DialogAktion[Index])
endfunction
function GetLastClickedDialogButtonNrOfPlayer takes player P returns integer
return udg_zz_LastClickedButtonNr[GetPlayerId(P)]
endfunction
function Dialoginitialisierung takes nothing returns nothing
local integer Index = 0
loop
set udg_zz_DialogSpieler[Index] = DialogCreate()
exitwhen Index == 11
set Index = Index + 1
endloop
set Index = 0
loop
set udg_zz_DialogAktion[Index] = ""
set udg_zz_DialogFolge[Index] = CreateTrigger()
call TriggerRegisterDialogEventBJ(udg_zz_DialogFolge[Index],udg_zz_DialogSpieler[Index])
call TriggerAddAction(udg_zz_DialogFolge[Index],function Klickaktionen)
exitwhen Index == 11
set Index = Index + 1
endloop
call InitShortcuts()
endfunction
function ButtonHinzu takes string B, string F, string FarbeText, integer Spieler, integer Arrayposition, integer Index returns integer
if B != "" then
call DialogAddButtonBJ(udg_zz_DialogSpieler[Spieler],"|cff" + FarbeText + B + "|r")
if F == "" then
set udg_zz_DialogAktion[Arrayposition + Index] = "DoNothing"
else
set udg_zz_DialogAktion[Arrayposition + Index] = F
endif
set udg_zz_DialogButton[Arrayposition + Index] = GetLastCreatedButtonBJ()
endif
set Index = Index + 1
return Index
endfunction
function DialogOhneShortcut takes player Spieler, string Label, string FarbeLabel, string FarbeText, string B1, string F1, string B2, string F2, string B3, string F3, string B4, string F4, string B5, string F5, string B6, string F6, boolean Show returns nothing
local integer Arrayposition = GetPlayerId(Spieler) * 12
local integer Index = 0
call DialogClearBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)])
call DialogSetMessageBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)],"|cff" + FarbeLabel + Label + "|r")
set Index = ButtonHinzu(B1,F1,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B2,F2,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B3,F3,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B4,F4,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B5,F5,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B6,F6,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
if Show == true then
call DialogDisplayBJ(true,udg_zz_DialogSpieler[GetPlayerId(Spieler)],Spieler)
endif
endfunction
function AddButtonsOhneShortcut takes player Spieler, string FarbeText, string B7, string F7, string B8, string F8, string B9, string F9, string B10, string F10, string B11, string F11, string B12, string F12 returns nothing
local integer Arrayposition = GetPlayerId(Spieler) * 12
local integer Index = 6
set Index = ButtonHinzu(B7,F7,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B8,F8,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B9,F9,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B10,F10,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B11,F11,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonHinzu(B12,F12,FarbeText,GetPlayerId(Spieler),Arrayposition,Index)
call DialogDisplayBJ(true,udg_zz_DialogSpieler[GetPlayerId(Spieler)],Spieler)
endfunction
function UcaseWord takes string S returns string
if S == "a" then
return "A"
elseif S == "b" then
return "B"
elseif S == "c" then
return "C"
elseif S == "d" then
return "D"
elseif S == "e" then
return "E"
elseif S == "f" then
return "F"
elseif S == "g" then
return "G"
elseif S == "h" then
return "H"
elseif S == "i" then
return "I"
elseif S == "j" then
return "J"
elseif S == "k" then
return "K"
elseif S == "l" then
return "L"
elseif S == "m" then
return "M"
elseif S == "n" then
return "N"
elseif S == "o" then
return "O"
elseif S == "p" then
return "P"
elseif S == "q" then
return "Q"
elseif S == "r" then
return "R"
endif
if S == "s" then
return "S"
elseif S == "t" then
return "T"
elseif S == "u" then
return "U"
elseif S == "v" then
return "V"
elseif S == "w" then
return "W"
elseif S == "x" then
return "X"
elseif S == "y" then
return "Y"
elseif S == "z" then
return "Z"
endif
return S
endfunction
function LcaseWord takes string S returns string
if S == "A" then
return "a"
elseif S == "B" then
return "b"
elseif S == "C" then
return "c"
elseif S == "D" then
return "d"
elseif S == "E" then
return "e"
elseif S == "F" then
return "f"
elseif S == "G" then
return "g"
elseif S == "H" then
return "h"
elseif S == "I" then
return "i"
elseif S == "J" then
return "j"
elseif S == "K" then
return "k"
elseif S == "L" then
return "l"
elseif S == "M" then
return "m"
elseif S == "N" then
return "n"
elseif S == "O" then
return "o"
elseif S == "P" then
return "p"
elseif S == "Q" then
return "q"
elseif S == "R" then
return "r"
endif
if S == "S" then
return "s"
elseif S == "T" then
return "t"
elseif S == "U" then
return "u"
elseif S == "V" then
return "v"
elseif S == "W" then
return "w"
elseif S == "X" then
return "x"
elseif S == "Y" then
return "y"
elseif S == "Z" then
return "z"
endif
return S
endfunction
function Uppercase takes string S returns string
local integer L = GetLength(S)
local integer Index = 1
local string Ret = ""
loop
set Ret = Ret + UcaseWord(SubStringBJ(S,Index,Index))
exitwhen Index == L
set Index = Index + 1
endloop
return Ret
endfunction
function Lowercase takes string S returns string
local integer L = GetLength(S)
local integer Index = 1
local string Ret = ""
loop
set Ret = Ret + LcaseWord(SubStringBJ(S,Index,Index))
exitwhen Index == L
set Index = Index + 1
endloop
return Ret
endfunction
function CountWords takes string ChatMsg returns integer
local integer Anzahl = 1
local integer Length = GetLength(ChatMsg)
local integer Index = 1
loop
if SubStringBJ(ChatMsg,Index,Index) == " " then
if Index != 1 and Index != Length then
set Anzahl = Anzahl + 1
endif
endif
exitwhen Index == Length
set Index = Index + 1
endloop
return Anzahl
endfunction
function ColoredString takes string Bright, string Color, string Text returns string
return "|c" + Bright + Color + Text + "|r"
endfunction
function WordParser takes string ChatMsg, integer Word returns string
local string array Chkstr
local integer Last = 0
local integer A = 1
local integer I = 0
local integer Length = GetLength(ChatMsg)
loop
if(SubStringBJ(ChatMsg,A,A) == " ") then
if A != 1 and A != Length then
set Chkstr[I] = SubStringBJ(ChatMsg,(Last + 1),(A - 1))
set Last = A
set I = I + 1
endif
elseif(A == Length) then
set Chkstr[I] = SubStringBJ(ChatMsg,(Last + 1),A)
endif
set A = A + 1
exitwhen A > Length
exitwhen Word + 1 == I
endloop
return Chkstr[Word]
endfunction
function ShortcutNochNichtVerwendet takes integer Cut, integer Position returns boolean
local integer Index = Position
loop
exitwhen Index == Position + 13
exitwhen udg_zz_DialogShortcut[Index] == Cut
set Index = Index + 1
endloop
if udg_zz_DialogShortcut[Index] == Cut then
return false
endif
return true
endfunction
function StelleImString takes string B, string Teil returns integer
local integer Stelle = 1
set Teil = Uppercase(SubStringBJ(Teil,1,1))
loop
exitwhen SubStringBJ(B,Stelle,Stelle) == ""
exitwhen SubStringBJ(B,Stelle,Stelle) == Teil
set Stelle = Stelle + 1
endloop
if SubStringBJ(B,Stelle,Stelle) == Teil then
return Stelle
else
set Stelle = 1
set Teil = Lowercase(Teil)
loop
exitwhen SubStringBJ(B,Stelle,Stelle) == ""
exitwhen SubStringBJ(B,Stelle,Stelle) == Teil
set Stelle = Stelle + 1
endloop
if SubStringBJ(B,Stelle,Stelle) == Teil then
return Stelle
endif
endif
return 0
endfunction
function KeinShortcut takes string B, string FarbeText, string FarbeCut, integer Position, integer Additiv returns string
local integer Stelle = 1
local string Buchstabe
local integer Index = 48
local integer Ende = GetLength(B)
loop
set Buchstabe = Uppercase(SubStringBJ(B,Stelle,Stelle))
loop
exitwhen Index == 91
exitwhen Buchstabe == ""
exitwhen Buchstabe == udg_zz_ShortcutId[Index]
set Index = Index + 1
endloop
if Buchstabe == "" then
set udg_zz_DialogShortcut[Position + Additiv] = 0
return "|cff" + FarbeText + B + "|r"
elseif Index == 91 then
set Stelle = Stelle + 1
elseif Index <= 90 then
if ShortcutNochNichtVerwendet(Index,Position) == true then
set udg_zz_DialogShortcut[Position + Additiv] = Index
if Stelle != 1 then
if Stelle == Ende then
return "|cff" + FarbeText + SubStringBJ(B,1,Stelle - 1) + "|cff" + FarbeCut + SubStringBJ(B,Stelle,Stelle) + "|r"
else
return "|cff" + FarbeText + SubStringBJ(B,1,Stelle - 1) + "|cff" + FarbeCut + SubStringBJ(B,Stelle,Stelle) + "|r|cff" + FarbeText + SubStringBJ(B,Stelle + 1,Ende) + "|r"
endif
else
return "|cff" + FarbeCut + SubStringBJ(B,1,1) + "|r|cff" + FarbeText + SubStringBJ(B,2,Ende) + "|r"
endif
endif
set Stelle = Stelle + 1
endif
set Index = 48
endloop
return B
endfunction
function VerarbeiteString takes string B, integer C, string FarbeText, string FarbeCut, integer Position, integer Additiv returns string
local integer Stelle = 1
local string Buchstabe
local integer Index = 48
local integer Ende = GetLength(B)
if C == 0 then
return KeinShortcut(B,FarbeText,FarbeCut,Position,Additiv)
else
if ShortcutNochNichtVerwendet(C,Position) == true then
set Stelle = StelleImString(B,udg_zz_ShortcutId[C])
set udg_zz_DialogShortcut[Position + Additiv] = C
if Stelle == 0 then
return "|cff" + FarbeText + B + " (|r|cff" + FarbeCut + udg_zz_ShortcutId[C] + "|r|cff" + FarbeText + ")|r"
elseif Stelle == 1 then
return "|cff" + FarbeCut + SubStringBJ(B,1,1) + "|r|cff" + FarbeText + SubStringBJ(B,2,Ende) + "|r"
else
return "|cff" + FarbeText + SubStringBJ(B,1,Stelle - 1) + "|r|cff" + FarbeCut + SubStringBJ(B,Stelle,Stelle) + "|r|cff" + FarbeText + SubStringBJ(B,Stelle + 1,Ende) + "|r"
endif
else
return KeinShortcut(B,FarbeText,FarbeCut,Position,Additiv)
endif
endif
return B
endfunction
function ButtonMitShortcutHinzu takes string B, string F, integer C, string FarbeText, string FarbeShortcut, integer Spieler, integer Arrayposition, integer Index returns integer
if B != "" then
set B = VerarbeiteString(B,C,FarbeText,FarbeShortcut,Arrayposition,Index)
call DialogAddButtonWithHotkeyBJ(udg_zz_DialogSpieler[Spieler],B,udg_zz_DialogShortcut[Arrayposition + Index])
if F == "" then
set udg_zz_DialogAktion[Arrayposition + Index] = "DoNothing"
else
set udg_zz_DialogAktion[Arrayposition + Index] = F
endif
set udg_zz_DialogButton[Arrayposition + Index] = GetLastCreatedButtonBJ()
endif
set Index = Index + 1
return Index
endfunction
function InfoDialogMitShortcut takes player Spieler, string Label, string FarbeText, string FarbeShortcut, string B1, string F1, integer C1, string B2, string F2, integer C2, string B3, string F3, integer C3, string B4, string F4, integer C4, string B5, string F5, integer C5, string B6, string F6, integer C6 returns nothing
local integer Arrayposition = GetPlayerId(Spieler) * 12
local integer Index = 0
call DialogClearBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)])
call DialogSetMessageBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)],Label)
set Index = ButtonMitShortcutHinzu(B1,F1,C1,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B2,F2,C2,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B3,F3,C3,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B4,F4,C4,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B5,F5,C5,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B6,F6,C6,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
call DialogDisplayBJ(true,udg_zz_DialogSpieler[GetPlayerId(Spieler)],Spieler)
endfunction
function DialogMitShortcut takes player Spieler, string Label, string FarbeLabel, string FarbeText, string FarbeShortcut, string B1, string F1, integer C1, string B2, string F2, integer C2, string B3, string F3, integer C3, string B4, string F4, integer C4, string B5, string F5, integer C5, string B6, string F6, integer C6, boolean Show returns nothing
local integer Arrayposition = GetPlayerId(Spieler) * 12
local integer Index = 0
call DialogClearBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)])
call DialogSetMessageBJ(udg_zz_DialogSpieler[GetPlayerId(Spieler)],"|cff" + FarbeLabel + Label + "|r")
set Index = ButtonMitShortcutHinzu(B1,F1,C1,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B2,F2,C2,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B3,F3,C3,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B4,F4,C4,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B5,F5,C5,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B6,F6,C6,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
if Show == true then
call DialogDisplayBJ(true,udg_zz_DialogSpieler[GetPlayerId(Spieler)],Spieler)
endif
endfunction
function AddButtonsMitShortcut takes player Spieler, string FarbeText, string FarbeShortcut, string B7, string F7, integer C7, string B8, string F8, integer C8, string B9, string F9, integer C9, string B10, string F10, integer C10, string B11, string F11, integer C11, string B12, string F12, integer C12 returns nothing
local integer Arrayposition = GetPlayerId(Spieler) * 12
local integer Index = 6
set Index = ButtonMitShortcutHinzu(B7,F7,C7,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B8,F8,C8,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B9,F9,C9,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B10,F10,C10,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B11,F11,C11,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
set Index = ButtonMitShortcutHinzu(B12,F12,C12,FarbeText,FarbeShortcut,GetPlayerId(Spieler),Arrayposition,Index)
call DialogDisplayBJ(true,udg_zz_DialogSpieler[GetPlayerId(Spieler)],Spieler)
endfunction
function TertiaryStringOp takes boolean expr, string a, string b returns string
if (expr) then
return a
else
return b
endif
return b
endfunction
function DebugIdInteger2IdString takes integer value returns string
local string charMap = "..................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
local string result = ""
local integer remainingValue = value
local integer charValue
local integer byteno
set byteno = 0
loop
set charValue = ModuloInteger(remainingValue, 256)
set remainingValue = remainingValue / 256
set result = SubString(charMap, charValue, charValue + 1) + result
set byteno = byteno + 1
exitwhen byteno == 4
endloop
return result
endfunction
function IdString2DebugIdInteger takes string value returns integer
local string charMap = "..................................!.#$%&'()*+,-./0123456789:;<=>.@ABCDEFGHIJKLMNOPQRSTUVWXYZ[.]^_`abcdefghijklmnopqrstuvwxyz{|}~................................................................................................................................."
local integer Index = 1
local string CheckChar
local integer Ergebnis = 0
local integer Mod = 0
set CheckChar = SubStringBJ(value,1,1)
loop
exitwhen CheckChar == SubStringBJ(charMap,Index,Index)
set Index = Index + 1
endloop
set Ergebnis = (Index - 1) * 256
set CheckChar = SubStringBJ(value,2,2)
set Index = 1
loop
exitwhen CheckChar == SubStringBJ(charMap,Index,Index)
set Index = Index + 1
endloop
set Ergebnis = Ergebnis + Index - 1
set Ergebnis = Ergebnis * 256
set CheckChar = SubStringBJ(value,3,3)
set Index = 1
loop
exitwhen CheckChar == SubStringBJ(charMap,Index,Index)
set Index = Index + 1
endloop
set Ergebnis = Ergebnis + Index - 1
set Ergebnis = Ergebnis * 256
set CheckChar = SubStringBJ(value,4,4)
set Index = 1
loop
exitwhen CheckChar == SubStringBJ(charMap,Index,Index)
set Index = Index + 1
endloop
set Ergebnis = Ergebnis + Index - 1
return Ergebnis
endfunction
function Integer2HeroSpellId takes string S returns integer
return IdString2DebugIdInteger(S)
endfunction
function JoinAttachPoints takes string S, string S2 returns string
return S + S2
endfunction
function AssembleCode takes string S returns string
local integer L = GetLength(S)
local integer Rows = R2I(L / 5)
local integer Mod
local integer Lines
local string array New
local string Ret = ""
local integer Index = 1
local integer Zaehler = 0
local integer Dimension = 1
if Rows > 20 then
set Rows = 20
elseif Rows == 0 then
set Rows = 1
endif
set Mod = ModuloInteger(L,Rows)
set Lines = (L - Mod) / Rows
loop
exitwhen Index > L
set New[udg_zz_CodeRows[Zaehler] + Dimension * 20] = SubStringBJ(S,Index,Index)
set Index = Index + 1
set Zaehler = Zaehler + 1
if Zaehler >= Rows then
set Zaehler = Zaehler - Rows
set Dimension = Dimension + 1
endif
endloop
set Index = 0
loop
exitwhen GetLength(Ret) >= L
if Index < Mod then
set Ret = Ret + New[udg_zz_CodeRows[Index] + (Lines + 1) * 20]
endif
set Dimension = 1
loop
exitwhen Dimension > Lines
set Ret = Ret + New[udg_zz_CodeRows[Index] + (Lines - Dimension + 1) * 20]
set Dimension = Dimension + 1
endloop
set Index = Index + 1
endloop
return Ret
endfunction
function RegainCode takes string S returns string
local integer L = GetLength(S)
local integer Rows = R2I(L / 5)
local integer Mod
local integer Lines
local string array New
local string Ret = ""
local integer Index = 0
local integer Zaehler = 0
local integer Dimension = 0
if Rows > 20 then
set Rows = 20
elseif Rows == 0 then
set Rows = 1
endif
set Mod = ModuloInteger(L,Rows)
set Lines = (L - Mod) / Rows
loop
exitwhen Index >= L
if Dimension < Mod then
set Index = Index + 1
set New[udg_zz_CodeRows[Dimension] + (Lines + 1) * 20] = SubStringBJ(S,Index,Index)
endif
set Zaehler = 1
loop
exitwhen Zaehler > Lines
set Index = Index + 1
set New[udg_zz_CodeRows[Dimension] + (Lines - Zaehler + 1) * 20] = SubStringBJ(S,Index,Index)
set Zaehler = Zaehler + 1
endloop
set Dimension = Dimension + 1
endloop
set Index = 0
set Dimension = 1
set Zaehler = 1
loop
exitwhen Zaehler > L
if Index >= Rows then
set Dimension = Dimension + 1
set Index = Index - Rows
endif
set Ret = Ret + New[udg_zz_CodeRows[Index] + Dimension * 20]
set Index = Index + 1
set Zaehler = Zaehler + 1
endloop
return Ret
endfunction
function OneCharInt2CodeStr takes string S, integer Running returns string
local integer I = S2I(S)
if ModuloInteger(Running,2) == 1 then
return udg_zz_CodeIdA[I]
endif
return udg_zz_CodeIdB[I]
endfunction
function OneCharCodeStr2Int takes string S, integer Running returns string
local integer Index = 0
loop
exitwhen udg_zz_CodeIdA[Index] == S
exitwhen udg_zz_CodeIdB[Index] == S
set Index = Index + 1
endloop
return I2S(Index)
endfunction
function CodeStr2Int takes string S returns integer
local integer L = GetLength(S)
local integer Index = 1
local string Ret = ""
loop
set Ret = Ret + OneCharCodeStr2Int(SubStringBJ(S,Index,Index),Index)
exitwhen Index == L
set Index = Index + 1
endloop
return S2I(Ret)
endfunction
function Int2CodeStr takes integer I, integer Stellen returns string
local string S = I2S(I)
local integer L = GetLength(S)
local integer Index = 1
local string Ret = ""
loop
exitwhen GetLength(S) == Stellen
set S = "0" + S
endloop
set L = GetLength(S)
loop
set Ret = Ret + OneCharInt2CodeStr(SubStringBJ(S,Index,Index),Index)
exitwhen Index == L
set Index = Index + 1
endloop
return Ret
endfunction
function AddScores takes string S returns string
local string Ret = ""
local integer L = GetLength(S)
local integer Index = 1
local integer Counter = 0
loop
set Ret = Ret + SubStringBJ(S,Index,Index)
exitwhen Index == L
set Index = Index + 1
set Counter = Counter + 1
if Counter == 6 then
set Ret = Ret + "-"
set Counter = 0
endif
endloop
return Ret
endfunction
function DeleteSubStringFromString takes string S, string Char returns string
local integer Index = 1
local integer L = GetLength(S)
local integer CompLen = GetLength(Char)
local integer CurLen = 0
local string Current = ""
local string Ret = ""
loop
set Current = Current + SubStringBJ(S,Index,Index)
set CurLen = CurLen + 1
if Current != SubStringBJ(Char,1,GetLength(Current)) then
set Ret = Ret + Current
set CurLen = 0
set Current = ""
elseif CurLen == CompLen then
set CurLen = 0
set Current = ""
elseif Index >= L then
set Ret = Ret + Current
endif
exitwhen Index >= L
set Index = Index + 1
endloop
return Ret
endfunction
function DeleteCharFromString takes string S, string Char returns string
local integer Index = 1
local integer L = GetLength(S)
local string Current
local string Ret = ""
loop
set Current = SubStringBJ(S,Index,Index)
if Current != Char then
set Ret = Ret + Current
endif
exitwhen Index >= L
set Index = Index + 1
endloop
return Ret
endfunction
function SaveRestoredSkillcode takes integer id, integer skillctr, unit U returns nothing
local integer Uid = GetUniqueEinheitsnummer(U)
if skillctr == 1 then
set udg_zz_HeroSkill1[Uid] = id
elseif skillctr == 2 then
set udg_zz_HeroSkill2[Uid] = id
elseif skillctr == 3 then
set udg_zz_HeroSkill3[Uid] = id
elseif skillctr == 4 then
set udg_zz_HeroSkill4[Uid] = id
else
set udg_zz_HeroSkill5[Uid] = id
endif
endfunction
function RestoreHeroDataNew takes string S, player P, boolean storedLoc, location Loc returns nothing
local integer X
local integer Y
local integer UnitType
local unit U
local integer XP
local integer Life
local integer Mana
local integer Gold
local integer Lumber
local integer Index = 34
local integer Counter = 1
local integer Level
local integer Abilcount = 0
local integer TempCode
local integer skillctr = 0
local string pname
set S = DeleteCharFromString(S,"-")
set S = RegainCode(RegainCode(S))
if udg_zz_SaveLoadSettings[6] then
set pname = GetPlayerName(P)
if GetLength(pname) < 5 then
set Counter = 5 - GetLength(pname)
set pname = SubStringBJ(pname,1,GetLength(pname))
loop
set pname = pname + "Q"
set Counter = Counter - 1
exitwhen Counter <= 0
endloop
set Counter = 1
else
set pname = SubStringBJ(pname,1,5)
endif
if SubStringBJ(S,1,5) != pname then
call DisplayTimedTextToPlayer(P,0,0,5,"Wrong player profile")
return
endif
set UnitType = IdString2DebugIdInteger(SubStringBJ(S,6,9))
else
set UnitType = IdString2DebugIdInteger(SubStringBJ(S,1,4))
endif
if storedLoc then
if udg_zz_SaveLoadSettings[0] then
if udg_zz_SaveLoadSettings[6] then
set X = CodeStr2Int(SubStringBJ(S,15,17))
set Y = CodeStr2Int(SubStringBJ(S,18,20))
else
set X = CodeStr2Int(SubStringBJ(S,10,12))
set Y = CodeStr2Int(SubStringBJ(S,13,15))
endif
set X = X * 100
set Y = Y * 100
set X = X - 50000
set Y = Y - 50000
if udg_zz_SaveLoadSettings[6] then
set Index = 21
else
set Index = 16
endif
else
if udg_zz_SaveLoadSettings[6] then
set Index = 15
else
set Index = 10
endif
set X = 0
set Y = 0
endif
call CreateNUnitsAtLoc(1,UnitType,P,Location(I2R(X),I2R  (Y)),90)
else
call CreateNUnitsAtLoc(1,UnitType,P,Loc,90)
if udg_zz_SaveLoadSettings[6] then
set Index = 15
else
set Index = 10
endif
endif
set U = GetLastCreatedUnit()
if udg_zz_SaveLoadSettings[6] then
set XP = CodeStr2Int(SubStringBJ(S,10,14))
else
set XP = CodeStr2Int(SubStringBJ(S,5,9))
endif
call SetHeroLevelBJ(U,XP,false)
if udg_zz_SaveLoadSettings[1] then
set Life = CodeStr2Int(SubStringBJ(S,Index,Index + 1)) + 1
set Mana = CodeStr2Int(SubStringBJ(S,Index + 2,Index + 3)) + 1
set Index = Index + 4
if Life > 100 then
set Life = 100
endif
if Mana > 100 then
set Mana = 100
endif
endif
if udg_zz_SaveLoadSettings[2] then
call SetHeroStr(U,CodeStr2Int(SubStringBJ(S,Index,Index   + 1)),true)
call SetHeroAgi(U,CodeStr2Int(SubStringBJ(S,Index + 2,Index + 3)),true)
call SetHeroInt(U,CodeStr2Int(SubStringBJ(S,Index + 4,Index + 5)),true)
set Index = Index + 6
endif
if udg_zz_SaveLoadSettings[3] then
set Gold = CodeStr2Int(SubStringBJ(S,Index,Index + 3))
set Lumber = CodeStr2Int(SubStringBJ(S,Index + 4,Index + 7))
set Gold = Gold * 10
set Lumber = Lumber * 10
call SetPlayerStateBJ(P,PLAYER_STATE_RESOURCE_GOLD,Gold)
call SetPlayerStateBJ(P,PLAYER_STATE_RESOURCE_LUMBER,Lumber)
set Index = Index + 8
endif
if udg_zz_SaveLoadSettings[4] then
loop
if SubStringBJ(S,Index, Index) != "X" then
call UnitAddItemToSlotById(U,IdString2DebugIdInteger(SubStringBJ(S,Index,Index + 3)),Counter - 1)
set Index = Index + 4
else
set Index = Index + 1
endif
exitwhen Counter == 6
set Counter = Counter + 1
endloop
endif
if udg_zz_SaveLoadSettings[5] then
loop
set Counter = 0
if CodeStr2Int(SubStringBJ(S,Index, Index)) > 0 then
set Level = CodeStr2Int(SubStringBJ(S,Index, Index))
set TempCode = IdString2DebugIdInteger(SubStringBJ(S,Index + 1,Index + 4))
set skillctr = skillctr + 1
call SaveRestoredSkillcode(TempCode,skillctr,U)
loop
call SelectHeroSkill(U,TempCode)
set Counter = Counter + 1
exitwhen Counter == Level
endloop
set Index = Index + 5
else
set Index = Index + 1
endif
set Abilcount = Abilcount + 1
exitwhen Abilcount == 5
endloop
endif
if udg_zz_SaveLoadSettings[1] then
call SetUnitLifePercentBJ(U,I2R(Life))
call SetUnitManaPercentBJ(U,I2R(Mana))
endif
set bj_lastCreatedUnit = U
endfunction
function RestoreHeroData takes string S, player P returns nothing
call RestoreHeroDataNew(S,P,true,GetRectCenter(GetPlayableMapRect()))
endfunction
function RestoreHeroAtLoc takes string S, player P, location L returns nothing
call RestoreHeroDataNew(S,P,false,L)
endfunction
function IsUpperCaseLetter takes string S returns boolean
if S == "A" or S == "B" or S == "C" or S == "D" or S == "E" or S == "F" or S == "G" or S == "H" or S == "I" or S == "J" or S == "K" or S == "L" or S == "M" or S == "N" or S == "O" or S == "P" or S == "Q" then
return true
elseif S == "R" or S == "S" or S == "T" or S == "U" or S == "V" or S == "W" or S == "X" or S == "Y" or S == "Z" then
return true
endif
return false
endfunction
function IsLowerCaseLetter takes string S returns boolean
if S == "a" or S == "b" or S == "c" or S == "d" or S == "e" or S == "f" or S == "g" or S == "h" or S == "i" or S == "j" or S == "k" or S == "l" or S == "m" or S == "n" or S == "o" or S == "p" or S == "q" then
return true
elseif S == "r" or S == "s" or S == "t" or S == "u" or S == "v" or S == "w" or S == "x" or S == "y" or S == "z" then
return true
endif
return false
endfunction
function ColorHeroCode takes string S returns string
local integer L = GetLength(S)
local integer Index = 1
local string Ret = ""
local string Temp
loop
exitwhen Index > L
set Temp = SubStringBJ(S,Index,Index)
if IsUpperCaseLetter(Temp) then
set Ret = Ret + "|cff33ffff" + Temp + "|r"
elseif IsLowerCaseLetter(Temp) then
set Ret = Ret + "|cffffccff" + Temp + "|r"
else
set Ret = Ret + "|cffffcc00" + Temp + "|r"
endif
set Index = Index + 1
endloop
return Ret
endfunction
function SaveHeroData takes unit U, player P returns nothing
local integer Id = GetUniqueEinheitsnummer(U)
local string Code = ""
local integer XP
local integer X
local integer Y
local integer Life
local integer Mana
local integer Agi
local integer Str
local integer Int
local integer Gold
local integer Lumber
local integer Uid
local string Final
local string pname
local integer Counter = 0
if IsUnitType(U,UNIT_TYPE_HERO) == false then
return
endif
if udg_zz_SaveLoadSettings[6] then
set pname = GetPlayerName(P)
if GetLength(pname) < 5 then
set Counter = 5 - GetLength(pname)
set pname = SubStringBJ(pname,1,GetLength(pname))
loop
set pname = pname + "Q"
set Counter = Counter - 1
exitwhen Counter <= 0
endloop
else
set pname = SubStringBJ(pname,1,5)
endif
set Code = pname
set Code = Code + DebugIdInteger2IdString(GetUnitTypeId(U))
else
set Code = DebugIdInteger2IdString(GetUnitTypeId(U))
endif
set XP=GetHeroLevel(U)
if XP>99999 then
set XP=99999
elseif XP<1 then
set XP=1
endif
set Code=Code+Int2CodeStr(XP,5)
if udg_zz_SaveLoadSettings[0] then
set X = R2I(GetUnitX(U))
set Y = R2I(GetUnitY(U))
if X < - 50000 then
set X = - 50000
endif
if X >= 50000 then
set X = 49999
endif
set X = X + 50000
if Y < - 50000 then
set Y = - 50000
endif
if Y >= 50000 then
set Y = 49999
endif
set Y = Y + 50000
set X = X / 100
set Y = Y / 100
set Code = Code + Int2CodeStr(X,3)
set Code = Code + Int2CodeStr(Y,3)
endif
if udg_zz_SaveLoadSettings[1] then
set Life = R2I(GetUnitLifePercent(U) - 1)
set Mana = R2I(GetUnitManaPercent(U) - 1)
if Life <= 0 then
set Life = 0
endif
if Mana < 0 then
set Mana = 0
endif
set Code = Code + Int2CodeStr(Life,2)
set Code = Code + Int2CodeStr(Mana,2)
endif
if udg_zz_SaveLoadSettings[2] then
set Str = GetHeroStatBJ(bj_HEROSTAT_STR,U,false)
set Agi = GetHeroStatBJ(bj_HEROSTAT_AGI,U,false)
set Int = GetHeroStatBJ(bj_HEROSTAT_INT,U,false)
if Agi > 99 then
set Agi = 99
endif
if Str > 99 then
set Str = 99
endif
if Int > 99 then
set Int = 99
endif
set Code = Code + Int2CodeStr(Str,2)
set Code = Code + Int2CodeStr(Agi,2)
set Code = Code + Int2CodeStr(Int,2)
endif
if udg_zz_SaveLoadSettings[3] then
set Gold = GetPlayerState(GetOwningPlayer(U),PLAYER_STATE_RESOURCE_GOLD)
set Lumber = GetPlayerState(GetOwningPlayer(U),PLAYER_STATE_RESOURCE_LUMBER)
if Gold > 99999 then
set Gold = 99999
endif
if Lumber > 99999 then
set Lumber = 99999
endif
set Gold = Gold / 10
set Lumber = Lumber / 10
set Code = Code + Int2CodeStr(Gold,4)
set Code = Code + Int2CodeStr(Lumber,4)
endif
if udg_zz_SaveLoadSettings[4] then
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,1) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,1))),"X")
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,2) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,2))),"X")
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,3) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,3))),"X")
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,4) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,4))),"X")
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,5) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,5))),"X")
set Code = Code + TertiaryStringOp(UnitItemInSlotBJ(U,6) != null,DebugIdInteger2IdString(GetItemTypeId(UnitItemInSlotBJ(U,6))),"X")
endif
if udg_zz_SaveLoadSettings[5] then
set Uid = GetUniqueEinheitsnummer(U)
set Code = Code + Int2CodeStr(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill1[Uid],U),1)
set Code = Code + TertiaryStringOp(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill1[Uid],U) > 0,DebugIdInteger2IdString(udg_zz_HeroSkill1[Uid]),"")
set Code = Code + Int2CodeStr(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill2[Uid],U),1)
set Code = Code + TertiaryStringOp(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill2[Uid],U) > 0,DebugIdInteger2IdString(udg_zz_HeroSkill2[Uid]),"")
set Code = Code + Int2CodeStr(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill3[Uid],U),1)
set Code = Code + TertiaryStringOp(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill3[Uid],U) > 0,DebugIdInteger2IdString(udg_zz_HeroSkill3[Uid]),"")
set Code = Code + Int2CodeStr(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill4[Uid],U),1)
set Code = Code + TertiaryStringOp(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill4[Uid],U) > 0,DebugIdInteger2IdString(udg_zz_HeroSkill4[Uid]),"")
set Code = Code + Int2CodeStr(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill5[Uid],U),1)
set Code = Code + TertiaryStringOp(GetUnitAbilityLevelSwapped(udg_zz_HeroSkill5[Uid],U) > 0,DebugIdInteger2IdString(udg_zz_HeroSkill5[Uid]),"")
endif
set Final = ColorHeroCode(AddScores(AssembleCode(AssembleCode(Code))))
call DisplayTimedTextToPlayer(P,0,0,180,Final)
endfunction
function SetHeroSaveLoadOptions takes boolean Value, integer Op returns nothing
set udg_zz_SaveLoadSettings[Op] = Value
endfunction
function Integer2UnitId takes string Zahl returns integer
return IdString2DebugIdInteger(Zahl)
endfunction
function Integer2ItemId takes string Zahl returns integer
return IdString2DebugIdInteger(Zahl)
endfunction
function Integer2DoodadId takes string Zahl returns integer
return IdString2DebugIdInteger(Zahl)
endfunction
function Integer2SpellId takes string Zahl returns integer
return IdString2DebugIdInteger(Zahl)
endfunction
function TriggerName2Function takes string S returns string
local integer L = GetLength(S)
local integer Index = 1
local string Temp
local string Ret = "Trig_"
loop
set Temp = SubStringBJ(S,Index,Index)
if Temp == " " then
set Ret = Ret + "_"
else
set Ret = Ret + Temp
endif
exitwhen Index == L
set Index = Index + 1
endloop
set Ret = Ret + "_Actions"
return Ret
endfunction
function GetTheTriggerOrderString takes nothing returns string
return OrderId2StringBJ(GetIssuedOrderIdBJ())
endfunction
function String2PointOrder takes string S returns string
return S
endfunction
function String2UnitOrder takes string S returns string
return S
endfunction
function String2DestOrder takes string S returns string
return S
endfunction
function String2NoOrder takes string S returns string
return S
endfunction
function AddAnyUnitIssuedAnyOrderEvent takes trigger Trig returns nothing
local integer Index = 0
loop
call TriggerRegisterPlayerUnitEventSimple(Trig,Player(Index),EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
call TriggerRegisterPlayerUnitEventSimple(Trig,Player(Index),EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
call TriggerRegisterPlayerUnitEventSimple(Trig,Player(Index),EVENT_PLAYER_UNIT_ISSUED_ORDER)
exitwhen Index == 11
set Index = Index + 1
endloop
endfunction
function RegisterNewDamageEvent takes nothing returns nothing
call GetUniqueEinheitsnummer(GetEnumUnit())
call TriggerRegisterUnitEvent(udg_zz_AnyDamageTrig,GetEnumUnit(),EVENT_UNIT_DAMAGED)
endfunction
function AnyDamageActions takes nothing returns nothing
set udg_zz_DamageTaken = 100
set udg_zz_DamageTaken = 0
endfunction
function AnyDamageEvent takes trigger T returns nothing
call TriggerRegisterVariableEvent(T,"udg_zz_DamageTaken",EQUAL,100.00)
endfunction
function String2Colorhex takes string S returns string
return S
endfunction
function GetAnzahlSpieler takes nothing returns integer
local integer Index = 0
local integer Anzahl = 0
loop
if GetPlayerSlotState(Player(Index)) == PLAYER_SLOT_STATE_PLAYING then
if GetPlayerController(Player(Index)) == MAP_CONTROL_USER then
if IsPlayerObserver(Player(Index)) == false then
set Anzahl = Anzahl + 1
endif
endif
endif
exitwhen Index == 11
set Index = Index + 1
endloop
return Anzahl
endfunction
function Dez2Hex takes integer I returns string
if I < 10 and I >= 0 then
return I2S(I)
elseif I == 10 then
return "a"
elseif I == 11 then
return "b"
elseif I == 12 then
return "c"
elseif I == 13 then
return "d"
elseif I == 14 then
return "e"
elseif I == 15 then
return "f"
endif
return I2S(I)
endfunction
function OneCharDezToHex takes integer I returns integer
set udg_zz_ModuloHex = ModuloInteger(I,16)
set I = I - udg_zz_ModuloHex
return I / 16
endfunction
function Dez2HexS takes integer I returns string
local string array Stelle
local integer Index = 0
local string Sum = ""
loop
set I = OneCharDezToHex(I)
set Stelle[Index] = Dez2Hex(udg_zz_ModuloHex)
exitwhen I == 0
set Index = Index + 1
endloop
loop
set Sum = Sum + Stelle[Index]
exitwhen Index == 0
set Index = Index - 1
endloop
return Sum
endfunction
function Hex2Dez takes string S returns integer
if S == "0" or S == "1" or S == "2" or S == "3" or S == "4" or S == "5" or S == "6" or S == "7" or S == "8" or S == "9" then
return S2I(S)
elseif S == "a" then
return 10
elseif S == "b" then
return 11
elseif S == "c" then
return 12
elseif S == "d" then
return 13
elseif S == "e" then
return 14
elseif S == "f" then
return 15
endif
return S2I(S)
endfunction
function HexS2Dez takes string S returns integer
local integer array Zahl
local integer Index = 0
local integer Zaehler = 0
local integer Sum = 0
local integer Length = GetLength(S)
loop
set Zahl[Index] = Hex2Dez(SubStringBJ(S,Index + 1, Index + 1))
exitwhen Index + 1 == Length
set Index = Index + 1
endloop
loop
exitwhen Index == 0
set Zahl[Zaehler] = R2I(Zahl[Zaehler]*Pow(16.00,I2R(Index)))
exitwhen Index == 1
set Zaehler = Zaehler + 1
set Index = Index - 1
endloop
set Index = 0
loop
set Sum = Sum + Zahl[Index]
exitwhen Index + 1 == Length
set Index = Index + 1
endloop
return Sum
endfunction
function CombineColor takes integer I returns string
local string array Converted
local integer Index = 0
loop
set Converted[Index] = Dez2HexS(udg_zz_Anfangsfarbe[Index] + R2I(I*udg_zz_Farbinterval[Index]))
if GetLength(Converted[Index]) == 1 then
set Converted[Index] = "0" + Converted[Index]
endif
exitwhen Index == 2
set Index = Index + 1
endloop
return Converted[0] + Converted[1] + Converted[2]
endfunction
function Farbverlauf takes string Anfangsfarbe, string Endfarbe, string Text returns string
local integer L = GetLength(Text)
local integer array Ende
local integer array Abstand
local string Result = ""
local integer Index = 0
local integer array Modifikator
set udg_zz_Anfangsfarbe[0] = HexS2Dez(SubStringBJ(Anfangsfarbe,1,2))
set udg_zz_Anfangsfarbe[1] = HexS2Dez(SubStringBJ(Anfangsfarbe,3,4))
set udg_zz_Anfangsfarbe[2] = HexS2Dez(SubStringBJ(Anfangsfarbe,5,6))
set Ende[0] = HexS2Dez(SubStringBJ(Endfarbe,1,2))
set Ende[1] = HexS2Dez(SubStringBJ(Endfarbe,3,4))
set Ende[2] = HexS2Dez(SubStringBJ(Endfarbe,5,6))
set Abstand[0] = Ende[0] - udg_zz_Anfangsfarbe[0]
set Abstand[1] = Ende[1] - udg_zz_Anfangsfarbe[1]
set Abstand[2] = Ende[2] - udg_zz_Anfangsfarbe[2]
loop
if Abstand[Index] < 0 then
set Modifikator[Index] = Abstand[Index] + 1
else
set Modifikator[Index] = Abstand[Index] - 1
endif
set udg_zz_Farbinterval[Index] = (I2R(Abstand[Index])/I2R(L)) + (1.00/I2R(Modifikator[Index]))
exitwhen Index == 2
set Index = Index + 1
endloop
set Index = 0
loop
set Result = Result + "|cff" + CombineColor(Index) + SubStringBJ(Text,Index + 1,Index + 1) + "|r"
exitwhen Index + 1 == L
set Index = Index + 1
endloop
return Result
endfunction
function HidePortraits takes force F returns nothing
call ShowInterfaceForceOff(F,0.00)
call ShowInterfaceForceOn(F,0.00)
endfunction
function Ix takes integer x, integer y returns integer
return(x*12+y)
endfunction
function ClearBonus takes unit who,integer t returns nothing
local integer i=0
loop
call UnitRemoveAbilityBJ(udg_zz_BnsBit[Ix(t,i)],who)
exitwhen i==11
set i=i+1
endloop
endfunction
function GetBonus takes unit who,integer t returns integer
local integer array bit
local integer i=1
local integer bonus=0
set bit[0]=1
loop
set bit[i]=bit[i-1]*2
exitwhen i==11
set i=i+1
endloop
set i=i+1
loop
if (UnitRemoveAbilityBJ(udg_zz_BnsBit[Ix(t,i)],who)==true) then
call UnitAddAbilityBJ(udg_zz_BnsBit[Ix(t,i)],who)
set bonus=bonus+bit[i]
endif
exitwhen i==0
set i=i-1
endloop
return (bonus)
endfunction
function SetBonus takes integer amount,unit who,integer t returns boolean
local integer bonus=amount
local integer array bit
local integer i=1
set bit[0]=1
loop
set bit[i]=bit[i-1]*2
exitwhen i==11
set i=i+1
endloop
call ClearBonus(who,t)
loop
if (bonus>=bit[i]) then
call UnitAddAbilityBJ(udg_zz_BnsBit[Ix(t,i)],who)
set bonus=bonus-bit[i]
endif
exitwhen i==0
set i=i-1
endloop
return (amount<=4095 and t<=3 and t>=0 and amount>=0 and who!=null)
endfunction
function AddBonus takes integer amount,unit who,integer t returns boolean
return SetBonus((GetBonus(who,t)+amount),who,t)
endfunction
function ChangeManaRegeneration takes player Spieler, boolean Increase, integer Race, real Percent returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_ManaRegenUpgr[Race]
else
set Type = udg_zz_ManaRegenUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + R2I(10*Percent) > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+R2I(10*Percent),Spieler)
endif
endfunction
function ChangeLifeRegeneration takes player Spieler, boolean Increase, integer Race, real Percent returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_LifeRegenUpgr[Race]
else
set Type = udg_zz_LifeRegenUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + R2I(Percent*10) > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+R2I(Percent*10),Spieler)
endif
endfunction
function ChangeAttackDices takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_AttackDiceUpgr[Race]
else
set Type = udg_zz_AttackDiceUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + Zahl > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+Zahl,Spieler)
endif
endfunction
function ChangeLeeching takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,5)
endfunction
function ChangeSightRange takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,4)
endfunction
function ChangeMana takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,3)
endfunction
function ChangeLife takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,2)
endfunction
function ChangeDamage takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,0)
endfunction
function ChangeDefense takes unit U, boolean Increase, integer Zahl returns nothing
if not Increase then
set Zahl = 0 - Zahl
endif
call AddBonus(Zahl,U,1)
endfunction
function ChangeRange takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_RangeUpgr[Race]
else
set Type = udg_zz_RangeUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + Zahl > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+Zahl,Spieler)
endif
endfunction
function ChangeAttackRate takes player Spieler, boolean Increase, integer Race, real Percent returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_AttackRateUpgr[Race]
else
set Type = udg_zz_AttackRateUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + R2I(10*Percent) > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+R2I(10*Percent),Spieler)
endif
endfunction
function ChangeMoveRate takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_MoveRateUpgr[Race]
else
set Type = udg_zz_MoveRateUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + Zahl > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+Zahl,Spieler)
endif
endfunction
function ChangeMissileTargets takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
local integer Type
if Increase == true then
set Type = udg_zz_TargetUpgr[Race]
else
set Type = udg_zz_TargetUpgr[Race + 4]
endif
if GetPlayerTechCountSimple(Type,Spieler) + Zahl > 4095 then
call SetPlayerTechResearchedSwap(Type,4095,Spieler)
else
call SetPlayerTechResearchedSwap(Type,GetPlayerTechCountSimple(Type,Spieler)+Zahl,Spieler)
endif
endfunction
function GetManaRegenBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_ManaRegenUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_ManaRegenUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetRelativeManaRegenBonus takes player Spieler, integer Race returns real
return GetManaRegenBonus(Spieler,Race)/10.00
endfunction
function GetLifeRegenBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_LifeRegenUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_LifeRegenUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetRelativeLifeRegenBonus takes player Spieler, integer Race returns real
return GetLifeRegenBonus(Spieler,Race)/10.00
endfunction
function GetCurrentAttackDiceBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_AttackDiceUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_AttackDiceUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetCurrentLeechingBonus takes unit U returns integer
return GetBonus(U,5)
endfunction
function GetCurrentSightRangeBonus takes unit U returns integer
return GetBonus(U,4)
endfunction
function GetCurrentManaBonus takes unit U returns integer
return GetBonus(U,3)
endfunction
function GetCurrentLifeBonus takes unit U returns integer
return GetBonus(U,2)
endfunction
function GetCurrentDamageBonus takes unit U returns integer
return GetBonus(U,0)
endfunction
function GetCurrentDefenseBonus takes unit U returns integer
return GetBonus(U,1)
endfunction
function GetCurrentRangeBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_RangeUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_RangeUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetAttackRateBonusPercent takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_AttackRateUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_AttackRateUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetRelativeAttackRateBonus takes player Spieler, integer Race returns real
return GetAttackRateBonusPercent(Spieler,Race)/10.00
endfunction
function GetCurrentMoveRateBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_MoveRateUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_MoveRateUpgr[Race + 4],Spieler)
return Differenz
endfunction
function GetCurrentMissileBonus takes player Spieler, integer Race returns integer
local integer Differenz = GetPlayerTechCountSimple(udg_zz_TargetUpgr[Race],Spieler) - GetPlayerTechCountSimple(udg_zz_TargetUpgr[Race + 4],Spieler)
return Differenz
endfunction
function MJIstHeld takes nothing returns boolean
return IsUnitType(GetFilterUnit(),UNIT_TYPE_HERO) == true
endfunction
function HasHeroItemOfClass takes unit U, itemtype Class returns boolean
local integer Index = 0
loop
if UnitItemInSlot(U,Index) != null then
if GetItemType(UnitItemInSlot(U,Index)) == Class then
return true
endif
endif
exitwhen Index == 5
set Index = Index + 1
endloop
return false
endfunction
function ForItemsOfTypeCondition takes nothing returns boolean
return GetItemTypeId(GetFilterItem()) == udg_zz_EnumItemType
endfunction
function ForItemsOfType takes integer Type, code Func returns nothing
local filterfunc F = Filter(function ForItemsOfTypeCondition)
set udg_zz_EnumItemType = Type
call EnumItemsInRect(GetEntireMapRect(),F,Func)
call DestroyFilter(F)
set F = null
endfunction
function ForItemsOfClassCondition takes nothing returns boolean
return GetItemType(GetFilterItem()) == udg_zz_EnumItemTypeT
endfunction
function ForItemsOfClass takes itemtype Class, code Func returns nothing
local filterfunc F = Filter(function ForItemsOfClassCondition)
set udg_zz_EnumItemTypeT = Class
call EnumItemsInRect(GetEntireMapRect(),F,Func)
call DestroyFilter(F)
set F = null
endfunction
function IsItemWorn takes item I returns boolean
local integer IndexA = 0
local integer IndexB = 0
local group G = CreateGroup()
local unit U
call GroupEnumUnitsInRect(G,GetEntireMapRect(),null)
loop
set U = FirstOfGroup(G)
exitwhen U == null
loop
if UnitItemInSlot(U,IndexB) == I then
call DestroyGroup(G)
set G = null
return true
endif
exitwhen IndexB == 5
set IndexB = IndexB + 1
endloop
set IndexB = 0
call GroupRemoveUnit(G,U)
endloop
call DestroyGroup(G)
set G = null
return false
endfunction
function ItemExistsInGameAction takes nothing returns nothing
set udg_zz_ForRectItem = true
endfunction
function ItemExistsInGameCondition takes nothing returns boolean
return GetItemType(GetFilterItem()) == udg_zz_EnumItemTypeT
endfunction
function ItemOfClassExistsInGame takes itemtype Class returns boolean
local filterfunc F = Filter(function ItemExistsInGameCondition)
set udg_zz_EnumItemTypeT = Class
call EnumItemsInRect(GetEntireMapRect(),F,function ItemExistsInGameAction)
call DestroyFilter(F)
set F = null
if udg_zz_ForRectItem == true then
set udg_zz_ForRectItem = false
return true
endif
return false
endfunction
function TurnHeroDiedMsgOn takes boolean On returns nothing
if On == true then
call EnableTrigger(udg_zz_HeroDiedMsg)
else
call DisableTrigger(udg_zz_HeroDiedMsg)
endif
endfunction
function TurnPlayerLeftMsgOn takes boolean On returns nothing
if On == true then
call EnableTrigger(udg_zz_PlayerLeftMsg)
else
call DisableTrigger(udg_zz_PlayerLeftMsg)
endif
endfunction
function TurnRegrowingTreesOn takes boolean On returns nothing
if On == true then
call EnableTrigger(udg_zz_RegrowingTrees)
else
call DisableTrigger(udg_zz_RegrowingTrees)
endif
endfunction
function AHeroDies_Condition takes nothing returns boolean
return IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO) == true
endfunction
function AHeroDies_Actions takes nothing returns nothing
call SetUnitOwner(GetTriggerUnit(),Player(PLAYER_NEUTRAL_PASSIVE),false)
endfunction
function APlayerLeft_Condition takes nothing returns boolean
return IsPlayerObserver(GetTriggerPlayer()) == false
endfunction
function APlayerLeft_Actions takes nothing returns nothing
local integer Index = 0
loop
call DisplayTimedTextToPlayer(Player(Index),0,0,5,"Player " + I2S(GetPlayerId(GetTriggerPlayer())) + " has left the game.")
exitwhen Index == 1
set Index = Index + 1
endloop
call CachePlayerHeroData(GetTriggerPlayer())
call MakeUnitsPassiveForPlayer(GetTriggerPlayer())
endfunction
function Regrowth_Actions takes nothing returns nothing
local real Zeit = 5
local destructable Baum = GetDyingDestructable()
call PolledWait(Zeit)
call DestructableRestoreLife(Baum,GetDestructableMaxLife(Baum),true)
endfunction
function RegRegrowingTrees takes nothing returns nothing
if GetDestructableTypeId(GetEnumDestructable()) == 'LTlt' or GetDestructableTypeId(GetEnumDestructable()) == 'NTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'WTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'WTst' or GetDestructableTypeId(GetEnumDestructable()) == 'YTct' then
call TriggerRegisterDeathEvent(udg_zz_RegrowingTrees,GetEnumDestructable())
elseif GetDestructableTypeId(GetEnumDestructable()) == 'YTwt' or GetDestructableTypeId(GetEnumDestructable()) == 'YTst' or GetDestructableTypeId(GetEnumDestructable()) == 'YTft' or GetDestructableTypeId(GetEnumDestructable()) == 'VTlt' or GetDestructableTypeId(GetEnumDestructable()) == 'ATtr' then
call TriggerRegisterDeathEvent(udg_zz_RegrowingTrees,GetEnumDestructable())
elseif GetDestructableTypeId(GetEnumDestructable()) == 'BTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'CTtr' or GetDestructableTypeId(GetEnumDestructable()) == 'FTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'ZTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'ITtw' then
call TriggerRegisterDeathEvent(udg_zz_RegrowingTrees,GetEnumDestructable())
elseif GetDestructableTypeId(GetEnumDestructable()) == 'ATtc' or GetDestructableTypeId(GetEnumDestructable()) == 'OTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'KTtw' or GetDestructableTypeId(GetEnumDestructable()) == 'JTct' or GetDestructableTypeId(GetEnumDestructable()) == 'JTtw' then
call TriggerRegisterDeathEvent(udg_zz_RegrowingTrees,GetEnumDestructable())
elseif GetDestructableTypeId(GetEnumDestructable()) == 'BTtc' or GetDestructableTypeId(GetEnumDestructable()) == 'CTtc' or GetDestructableTypeId(GetEnumDestructable()) == 'NTtc' or GetDestructableTypeId(GetEnumDestructable()) == 'ZTtc' or GetDestructableTypeId(GetEnumDestructable()) == 'ITtc' then
call TriggerRegisterDeathEvent(udg_zz_RegrowingTrees,GetEnumDestructable())
endif
endfunction
function IsFriendlyPlayerTPOpen takes player P returns boolean
local boolean Open = false
local integer I = 0
loop
if udg_zz_TPOpen[I] == true then
if P == Player(I) or IsPlayerAlly(P,Player(I)) then
set Open = true
endif
endif
exitwhen I == 11
set I = I + 1
endloop
return Open
endfunction
function PlayerHasPortalOpened takes player P returns boolean
if GetPlayerId(P) > 11 then
return false
endif
return udg_zz_TPOpen[GetPlayerId(P)]
endfunction
function GetFriendlyPlayerTPIndex takes player P returns integer
local integer Index = -1
local integer I = 0
loop
if IsPlayerAlly(P,Player(I)) == true or (P == Player(I)) then
if udg_zz_TPOpen[I] == true then
set Index = I
endif
endif
exitwhen I == 11
set I = I + 1
endloop
return Index
endfunction
function TPOpenCount takes nothing returns integer
local integer Index = 0
local integer Count = 0
loop
if udg_zz_TPOpen[Index] == true then
set Count = Count + 1
endif
exitwhen Index == 11
set Index = Index + 1
endloop
return Count
endfunction
function Geschlossen_Conditions takes nothing returns boolean
local integer Id = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
if GetPlayerController(GetOwningPlayer(GetTriggerUnit())) != MAP_CONTROL_USER then
return false
endif
if udg_zz_TPOpen[Id] == true then
set udg_zz_TPPointer = Id
return true
endif
if GetFriendlyPlayerTPIndex(GetOwningPlayer(GetTriggerUnit())) == -1 then
if TPOpenCount() > 0 then
call DisplayTimedTextToPlayer(GetOwningPlayer(GetTriggerUnit()),0,0,4.00,"Another unit has already closed your portal.")
endif
return false
endif
set udg_zz_TPPointer = GetFriendlyPlayerTPIndex(GetOwningPlayer(GetTriggerUnit()))
return true
endfunction
function Geschlossen_Actions takes nothing returns nothing
local integer Id = udg_zz_TPPointer
set udg_zz_TPWatchersB = 1
set udg_zz_TPWatchersB = 0
call SetUnitPositionLoc(GetTriggerUnit(),OffsetLocation(GetRectCenter(udg_zz_TPEingang[Id]),0,-200.00))
call TriggerSleepAction(0.01)
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call PanCameraToTimedLocForPlayer(GetOwningPlayer(GetTriggerUnit()),GetUnitLoc(GetTriggerUnit()),0)
call TriggerSleepAction(0.01)
call DestroyEffectBJ(udg_zz_PortaleffektA[Id])
set udg_zz_PortaleffektA[Id] = null
if TPOpenCount() <= 1 then
call DestroyEffectBJ(udg_zz_PortaleffektB)
set udg_zz_PortaleffektB = null
endif
call SetSoundPositionLocBJ(udg_zz_DefendCaster,GetRectCenter(udg_zz_TPEingang[Id]),0)
call PlaySoundBJ(udg_zz_DefendCaster)
set udg_zz_TPOpen[Id] = false
endfunction
function Offen_Conditions takes nothing returns boolean
local integer Id = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
local integer Index = 0
local integer Pid = -1
if GetPlayerController(GetOwningPlayer(GetTriggerUnit())) != MAP_CONTROL_USER then
return false
endif
if IsFriendlyPlayerTPOpen(GetOwningPlayer(GetTriggerUnit())) == false then
return false
endif
loop
if DistanceBetweenPoints(GetUnitLoc(GetTriggerUnit()),GetRectCenter(udg_zz_TPEingang[Index])) < 200.00 then
set Pid = Index
endif
exitwhen Index == 11
set Index = Index + 1
endloop
if Pid == -1 then
return false
endif
if udg_zz_TPOpen[Pid] == false then
return false
endif
if IsPlayerAlly(Player(Pid),GetOwningPlayer(GetTriggerUnit())) == false then
return false
endif
return true
endfunction
function Offen_Actions takes nothing returns nothing
set udg_zz_TPWatchersA = 1
set udg_zz_TPWatchersA = 0
call SetUnitPositionLoc(GetTriggerUnit(),OffsetLocation(GetRectCenter(udg_zz_TPCenter),0,-200.00))
call TriggerSleepAction(0.01)
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call PanCameraToTimedLocForPlayer(GetOwningPlayer(GetTriggerUnit()),GetUnitLoc(GetTriggerUnit()),0)
endfunction
function Stadtportal_Conditions takes nothing returns boolean
if GetItemTypeId(GetManipulatedItem()) == 'Ix00' then
return true
endif
return false
endfunction
function Stadtportal_Actions takes nothing returns nothing
local integer Id = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
local integer Index = 0
if RectContainsUnit(udg_zz_TPNextTown,GetTriggerUnit()) then
call DisplayTimedTextToPlayer(GetOwningPlayer(GetTriggerUnit()),0,0,3.00,"You are already in the town.")
call TriggerSleepAction(0.01)
call UnitAddItemByIdSwapped('Ix00',GetTriggerUnit())
return
endif
if udg_zz_TPOpen[Id] == true then
call DestroyEffectBJ(udg_zz_PortaleffektA[Id])
set udg_zz_PortaleffektA[Id] = null
if TPOpenCount() < 1 then
call DestroyEffectBJ(udg_zz_PortaleffektB)
set udg_zz_PortaleffektB = null
endif
call SetSoundPositionLocBJ(udg_zz_DefendCaster,GetRectCenter(udg_zz_TPCenter),0)
call PlaySoundBJ(udg_zz_DefendCaster)
call TriggerSleepAction(0.01)
endif
set udg_zz_TPEingang[Id] = RectFromCenterSizeBJ(OffsetLocation(GetUnitLoc(GetManipulatingUnit()),0,200.00),150.00,150.00)
call AddSpecialEffectLocBJ(GetRectCenter(udg_zz_TPEingang[Id]),"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdx")
set udg_zz_PortaleffektA[Id] = GetLastCreatedEffectBJ()
if TPOpenCount() == 0 then
call AddSpecialEffectLocBJ(GetRectCenter(udg_zz_TPCenter),"Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTo.mdx")
set udg_zz_PortaleffektB = GetLastCreatedEffectBJ()
endif
call SetSoundPositionLocBJ(udg_zz_DivineShield,GetRectCenter(udg_zz_TPEingang[Id]),0)
call PlaySoundBJ(udg_zz_DivineShield)
call ResetTrigger(udg_zz_PortaltriggerA)
loop
call TriggerRegisterEnterRectSimple(udg_zz_PortaltriggerA,udg_zz_TPEingang[Index])
exitwhen Index == 11
set Index = Index + 1
endloop
call TriggerAddCondition(udg_zz_PortaltriggerA,Condition(function Offen_Conditions))
call TriggerAddAction(udg_zz_PortaltriggerA,function Offen_Actions)
set udg_zz_TPOpen[Id] = true
endfunction
function InitTownPortalSystem takes rect Town, location Ziel returns nothing
local trigger Stadtportal = CreateTrigger()
local integer Index = 0
set udg_zz_TPWatchersA = 0
set udg_zz_TPWatchersB = 0
set udg_zz_PortaltriggerB = CreateTrigger()
set udg_zz_PortaltriggerA = CreateTrigger()
set udg_zz_TPCenter = RectFromLoc(OffsetLocation(Ziel,-100,-100),OffsetLocation(Ziel,100,100))
set udg_zz_TPNextTown = Town
call TriggerRegisterAnyUnitEventBJ(Stadtportal,EVENT_PLAYER_UNIT_USE_ITEM)
call TriggerAddCondition(Stadtportal, Condition(function Stadtportal_Conditions))
call TriggerAddAction(Stadtportal, function Stadtportal_Actions)
call TriggerRegisterEnterRectSimple(udg_zz_PortaltriggerB,udg_zz_TPCenter)
call TriggerAddCondition(udg_zz_PortaltriggerB,Condition(function Geschlossen_Conditions))
call TriggerAddAction(udg_zz_PortaltriggerB,function Geschlossen_Actions)
loop
set udg_zz_TPOpen[Index] = false
exitwhen Index == 11
set Index = Index + 1
endloop
endfunction
function AddTownPortalEvent takes trigger T, boolean Enter returns nothing
if Enter then
call TriggerRegisterVariableEvent(T,"udg_zz_TPWatchersA",EQUAL,1.00)
else
call TriggerRegisterVariableEvent(T,"udg_zz_TPWatchersB",EQUAL,1.00)
endif
endfunction
function GetTPCenter takes nothing returns location
return GetRectCenter(udg_zz_TPCenter)
endfunction
function GetCurrentTPTargetPointOfPlayer takes player P returns location
return GetRectCenter(udg_zz_TPEingang[GetPlayerId(P)])
endfunction
function HasPlayerTPOpen takes player P returns boolean
return udg_zz_TPOpen[GetPlayerId(P)]
endfunction
function OnlyHeros takes nothing returns boolean
if IsUnitType(GetTriggerUnit(),UNIT_TYPE_HERO) then
return true
endif
return false
endfunction
function OnlyGroup takes nothing returns boolean
if IsUnitInGroup(GetTriggerUnit(),udg_zz_TPRestrictGroup) then
return true
endif
return false
endfunction
function OnlyType takes nothing returns boolean
if GetUnitTypeId(GetTriggerUnit()) == udg_zz_TPRestrictType then
return true
endif
return false
endfunction
function RestrictTPToHeros takes nothing returns nothing
if udg_zz_TPCondition[0] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerA,udg_zz_TPCondition[0])
endif
if udg_zz_TPCondition[1] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerB,udg_zz_TPCondition[1])
endif
set udg_zz_TPCondition[0] = TriggerAddCondition(udg_zz_PortaltriggerA,Condition(function OnlyHeros))
set udg_zz_TPCondition[1] = TriggerAddCondition(udg_zz_PortaltriggerB,Condition(function OnlyHeros))
endfunction
function RestrictTPToType takes integer Type returns nothing
set udg_zz_TPRestrictType = Type
if udg_zz_TPCondition[0] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerA,udg_zz_TPCondition[0])
endif
if udg_zz_TPCondition[1] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerB,udg_zz_TPCondition[1])
endif
set udg_zz_TPCondition[0] = TriggerAddCondition(udg_zz_PortaltriggerA,Condition(function OnlyType))
set udg_zz_TPCondition[1] = TriggerAddCondition(udg_zz_PortaltriggerB,Condition(function OnlyType))
endfunction
function RestrictTPToGroup takes group G returns nothing
set udg_zz_TPRestrictGroup = G
if udg_zz_TPCondition[0] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerA,udg_zz_TPCondition[0])
endif
if udg_zz_TPCondition[1] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerB,udg_zz_TPCondition[1])
endif
set udg_zz_TPCondition[0] = TriggerAddCondition(udg_zz_PortaltriggerA,Condition(function OnlyGroup))
set udg_zz_TPCondition[1] = TriggerAddCondition(udg_zz_PortaltriggerB,Condition(function OnlyGroup))
endfunction
function TPRemoveRestrictions takes nothing returns nothing
if udg_zz_TPCondition[0] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerA,udg_zz_TPCondition[0])
endif
if udg_zz_TPCondition[1] != null then
call TriggerRemoveCondition(udg_zz_PortaltriggerB,udg_zz_TPCondition[1])
endif
endfunction
function DreistelligerInteger takes integer I returns string
local string S
if I < 0 then
set S = "000"
elseif I < 10 then
set S = "00" + I2S(I)
elseif I < 100 then
set S = "0" + I2S(I)
elseif I < 1000 then
set S = I2S(I)
else
set S = "999"
endif
return S
endfunction
function GetWTSString takes integer Nr returns string
local string S
call SetPlayerName(Player(12),"TRIGSTR_" + DreistelligerInteger(Nr))
set S = GetPlayerName(Player(12))
return S
endfunction
function AutomaticMemoryCleanup takes boolean On returns nothing
set bj_wantDestroyGroup = true
endfunction
function AddHeroGlow takes string Col, unit U, boolean Big returns nothing
endfunction
function ChangeManaOld takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
endfunction
function ChangeLifeOld takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
endfunction
function ChangeDamageOld takes player Spieler, boolean Increase, integer Race, integer Zahl returns nothing
endfunction
function GetCurrentManaBonusOld takes player Spieler, integer Race returns integer
return 0
endfunction
function GetCurrentLifeBonusOld takes player Spieler, integer Race returns integer
return 0
endfunction
function GetCurrentDamageBonusOld takes player Spieler, integer Race returns integer
return 0
endfunction
function AddHeroGlowNew takes unit U returns nothing
call UnitAddAbilityBJ('Ax0J',U)
call SetUnitColor(U,GetPlayerColor(GetOwningPlayer(U)))
endfunction
function RemoveHeroGlow takes unit U returns nothing
call UnitRemoveAbilityBJ('Ax0J',U)
endfunction
function Itemcode2Dummyitem takes integer I returns integer
return I
endfunction
function SetMidiAmbientSound takes string MidiFile returns nothing
call SetAmbientDaySound("Roland")
call SetAmbientNightSound("Roland")
call StopMusicBJ(true)
call PolledWait(2.00)
call PlayMusicBJ(MidiFile)
endfunction
function Xor takes boolean A, boolean B returns boolean
return not A == B
endfunction
function CreateItemWithChargesLoc takes integer Id, integer Charges, location L returns nothing
endfunction
function CreateItemWithChargesForHero takes integer Id, integer Charges, unit Un returns nothing
endfunction
function CreateDestructableZBJ takes integer objectid, real x, real y, real z, real face, real scale, integer variation returns nothing
set bj_lastCreatedDestructable = CreateDestructableZ(objectid,x,y,z,face,scale,variation)
endfunction
function CreateDeadDestructableZBJ takes integer objectid, real x, real y, real z, real face, real scale, integer variation returns nothing
set bj_lastCreatedDestructable = CreateDeadDestructableZ(objectid,x,y,z,face,scale,variation)
endfunction
function MDLPath2Burnstyle takes string S returns string
return S
endfunction
function EvaluateBoolexpr takes boolexpr expr returns boolean
local trigger trg = CreateTrigger()
local boolean b
call TriggerAddCondition(trg, expr)
set b = TriggerEvaluate(trg)
call DestroyTrigger(trg)
set trg = null
return b
endfunction
function AsciiIntegerToChar takes integer i returns string
if i == 0 then
return null
elseif i >= 8 and i <= 10 then
return SubString("\b\t\n", i - 8, i - 7)
elseif i >= 12 and i <= 13 then
return SubString("\f\r", i - 12, i - 11)
elseif i >= 32 and i <= 127 then
return SubString(" !\"#$%%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", i - 32, i - 31)
endif
return ""
endfunction
function AsciiCharToInteger takes string char returns integer
local string charMap = " !\"#$%%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
local string u = SubString(char, 0, 1)
local string c
local integer i = 0
if u == "" or u == null then
return 0
elseif u == "\b" then
return 8
elseif u == "\t" then
return 9
elseif u == "\n" then
return 10
elseif u == "\f" then
return 12
elseif u == "\r" then
return 13
endif
loop
set c = SubString(charMap, i, i + 1)
exitwhen c == ""
if c == u then
return i + 32
endif
set i = i + 1
endloop
return 0
endfunction
function TeamColor2RGB takes playercolor col, string RGB returns integer
if RGB == "R" then
if col == PLAYER_COLOR_RED or col == PLAYER_COLOR_YELLOW or col == PLAYER_COLOR_ORANGE or col == PLAYER_COLOR_PINK then
return 255
elseif col == PLAYER_COLOR_BLUE or col == PLAYER_COLOR_AQUA or col == PLAYER_COLOR_CYAN or col == PLAYER_COLOR_GREEN then
return 000
elseif col == PLAYER_COLOR_PURPLE or col == PLAYER_COLOR_LIGHT_BLUE then
return 128
elseif col == PLAYER_COLOR_LIGHT_GRAY then
return 192
elseif col == PLAYER_COLOR_BROWN then
return 064
endif
elseif RGB == "G" then
if col == PLAYER_COLOR_RED or col == PLAYER_COLOR_BLUE or col == PLAYER_COLOR_PURPLE or col == PLAYER_COLOR_PINK then
return 000
elseif col == PLAYER_COLOR_CYAN or col == PLAYER_COLOR_YELLOW or col == PLAYER_COLOR_GREEN then
return 255
elseif col == PLAYER_COLOR_ORANGE then
return 128
elseif col == PLAYER_COLOR_LIGHT_GRAY or col == PLAYER_COLOR_LIGHT_BLUE then
return 192
elseif col == PLAYER_COLOR_AQUA or col == PLAYER_COLOR_BROWN then
return 064
endif
endif
if col == PLAYER_COLOR_RED or col == PLAYER_COLOR_YELLOW or col == PLAYER_COLOR_ORANGE or col == PLAYER_COLOR_GREEN or col == PLAYER_COLOR_BROWN then
return 000
elseif col == PLAYER_COLOR_BLUE or col == PLAYER_COLOR_PINK or col == PLAYER_COLOR_LIGHT_BLUE then
return 255
elseif col == PLAYER_COLOR_CYAN or col == PLAYER_COLOR_LIGHT_GRAY then
return 192
elseif col == PLAYER_COLOR_PURPLE then
return 128
elseif col == PLAYER_COLOR_AQUA then
return 064
endif
return 000
endfunction
function SmartCameraPanND takes player whichPlayer, location loc, real duration returns nothing
local real dist
local real x = GetLocationX(loc)
local real y = GetLocationY(loc)
if (GetLocalPlayer() == whichPlayer) then
set dist = SquareRoot(((GetCameraTargetPositionX() - x) * (GetCameraTargetPositionX() - x)) + ((GetCameraTargetPositionY() - y) * (GetCameraTargetPositionY() - y)))
if (dist >= bj_SMARTPAN_TRESHOLD_SNAP) then
call PanCameraToTimed(x, y, 0)
elseif (dist >= bj_SMARTPAN_TRESHOLD_PAN) then
call PanCameraToTimed(x, y, duration)
endif
endif
endfunction
function AngleDifference takes real A, real B returns real
if A > B then
if A - B < 180 then
return A - B
else
return 360 - (A - B)
endif
elseif B - A < 180 then
return B - A
endif
return 360 - (B - A)
endfunction
function DisableKeyboardScrolling takes player P, location Center, real Time returns nothing
call SetCameraBoundsToRectForPlayerBJ(P,RectFromCenterSizeBJ(Center,0.00,0.00))
call PanCameraToTimedLocForPlayer(P,Center,Time)
endfunction
function EnableKeyboardScrolling takes player P returns nothing
call SetCameraBoundsToRectForPlayerBJ(P,GetCameraBoundsMapRect())
endfunction
function PolarProjectionY takes real y, real angle, real distance returns real
return y + SinBJ(angle)*distance
endfunction
function PolarProjectionX takes real x, real angle, real distance returns real
return x + CosBJ(angle)*distance
endfunction
function DistanceBetweenPointsXY takes real x1, real y1, real x2, real y2 returns real
return SquareRoot((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2))
endfunction
function AngleBetweenPointsXY takes real x1, real y1, real x2, real y2 returns real
return Atan2BJ((y2-y1),(x2-x1))
endfunction
function PlaySoundForPlayer takes player whichPlayer, sound whichSound returns nothing
if ( whichPlayer == GetLocalPlayer() ) then
call PlaySoundBJ( whichSound )
endif
endfunction
function DistanceBetweenPointsXYZ takes real x1, real y1, real z1, real x2, real y2, real z2 returns real
return SquareRoot((x1 - x2)*(x1 - x2)+(y1 - y2)*(y1 - y2)+(z1 - z2)*(z1 - z2))
endfunction
function GetIssuedOrderItem takes nothing returns item
if not (GetIssuedOrderId() >= 852008) and (GetIssuedOrderId() <= 852013) then
return null
endif
return(UnitItemInSlot(GetTriggerUnit(), (GetIssuedOrderId()-852008)))
endfunction
function GetIssuedOrderItemSlot takes nothing returns integer
if not (GetIssuedOrderId() >= 852008) and (GetIssuedOrderId() <= 852013) then
return 0
endif
return(GetIssuedOrderId()-852007)
endfunction
function IsRectInRegion takes region whichRegion, rect whichRect returns boolean
return (IsPointInRegion(whichRegion, GetRectMinX(whichRect), GetRectMinY(whichRect))) and (IsPointInRegion(whichRegion, GetRectMaxX(whichRect), GetRectMinY(whichRect))) and (IsPointInRegion(whichRegion, GetRectMaxX(whichRect), GetRectMaxY(whichRect))) and (IsPointInRegion(whichRegion, GetRectMinX(whichRect), GetRectMaxY(whichRect)))
endfunction
function FadingText_child takes nothing returns nothing
local integer alpha=255
local integer red=S2I(SubString(bj_cineFadeContinueTex,1,4))
local integer green=S2I(SubString(bj_cineFadeContinueTex,4,7))
local integer blue=S2I(SubString(bj_cineFadeContinueTex,7,10))
local texttag t= bj_lastCreatedTextTag
call DestroyTrigger(GetTriggeringTrigger())
call TriggerSleepAction(1.00)
loop
set alpha=alpha - 32
exitwhen alpha <= 0
call SetTextTagColor(t,red,green,blue,alpha)
call TriggerSleepAction(0.01)
endloop
call DestroyTextTag(t)
set t = null
endfunction
function FadingText takes string msg, integer red, integer green, integer blue, real x, real y returns nothing
local texttag t = CreateTextTag()
local trigger child = CreateTrigger()
call SetTextTagText(t,msg,0.025)
call SetTextTagPos(t,x,y, 0.00)
call SetTextTagColor(t,red,green,blue,255)
call SetTextTagVelocity(t,0,0.02)
call TriggerAddAction(child, function FadingText_child)
set bj_lastCreatedTextTag=t
set bj_cineFadeContinueTex=I2S(1000000000 + red * 1000000 + green * 1000 + blue)
call TriggerExecute(child)
endfunction
function GoldText_child takes nothing returns nothing
local texttag t = bj_lastCreatedTextTag
local integer alpha = 55
call DestroyTrigger(GetTriggeringTrigger())
call TriggerSleepAction(1.00)
loop
set alpha=alpha - 64
exitwhen alpha <= 0
call SetTextTagColor(t,255,220,0,alpha)
call TriggerSleepAction(0.01)
endloop
call DestroyTextTag(t)
set t = null
endfunction
function GoldText takes integer bounty, real x, real y returns nothing
local texttag t = CreateTextTag()
local trigger child = CreateTrigger()
call SetTextTagText(t,"+"+I2S(bounty),0.025)
call SetTextTagPos(t,x,y, 0.00)
call SetTextTagColor(t,255,220,0,255)
call SetTextTagVelocity(t,0,0.02)
call TriggerAddAction(child, function GoldText_child)
set bj_lastCreatedTextTag=t
call TriggerExecute(child)
endfunction
function MissText_child takes nothing returns nothing
local texttag t = bj_lastCreatedTextTag
local integer alpha = 255
call DestroyTrigger(GetTriggeringTrigger())
call TriggerSleepAction(1.00)
loop
set alpha=alpha - 32
exitwhen alpha <= 0
call SetTextTagColor(t,255,0,0,alpha)
call TriggerSleepAction(0.01)
endloop
call DestroyTextTag(t)
set t = null
endfunction
function MissText takes real x, real y returns nothing
local texttag t = CreateTextTag()
local trigger child = CreateTrigger()
call SetTextTagText(t,"miss",0.025)
call SetTextTagPos(t,x,y, 0.00)
call SetTextTagColor(t,255,0,0,255)
call SetTextTagVelocity(t,0,0.02)
call TriggerAddAction(child, function MissText_child)
set bj_lastCreatedTextTag = t
call TriggerExecute(child)
endfunction
function StopSpellFromCasting takes unit U returns nothing
call DisableTrigger(GetTriggeringTrigger())
call PauseUnitBJ(true,U)
call IssueImmediateOrderBJ(U,"stop")
call PauseUnitBJ(false,U)
call TriggerSleepAction(0.01)
call EnableTrigger(GetTriggeringTrigger())
endfunction
function WaitForPlayerEvent takes player P, playerevent E, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerEvent(T,P,E)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForGameEvent takes gameevent E, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterGameEvent(T,E)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForPlayerUnitEvent takes player P, playerunitevent E, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerUnitEventSimple(T,P,E)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForSpecificUnitEvent takes unit U, unitevent E, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterUnitEvent(T,U,E)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForGenericUnitEvent takes playerunitevent E, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(T,E)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForDeathEvent takes destructable D, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterDeathEvent(T,D)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForDeathInRegionEvent takes rect R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterDestDeathInRegionEvent(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForDialogEvent takes dialog D, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterDialogEventBJ(T,D)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTimeOfDayEvent takes limitop L, real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterGameStateEventTimeOfDay(T,L,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForChatEvent takes player P, string S, boolean B, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerChatEvent(T,P,S,B)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForSelectionEvent takes player P, boolean B, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerSelectionEventBJ(T,P,B)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForPlayerstateEvent takes player P, playerstate PS, limitop L, real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerStateEvent(T,P,PS,L,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForAllianceEvent takes player P, alliancetype A, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerAllianceChange(T,P,A)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForGamestateEvent takes igamestate GS, limitop L, integer I, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterGameStateEvent(T,GS,L,I)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForUnitstateEvent takes unit U, unitstate US, limitop L, real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterUnitStateEvent(T,U,US,L,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTimerEventSingle takes real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterTimerEventSingle(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTimerExpireEvent takes timer T, real Time returns nothing
local trigger D = CreateTrigger()
call TriggerRegisterTimerExpireEventBJ(D,T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(D) > 0
endloop
call DestroyTrigger(D)
set D = null
endfunction
function WaitForConditionalPlayerUnitEvent takes player P, playerunitevent PU, boolexpr B, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterPlayerUnitEvent(T,P,PU,B)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForEnterRectEvent takes rect R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterEnterRectSimple(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForLeaveRectEvent takes rect R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterLeaveRectSimple(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForRangeEvent takes real R, unit U, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterUnitInRangeSimple(T,R,U)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForLifeEvent takes unit U, limitop L, real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterUnitLifeEvent(T,U,L,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForManaEvent takes unit U, limitop L, real R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterUnitManaEvent(T,U,L,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForEnterRecEvent takes region R, boolexpr B, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterEnterRegion(T,R,B)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForLeaveRecEvent takes region R, boolexpr B, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterLeaveRegion(T,R,B)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForAnyOrderEvent takes real Time returns nothing
local trigger T = CreateTrigger()
call AddAnyUnitIssuedAnyOrderEvent(T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForAnyDamageEvent takes real Time returns nothing
local trigger T = CreateTrigger()
call AnyDamageEvent(T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForEnterSimpleRecEvent takes region R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterEnterRegionSimple(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForLeaveSimpleRecEvent takes region R, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterLeaveRegionSimple(T,R)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function AddSelectSpecificHeroEvent takes trigger T returns nothing
call TriggerRegisterVariableEvent(T,"udg_zz_DetectSelected",EQUAL,1.00)
endfunction
function AddSelectRandomHeroEvent takes trigger T returns nothing
call TriggerRegisterVariableEvent(T,"udg_zz_DetectRandom",EQUAL,1.00)
endfunction
function WaitForSelectSpecificHeroEvent takes real Time returns nothing
local trigger T = CreateTrigger()
call AddSelectSpecificHeroEvent(T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForSelectRandomHeroEvent takes real Time returns nothing
local trigger T = CreateTrigger()
call AddSelectRandomHeroEvent(T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTownPortalEvent takes boolean Enter, real Time returns nothing
local trigger T = CreateTrigger()
call AddTownPortalEvent(T,Enter)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTrackableHitEvent takes trackable Track, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterTrackableHitEvent(T,Track)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function WaitForTrackableTrackEvent takes trackable Track, real Time returns nothing
local trigger T = CreateTrigger()
call TriggerRegisterTrackableTrackEvent(T,Track)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function SpellTargeted_Condition takes nothing returns boolean
if GetTriggerEventId() != EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER then
return true
endif
if OrderId2StringBJ(GetIssuedOrderIdBJ()) == "attack" or OrderId2StringBJ(GetIssuedOrderIdBJ()) == "smart" then
return false
endif
if GetOrderTargetUnit() != null then
return true
endif
return false
endfunction
function NoCommonOrderString takes nothing returns boolean
if OrderId2StringBJ(GetIssuedOrderIdBJ()) == "attack" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "smart" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "load" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "repair" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "renew" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "restoration" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "load" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "board" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "loadarcher" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "loadcorpse" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "revive" then
return false
endif
return true
endfunction
function AUnitIsTargetedByASpell takes trigger T returns nothing
local integer Index = 0
loop
call TriggerRegisterPlayerUnitEventSimple(T,Player(Index),EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
call TriggerAddCondition(T,Condition(function NoCommonOrderString))
exitwhen Index == 15
if Index == 13 then
set Index = 15
else
set Index = Index + 1
endif
endloop
call TriggerAddCondition(T,Condition(function SpellTargeted_Condition))
endfunction
function WaitForSpellTargetEvent takes real Time returns nothing
local trigger T = CreateTrigger()
call AUnitIsTargetedByASpell(T)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function GetLastCreatedMultiboardBJ takes nothing returns multiboard
return null
endfunction
function CreateMultiboardItemBJ takes multiboard lb, integer row, integer column returns nothing
endfunction
function GetLastCreatedMultiboardItemBJ takes nothing returns multiboarditem
return null
endfunction
function DestroyMovingSpecialEffect takes integer I returns nothing
set udg_zz_MovingSFXLoop[I] = false
call DestroyEffectBJ(udg_zz_MovingSFX[I])
set udg_zz_MovingSFX[I] = null
call DestroyTrigger(udg_zz_MovingSFXTrigger[I])
set udg_zz_MovingSFXTrigger[I] = null
set udg_zz_MovingSFXKilled[I] = true
endfunction
function GetIndexOfLastMovingSFX takes nothing returns integer
return udg_zz_LastCreatedMovingSFX
endfunction
function GetTriggeringSFXTriggerIndex takes trigger T returns integer
local integer Index = 1
loop
exitwhen udg_zz_MovingSFXTrigger[Index] == T
if Index == udg_zz_MovingSFXLength then
return -1
endif
set Index = Index + 1
endloop
return Index
endfunction
function MovingSFX_Actions takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local real Angle = 0
local real Dist = 0
call VolumeGroupSetVolumeBJ(SOUND_VOLUMEGROUP_SPELLS,0.00)
if udg_zz_MovingSFXType[L] == 0 then
if udg_zz_MovingSFXNr[L] / 2 > udg_zz_MovingSFXCounter[L] then
set Dist = udg_zz_MovingSFXAbstand[L]*((udg_zz_MovingSFXNr[L] / 2) - udg_zz_MovingSFXCounter[L])
set Angle = udg_zz_MovingSFXStartAngle[L]
else
set Dist = udg_zz_MovingSFXAbstand[L]*(udg_zz_MovingSFXCounter[L] - (udg_zz_MovingSFXNr[L] /2))
if udg_zz_MovingSFXStartAngle[L] >= 180 then
set Angle = udg_zz_MovingSFXStartAngle[L] - 180
else
set Angle = udg_zz_MovingSFXStartAngle[L] + 180
endif
endif
elseif udg_zz_MovingSFXType[L] == 1 or udg_zz_MovingSFXType[L] == 3 or udg_zz_MovingSFXType[L] == 5 then
set Dist = udg_zz_MovingSFXRadius[L]
set Angle = udg_zz_MovingSFXStartAngle[L] + udg_zz_MovingSFXAbstand[L]*udg_zz_MovingSFXCounter[L]
if Angle > 360 then
set Angle = Angle - 360
endif
elseif udg_zz_MovingSFXType[L] == 2 or udg_zz_MovingSFXType[L] == 4 or udg_zz_MovingSFXType[L] == 6 then
set Dist = udg_zz_MovingSFXRadius[L]
set Angle = udg_zz_MovingSFXStartAngle[L] - udg_zz_MovingSFXAbstand[L]*udg_zz_MovingSFXCounter[L]
if Angle < 0 then
set Angle = Angle + 360
endif
endif
set udg_zz_MovingSFX[L] = AddSpecialEffectLocBJ(PolarProjectionBJ(udg_zz_MovingSFXCenter[L],Dist,Angle),udg_zz_MovingSFXPath[L])
set udg_zz_MovingSFXCounter[L] = udg_zz_MovingSFXCounter[L] + 1
call PolledWait(udg_zz_MovingSFXWait[L])
if udg_zz_MovingSFXCounter[L] == udg_zz_MovingSFXNr[L] then
if udg_zz_MovingSFXLoop[L] == true then
set udg_zz_MovingSFXCounter[L] = 0
else
call DestroyEffectBJ(udg_zz_MovingSFX[L])
set udg_zz_MovingSFX[L] = null
return
endif
endif
call DestroyEffectBJ(udg_zz_MovingSFX[L])
set udg_zz_MovingSFX[L] = null
call VolumeGroupSetVolumeBJ(SOUND_VOLUMEGROUP_SPELLS,100.00)
call TriggerExecute(GetTriggeringTrigger())
endfunction
function ActionAnd takes code A, code B returns nothing
call TriggerClearActions(udg_zz_ActionAndTrig)
call TriggerAddAction(udg_zz_ActionAndTrig,A)
call TriggerAddAction(udg_zz_ActionAndTrig,B)
call TriggerExecute(udg_zz_ActionAndTrig)
endfunction
function Rect2Region takes rect Rec returns region
local region R = CreateRegion()
call RegionAddRect(R,Rec)
return R
endfunction
function MorphUnit takes unit U, integer Abil returns nothing
call UnitAddAbilityBJ(Abil, U)
endfunction
function HasUnitAbility takes unit U, integer Abil returns boolean
return GetUnitAbilityLevel(U,Abil) > 0
endfunction
function RemoveBasicAbility takes integer Abil, unit U returns nothing
if Abil == 0 then
call UnitRemoveAbilityBJ('ANbu',U)
call UnitRemoveAbilityBJ('AHbu',U)
call UnitRemoveAbilityBJ('AObu',U)
call UnitRemoveAbilityBJ('AEbu',U)
call UnitRemoveAbilityBJ('AUbu',U)
call UnitRemoveAbilityBJ('AGbu',U)
elseif Abil == 1 then
call UnitRemoveAbilityBJ('Afir',U)
call UnitRemoveAbilityBJ('Afih',U)
call UnitRemoveAbilityBJ('Afio',U)
call UnitRemoveAbilityBJ('Afin',U)
call UnitRemoveAbilityBJ('Afiu',U)
elseif Abil == 2 then
call UnitRemoveAbilityBJ('Aren',U)
call UnitRemoveAbilityBJ('Ahrp',U)
call UnitRemoveAbilityBJ('Arep',U)
call UnitRemoveAbilityBJ('Arst',U)
elseif Abil == 3 then
call UnitRemoveAbilityBJ('Argd',U)
call UnitRemoveAbilityBJ('Argl',U)
call UnitRemoveAbilityBJ('Arlm',U)
elseif Abil == 4 then
call UnitRemoveAbilityBJ('Aloa',U)
call UnitRemoveAbilityBJ('Sloa',U)
call UnitRemoveAbilityBJ('Slo2',U)
call UnitRemoveAbilityBJ('Slo3',U)
call UnitRemoveAbilityBJ('Atlp',U)
elseif Abil == 5 then
call UnitRemoveAbilityBJ('Adri',U)
call UnitRemoveAbilityBJ('Adro',U)
call UnitRemoveAbilityBJ('Sdro',U)
call UnitRemoveAbilityBJ('Atdp',U)
elseif Abil == 6 then
call UnitRemoveAbilityBJ('Awha',U)
call UnitRemoveAbilityBJ('Awh2',U)
call UnitRemoveAbilityBJ('Aaha',U)
call UnitRemoveAbilityBJ('Ahar',U)
call UnitRemoveAbilityBJ('ANha',U)
call UnitRemoveAbilityBJ('Ahrl',U)
call UnitRemoveAbilityBJ('Ahr3',U)
call UnitRemoveAbilityBJ('Ahr2',U)
elseif Abil == 7 then
call UnitRemoveAbilityBJ('Arev',U)
call UnitRemoveAbilityBJ('Aawa',U)
elseif Abil == 8 then
call UnitRemoveAbilityBJ('Adet',U)
call UnitRemoveAbilityBJ('Adt1',U)
call UnitRemoveAbilityBJ('Adta',U)
else
call UnitRemoveAbilityBJ(Abil,U)
endif
endfunction
function IsPointUnbuildable takes location L returns boolean
local integer Index = 1
loop
exitwhen Index > udg_zz_NoBuildIndex
if udg_zz_NoBuildRects[Index] != null then
if RectContainsLoc(udg_zz_NoBuildRects[Index],L) then
return true
endif
endif
set Index = Index + 1
endloop
return false
endfunction
function BuildOff_Conditions takes nothing returns boolean
if OrderId2StringBJ(GetIssuedOrderIdBJ()) == "smart" then
return false
elseif not IsUnitType(GetTriggerUnit(),UNIT_TYPE_PEON) then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "move" then
return false
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "attackground" then
return false
elseif not IsPointUnbuildable(GetOrderPointLoc()) then
return false
endif
return true
endfunction
function IsRectUnbuildable takes rect R returns boolean
local integer Index = 1
loop
exitwhen Index > udg_zz_NoBuildIndex
if udg_zz_NoBuildRects[Index] == R then
return true
endif
set Index = Index + 1
endloop
return false
endfunction
function StopBuildOrder takes nothing returns nothing
call DisableTrigger(GetTriggeringTrigger())
call PauseUnitBJ(true,GetTriggerUnit())
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call PauseUnitBJ(false,GetTriggerUnit())
call TriggerSleepAction(0.01)
call EnableTrigger(GetTriggeringTrigger())
endfunction
function AddUnbuildableRect takes rect R returns nothing
if not IsRectUnbuildable(R) then
if udg_zz_NoBuildIndex == 0 then
set udg_zz_NoBuildTrig = CreateTrigger()
call TriggerRegisterAnyUnitEventBJ(udg_zz_NoBuildTrig,EVENT_PLAYER_UNIT_ISSUED_POINT_ORDER)
call TriggerAddCondition(udg_zz_NoBuildTrig,Condition(function BuildOff_Conditions))
call TriggerAddAction(udg_zz_NoBuildTrig,function StopBuildOrder)
endif
set udg_zz_NoBuildIndex = udg_zz_NoBuildIndex + 1
set udg_zz_NoBuildRects[udg_zz_NoBuildIndex] = R
endif
endfunction
function RemoveUnbuildableRect takes rect R returns nothing
local integer Index = 1
loop
exitwhen Index > udg_zz_NoBuildIndex
if udg_zz_NoBuildRects[Index] == R then
set udg_zz_NoBuildRects[Index] = null
return
endif
set Index = Index + 1
endloop
endfunction
function BuildOff takes rect R, boolean Off returns nothing
if Off then
call AddUnbuildableRect(R)
else
call RemoveUnbuildableRect(R)
endif
endfunction
function GetFreeMovingSFXIndex takes nothing returns integer
local integer Index = 0
loop
if udg_zz_MovingSFXKilled[Index] then
return Index
endif
exitwhen Index == udg_zz_MovingSFXLength
set Index = Index + 1
endloop
set udg_zz_MovingSFXLength = udg_zz_MovingSFXLength + 1
return udg_zz_MovingSFXLength
endfunction
function CreateMovingSFX takes integer Type, string Path, location Start, location End, integer Nr, real Wait, boolean DoLoop returns nothing
local real Abstand = 0
local location Center
local integer L = 0
set L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_LastCreatedMovingSFX = L
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function MovingSFX_Actions)
set udg_zz_MovingSFXWait[L] = Wait
set Center = PolarProjectionBJ(Start,DistanceBetweenPoints(Start,End) / 2,AngleBetweenPoints(Start,End))
set udg_zz_MovingSFXCenter[L] = Start
set udg_zz_MovingSFXStartAngle[L] = AngleBetweenPoints(End,Start)
set udg_zz_MovingSFXType[L] = Type
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXLoop[L] = DoLoop
set udg_zz_MovingSFXCounter[L] = 0
set udg_zz_MovingSFXNr[L] = Nr
if Type == 0 then
set Abstand = DistanceBetweenPoints(Start,End) / Nr
elseif Type == 1 or Type == 2 then
set Abstand = 180 / Nr
elseif Type == 3 or Type == 4 then
set Abstand = 90 / Nr
set udg_zz_MovingSFXCenter[L] = End
else
set Abstand = 360 / Nr
set udg_zz_MovingSFXCenter[L] = PolarProjectionBJ(Start,DistanceBetweenPoints(Start,End),AngleBetweenPoints(Start,End))
endif
set udg_zz_MovingSFXRadius[L] = DistanceBetweenPoints(Start,End) / 2
set udg_zz_MovingSFXAbstand[L] = Abstand
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function MovingSFXUnit_Actions takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local real Angle = 0
call VolumeGroupSetVolumeBJ(SOUND_VOLUMEGROUP_SPELLS,0.00)
if udg_zz_MovingSFXType[L] == 5 then
set Angle = udg_zz_MovingSFXStartAngle[L] + udg_zz_MovingSFXCounter[L] * udg_zz_MovingSFXAbstand[L]
elseif udg_zz_MovingSFXType[L] == 6 then
set Angle = udg_zz_MovingSFXStartAngle[L] - udg_zz_MovingSFXCounter[L] * udg_zz_MovingSFXAbstand[L]
else
return
endif
if Angle > 360 then
set Angle = Angle - 360
elseif Angle < 0 then
set Angle = Angle + 360
endif
call DestroyEffectBJ(udg_zz_MovingSFX[L])
set udg_zz_MovingSFX[L] = AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(udg_zz_MovingSFXUnit[L]),udg_zz_MovingSFXRadius[L],Angle),udg_zz_MovingSFXPath[L])
set udg_zz_MovingSFXCounter[L] = udg_zz_MovingSFXCounter[L] + 1
call PolledWait(udg_zz_MovingSFXWait[L])
if udg_zz_MovingSFXCounter[L] == udg_zz_MovingSFXNr[L] then
if udg_zz_MovingSFXLoop[L] == true then
set udg_zz_MovingSFXCounter[L] = 0
else
call DestroyEffectBJ(udg_zz_MovingSFX[L])
set udg_zz_MovingSFX[L] = null
return
endif
endif
call VolumeGroupSetVolumeBJ(SOUND_VOLUMEGROUP_SPELLS,100.00)
call TriggerExecute(GetTriggeringTrigger())
endfunction
function AttachMovingSFXToUnit takes string Path, unit U, real Radius, integer Nr, real Wait, integer Direction returns nothing
local real Abstand = 0
local integer L = 0
set udg_zz_MovingSFXLength = udg_zz_MovingSFXLength + 1
set L = udg_zz_MovingSFXLength
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function MovingSFXUnit_Actions)
set udg_zz_MovingSFXWait[L] = Wait
set udg_zz_MovingSFXUnit[L] = U
set udg_zz_MovingSFXStartAngle[L] = 0
set udg_zz_MovingSFXType[L] = Direction
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXCounter[L] = 0
set udg_zz_MovingSFXNr[L] = Nr
set udg_zz_MovingSFXRadius[L] = Radius
set udg_zz_MovingSFXAbstand[L] = 360 / Nr
set udg_zz_MovingSFXLoop[L] = true
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function GetDimensionalIndex takes integer Size1D, integer Index1, integer Index2 returns integer
return Index2 * Size1D + Index1
endfunction
function JoinAnimationTags takes string A, string B returns string
return A + " " + B
endfunction
function DoSFXRain takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local location Center = udg_zz_MovingSFXCenter[L]
local string Path = udg_zz_MovingSFXPath[L]
local real Radius = udg_zz_MovingSFXWait[L]
local integer Nr = udg_zz_MovingSFXCounter[L]
local integer Index = 0
local effect array FX
loop
exitwhen Index == Nr
set FX[Index] = AddSpecialEffectLocBJ(PolarProjectionBJ(Center,GetRandomReal(0,Radius),GetRandomDirectionDeg()),Path)
call PolledWait(GetRandomReal(0.005,0.05))
set Index = Index + 1
endloop
loop
set Index = Index - 1
call DestroyEffectBJ(FX[Index])
set FX[Index] = null
exitwhen Index == 0
endloop
call RemoveLocation(Center)
set Center = null
call DestroyMovingSpecialEffect(L)
endfunction
function CreateSFXRain takes string Path, location Center, real Radius, integer Nr returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXCenter[L] = Center
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXWait[L] = Radius
set udg_zz_MovingSFXCounter[L] = Nr
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoSFXRain)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function KillTree takes nothing returns nothing
call KillDestructable(GetEnumDestructable())
endfunction
function IsHigherCliffLevel takes location thisLoc, location nextLoc returns boolean
return GetTerrainCliffLevel(GetLocationX(thisLoc), GetLocationY(thisLoc)) < GetTerrainCliffLevel(GetLocationX(nextLoc),GetLocationY(nextLoc))
endfunction
function SmackMove takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local location thisLoc = GetUnitLoc(udg_zz_MovingSFXUnit[L])
local location nextLoc = PolarProjectionBJ(thisLoc,udg_zz_MovingSFXWait[L],udg_zz_MovingSFXStartAngle[L])
if IsHigherCliffLevel(thisLoc,nextLoc) or udg_zz_MovingSFXWait[L] <= 0 then
set udg_zz_MovingSFXWait[L] = 0
call PauseUnitBJ(false,udg_zz_MovingSFXUnit[L])
call SetUnitPathing(udg_zz_MovingSFXUnit[L],true)
call RemoveLocation(thisLoc)
call RemoveLocation(nextLoc)
set thisLoc = null
set nextLoc = null
call DestroyMovingSpecialEffect(L)
return
else
if udg_zz_MovingSFXLoop[L] then
call EnumDestructablesInCircleBJ(128,nextLoc,function KillTree)
endif
call SetUnitPositionLoc(udg_zz_MovingSFXUnit[L],nextLoc)
set udg_zz_MovingSFXWait[L] = udg_zz_MovingSFXWait[L] - 0.5
endif
call PolledWait(0.05)
call TriggerExecute(GetTriggeringTrigger())
endfunction
function MakeUnitSlide takes unit Smacked, real Angle, real Rate, boolean KillDestructibles returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXStartAngle[L] = Angle
set udg_zz_MovingSFXWait[L] = Rate
set udg_zz_MovingSFXUnit[L] = Smacked
set udg_zz_MovingSFXLoop[L] = KillDestructibles
call PauseUnitBJ(true,Smacked)
call SetUnitPathing(Smacked,false)
call TriggerRegisterTimerEventPeriodic(udg_zz_MovingSFXTrigger[L],0.05)
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function SmackMove)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function Bridge_Conditions takes nothing returns boolean
if IsUnitType(GetTriggerUnit(),UNIT_TYPE_FLYING) then
return false
elseif IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE) then
return false
endif
return true
endfunction
function Bridge_MarkUnits takes nothing returns nothing
call StoreBoolean(WEUCache(),"BeenDeselected" + I2S(GetUniqueEinheitsnummer(GetEnumUnit())),"UnitAttached",true)
endfunction
function Bridge_Deselection takes nothing returns nothing
local integer PId = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
if GetStoredBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached") then
call ForGroup(Int2Group(GetStoredInteger(WEUCache(),"PathingUnits" + I2S(PId),"PlayerAttached")),function Bridge_MarkUnits)
endif
endfunction
function Bridge_Actions takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local integer Id = GetUniqueEinheitsnummer(GetTriggerUnit())
local integer PId = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
local group G
if GetStoredBoolean(WEUCache(),"IsPathing" + I2S(Id),"UnitAttached") then
return
endif
if DistanceBetweenPoints(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L])),GetUnitLoc(GetTriggerUnit())) < DistanceBetweenPoints(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L])),GetUnitLoc(GetTriggerUnit())) then
if GetTerrainCliffLevelBJ(GetUnitLoc(GetTriggerUnit())) > GetTerrainCliffLevelBJ(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L]))) then
return
endif
else
if GetTerrainCliffLevelBJ(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L]))) > GetTerrainCliffLevelBJ(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L]))) then
return
endif
endif
set G = GetUnitsSelectedAll(GetOwningPlayer(GetTriggerUnit()))
if not IsUnitInGroup(GetTriggerUnit(),G) then
call StoreBoolean(WEUCache(),"BeenDeselected" + I2S(Id),"UnitAttached",true)
call DisplayTimedTextToPlayer(Player(0),0,0,5,"not selected")
else
call StoreBoolean(WEUCache(),"BeenDeselected" + I2S(Id),"UnitAttached",false)
call StoreBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached",true)
endif
call GroupAddUnit(Int2Group(GetStoredInteger(WEUCache(),"PathingUnits" + I2S(PId),"PlayerAttached")),GetTriggerUnit())
call StoreBoolean(WEUCache(),"IsPathing" + I2S(Id),"UnitAttached",true)
call ShowUnitHide(GetTriggerUnit())
call PauseUnitBJ(true,GetTriggerUnit())
call TriggerSleepAction(DistanceBetweenPoints(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L])),GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L])))/500)
call PauseUnitBJ(false,GetTriggerUnit())
call SetUnitPathing(GetTriggerUnit(),false)
call TriggerSleepAction(0.5)
call ShowUnitShow(GetTriggerUnit())
if not GetStoredBoolean(WEUCache(),"BeenDeselected" + I2S(Id),"UnitAttached") then
if GetStoredBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached") then
call StoreBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached",false)
call SelectUnitAddForPlayer(GetTriggerUnit(),Player(PId))
call TriggerSleepAction(0)
call StoreBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached",true)
else
call SelectUnitAddForPlayer(GetTriggerUnit(),GetOwningPlayer(GetTriggerUnit()))
endif
endif
call GroupRemoveUnit(Int2Group(GetStoredInteger(WEUCache(),"PathingUnits" + I2S(PId),"PlayerAttached")),GetTriggerUnit())
if CountUnitsInGroup(Int2Group(GetStoredInteger(WEUCache(),"PathingUnits" + I2S(PId),"PlayerAttached"))) <= 0 then
call StoreBoolean(WEUCache(),"CurrentlyPathing" + I2S(PId),"PlayerAttached",false)
endif
call FlushStoredBoolean(WEUCache(),"BeenDeselected" + I2S(Id),"UnitAttached")
call TriggerSleepAction(0.2)
call SetUnitPathing(GetTriggerUnit(),true)
call FlushStoredBoolean(WEUCache(),"IsPathing" + I2S(Id),"UnitAttached")
call DestroyGroup(G)
set G = null
endfunction
function MakeBridgeWalkable takes rect Vor, rect Nach returns nothing
local integer L = GetFreeMovingSFXIndex()
local integer I = 0
local integer Ptr
loop
exitwhen I > 15
if not HaveStoredInteger(WEUCache(),"PathingUnits" + I2S(I),"PlayerAttached") then
call StoreInteger(WEUCache(),"PathingUnits" + I2S(I),"PlayerAttached",Handle2Int(CreateGroup()))
endif
if not HaveStoredInteger(WEUCache(),"PathingTrigger" + I2S(I),"PlayerAttached") then
set Ptr = Handle2Int(CreateTrigger())
call StoreInteger(WEUCache(),"PathingTrigger" + I2S(I),"PlayerAttached",Ptr)
call TriggerRegisterPlayerSelectionEventBJ(Int2Trigger(Ptr),Player(I),true)
call TriggerAddAction(Int2Trigger(Ptr),function Bridge_Deselection)
call StoreBoolean(WEUCache(),"CurrentlyPathing" + I2S(I),"PlayerAttached",false)
endif
set I = I + 1
endloop
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXVor[L] = Unit2Rect(CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'ncop',GetRectCenter(Vor), bj_UNIT_FACING))
set udg_zz_MovingSFXNach[L] = Unit2Rect(CreateUnitAtLoc(Player(PLAYER_NEUTRAL_PASSIVE),'ncop',GetRectCenter(Nach), bj_UNIT_FACING))
set udg_zz_MovingSFXCenter[L] = GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L]))
if GetTerrainCliffLevelBJ(GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L]))) > GetTerrainCliffLevelBJ(udg_zz_MovingSFXCenter[L]) then
set udg_zz_MovingSFXCenter[L] = GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L]))
endif
call UnitAddAbilityBJ('Ax2K',Rect2Unit(udg_zz_MovingSFXVor[L]))
call UnitAddAbilityBJ('Aivs',Rect2Unit(udg_zz_MovingSFXVor[L]))
call UnitAddAbilityBJ('Agho',Rect2Unit(udg_zz_MovingSFXVor[L]))
call SetUnitScalePercent(Rect2Unit(udg_zz_MovingSFXVor[L]),0.01,0.01,0.01)
call WaygateSetDestinationLocBJ(Rect2Unit(udg_zz_MovingSFXVor[L]),GetUnitLoc(Rect2Unit(udg_zz_MovingSFXNach[L])))
call WaygateActivate(Rect2Unit(udg_zz_MovingSFXVor[L]),true)
call UnitAddAbilityBJ('Ax2K',Rect2Unit(udg_zz_MovingSFXNach[L]))
call UnitAddAbilityBJ('Aivs',Rect2Unit(udg_zz_MovingSFXNach[L]))
call UnitAddAbilityBJ('Agho',Rect2Unit(udg_zz_MovingSFXNach[L]))
call SetUnitScalePercent(Rect2Unit(udg_zz_MovingSFXNach[L]),0.01,0.01,0.01)
call WaygateSetDestinationLocBJ(Rect2Unit(udg_zz_MovingSFXNach[L]),GetUnitLoc(Rect2Unit(udg_zz_MovingSFXVor[L])))
call WaygateActivate(Rect2Unit(udg_zz_MovingSFXNach[L]),true)
call TriggerRegisterUnitInRangeSimple(udg_zz_MovingSFXTrigger[L],120,Rect2Unit(udg_zz_MovingSFXVor[L]))
call TriggerRegisterUnitInRangeSimple(udg_zz_MovingSFXTrigger[L],120,Rect2Unit(udg_zz_MovingSFXNach[L]))
call TriggerAddCondition(udg_zz_MovingSFXTrigger[L],Condition(function Bridge_Conditions))
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function Bridge_Actions)
endfunction
function UnitTypeIsInUnitGroup takes group whichGroup, integer whichType returns boolean
local group source = CreateGroup()
local unit testunit
call GroupAddGroup(whichGroup,source)
loop
set testunit = GroupPickRandomUnit(source)
exitwhen testunit == null
if GetUnitTypeId(testunit) == whichType then
call DestroyGroup(source)
set source = null
return true
endif
call GroupRemoveUnit(source,testunit)
endloop
call DestroyGroup(source)
set source = null
return false
endfunction
function UnitTypeIsInRegion takes rect whichRegion, integer whichType returns boolean
local group source = GetUnitsInRectAll(whichRegion)
local group unitstested = CreateGroup()
local unit testunit
loop
set testunit = GroupPickRandomUnit(source)
exitwhen testunit == null
if GetUnitTypeId(testunit) == whichType then
call DestroyGroup(source)
set source = null
call DestroyGroup(unitstested)
set unitstested = null
return true
endif
call GroupRemoveUnit(source,testunit)
endloop
call DestroyGroup(source)
set source = null
call DestroyGroup(unitstested)
set unitstested = null
return false
endfunction
function CharIsNumber takes string whichChar returns boolean
local integer i = 0
local string nums = "0123456789"
local boolean result = false
loop
exitwhen i > 9
if SubStringBJ(nums,i,i) == whichChar then
set result = true
set i = 9
endif
set i = i + 1
endloop
return result
endfunction
function PlayerGroupIsEmpty takes force whichForce returns boolean
return CountPlayersInForceBJ(whichForce) == 0
endfunction
function IsPrime takes integer i returns boolean
local integer c = 2
if ModuloInteger(i,2) == 0 and i != 2 then
set i = 0
else
loop
exitwhen c > R2I(SquareRoot(I2R(i)))
if ModuloInteger(i,c) == 0 then
set c = i
set i = 0
endif
set c = c + 1
endloop
endif
if i != 0 then
return true
endif
return false
endfunction
function AnzahlVorkommenImString takes string B, string Teil returns integer
local integer Stelle = 1
local integer Vorkommen = 0
set Teil = Uppercase(SubStringBJ(Teil,1,1))
loop
exitwhen SubStringBJ(B,Stelle,Stelle) == ""
if SubStringBJ(B,Stelle,Stelle) == Teil then
set Vorkommen = Vorkommen + 1
endif
set Stelle = Stelle + 1
endloop
set Stelle = 1
set Teil = Lowercase(Teil)
loop
exitwhen SubStringBJ(B,Stelle,Stelle) == ""
if SubStringBJ(B,Stelle,Stelle) == Teil then
set Vorkommen = Vorkommen + 1
endif
set Stelle = Stelle + 1
endloop
return Vorkommen
endfunction
function Unit2UnitGroup takes unit whichUnit returns group
local group whichGroup = CreateGroup()
call GroupAddUnitSimple(whichUnit,whichGroup)
return whichGroup
endfunction
function GetRandomLocInRectOfCliffHeightChild takes integer cliffheight, rect whichRegion, integer versuche returns location
local location temp_point = GetRandomLocInRect(whichRegion)
local integer max = 100
if GetTerrainCliffLevelBJ(temp_point) == cliffheight then
return temp_point
endif
call RemoveLocation(temp_point)
set temp_point = null
if versuche > max then
return null
endif
return GetRandomLocInRectOfCliffHeightChild(cliffheight,whichRegion,versuche + 1)
endfunction
function GetRandomLocInRectOfCliffHeight takes integer cliffheight, rect whichRegion returns location
return GetRandomLocInRectOfCliffHeightChild(cliffheight,whichRegion,0)
endfunction
function RandomPointInRange takes location whichPoint, real pointrange returns location
return PolarProjectionBJ(whichPoint,GetRandomReal(1.00,pointrange),GetRandomReal(0,360.00))
endfunction
function AddSpecialEffectLocWithTimer_Child takes nothing returns nothing
local effect tempeffect = bj_lastCreatedEffect
local real duration = bj_enumDestructableRadius
call PolledWait(duration)
call DestroyEffect(tempeffect)
set tempeffect = null
endfunction
function AddSpecialEffectLocWithTimer takes location whichLocation, string whichEffect, real duration returns nothing
local trigger dispatcher = CreateTrigger()
set bj_enumDestructableRadius = duration
call AddSpecialEffectLocBJ(whichLocation,whichEffect)
call TriggerAddAction(dispatcher,function AddSpecialEffectLocWithTimer_Child)
call TriggerExecute(dispatcher)
call DestroyTrigger(dispatcher)
set dispatcher = null
endfunction
function AddSpecialEffectTargetUnitWithTimer_Child takes nothing returns nothing
local effect tempeffect = bj_lastCreatedEffect
local real duration = bj_enumDestructableRadius
call PolledWait(duration)
call DestroyEffect(tempeffect)
set tempeffect = null
endfunction
function AddSpecialEffectTargetUnitWithTimer takes string whichAttach, unit whichUnit, string whichEffect, real duration returns nothing
local trigger dispatcher = CreateTrigger()
set bj_enumDestructableRadius = duration
call AddSpecialEffectTargetUnitBJ(whichAttach,whichUnit,whichEffect)
call TriggerAddAction(dispatcher,function AddSpecialEffectTargetUnitWithTimer_Child)
call TriggerExecute(dispatcher)
call DestroyTrigger(dispatcher)
set dispatcher = null
endfunction
function TargetHeal takes unit whichUnit, real healAmount returns nothing
call SetUnitLifeBJ(whichUnit,(GetUnitStateSwap(UNIT_STATE_LIFE,whichUnit) + healAmount))
call AddSpecialEffectTargetUnitWithTimer("origin",whichUnit,"Abilities\\Spells\\Human\\Heal\\HealTarget.mdl",1.8)
endfunction
function HealAliveCheck takes nothing returns boolean
return IsUnitAliveBJ(GetFilterUnit())
endfunction
function AOEHealSimple takes unit whichUnit, real healAmount, real radius, boolean friendlyfire returns nothing
local group tempgroup = CreateGroup()
local unit comp
local filterfunc F = Filter(function HealAliveCheck)
set tempgroup = GetUnitsInRangeOfLocMatching(radius,GetUnitLoc(whichUnit),F)
call DestroyFilter(F)
set F = null
loop
set comp = FirstOfGroup(tempgroup)
exitwhen comp == null
if IsPlayerAlly(GetOwningPlayer(comp),GetOwningPlayer(whichUnit)) or friendlyfire then
call TargetHeal(comp,healAmount)
endif
call GroupRemoveUnit(tempgroup,comp)
endloop
call DestroyGroup(tempgroup)
set tempgroup = null
endfunction
function UnitDropAllItemsOfType takes boolean CompletelyRemove, integer itemId, unit whichUnit returns integer
local integer removed = 0
local integer itemSlot
loop
set itemSlot = GetInventoryIndexOfItemTypeBJ(whichUnit,itemId)
exitwhen itemSlot == -1
if CompletelyRemove then
call RemoveItem(UnitRemoveItemFromSlot(whichUnit,itemSlot))
else
call UnitRemoveItemFromSlot(whichUnit,itemSlot)
endif
set removed = removed + 1
endloop
return removed
endfunction
function GetUnitsXItemOfType takes integer Nr, integer Type, unit U returns item
local integer Index = 1
local integer Anzahl = 0
loop
if GetItemTypeId(UnitItemInSlotBJ(U,Index)) == Type then
set Anzahl = Anzahl + 1
if Anzahl == Nr then
return UnitItemInSlotBJ(U,Index)
endif
endif
exitwhen Index == 6
set Index = Index + 1
endloop
return null
endfunction
function ReplaceUnitAdvanced takes unit whichUnit, integer newUnitId, integer unitStateMethod returns unit
local integer temp_customdata = GetUnitUserData(whichUnit)
local boolean wasHero = IsUnitType(whichUnit,UNIT_TYPE_HERO)
local real temp_fheight = GetUnitFlyHeight(whichUnit)
local real temp_pangle = GetUnitPropWindow(whichUnit)
local integer temp_strength
local integer temp_agility
local integer temp_intelligence
local unit temp_replacedunit
if wasHero then
set temp_strength = GetHeroStr(whichUnit, true)
set temp_agility = GetHeroAgi(whichUnit, true)
set temp_intelligence = GetHeroInt(whichUnit, true)
endif
set temp_replacedunit = ReplaceUnitBJ(whichUnit, newUnitId, unitStateMethod)
if wasHero and IsUnitType(temp_replacedunit, UNIT_TYPE_HERO) then
call SetHeroStr(temp_replacedunit, temp_strength, true)
call SetHeroAgi(temp_replacedunit, temp_agility, true)
call SetHeroInt(temp_replacedunit, temp_intelligence, true)
endif
call SetUnitUserData(temp_replacedunit, temp_customdata)
call SetUnitFlyHeight(temp_replacedunit, temp_fheight, temp_fheight)
call SetUnitPropWindow(temp_replacedunit, temp_pangle)
set bj_lastReplacedUnit = temp_replacedunit
return temp_replacedunit
endfunction
function DoAttachedSFXRain takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local unit U = udg_zz_MovingSFXUnit[L]
local string Path = udg_zz_MovingSFXPath[L]
local real Radius = udg_zz_MovingSFXWait[L]
local integer Nr = udg_zz_MovingSFXCounter[L]
local integer Index = 0
local effect array FX
loop
exitwhen Index == Nr
set FX[Index] = AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),GetRandomReal(0,Radius),GetRandomDirectionDeg()),Path)
call PolledWait(GetRandomReal(0.005,0.05))
set Index = Index + 1
endloop
loop
set Index = Index - 1
call DestroyEffectBJ(FX[Index])
set FX[Index] = null
exitwhen Index == 0
endloop
call DestroyMovingSpecialEffect(L)
endfunction
function AttachSFXRainToUnit takes string Path, unit U, real Radius, integer Nr returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXUnit[L] = U
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXWait[L] = Radius
set udg_zz_MovingSFXCounter[L] = Nr
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoAttachedSFXRain)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function Gewitter_Actions takes nothing returns nothing
call CreateSFXRain("Doodads\\Cinematic\\Lightningbolt\\Lightningbolt.mdl",udg_zz_GewitterCenter,1000,udg_zz_GewitterBlitze)
endfunction
function DoGewitter takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local integer AnzahlBlitze = udg_zz_MovingSFXCounter[L]
local location Center = udg_zz_MovingSFXCenter[L]
local sound Thunder = CreateSound("Doodads\\Cinematic\\Lightningbolt\\LightningBolt1.wav",false,false,true,10,10,"SpellsEAX")
local trigger Gew = CreateTrigger()
local integer Index = 1
local integer IndexEnd = AnzahlBlitze - R2I(AnzahlBlitze / 2.5)
local weathereffect WFX
call CinematicFadeBJ(bj_CINEFADETYPE_FADEIN,1,"ReplaceableTextures\\CameraMasks\\White_mask.blp",100.00,100.00,100.00,30.00)
call DisplayCineFilterBJ(false)
call TriggerAddAction(Gew,function Gewitter_Actions)
call SetSoundDuration(Thunder,3001)
set udg_zz_GewitterBlitze = AnzahlBlitze
set udg_zz_GewitterCenter = Center
call TriggerExecute(Gew)
call AddWeatherEffectSaveLast(RectFromCenterSizeBJ(Center,2000,2000),'RAhr')
set WFX = GetLastCreatedWeatherEffect()
call EnableWeatherEffect(WFX,true)
loop
exitwhen Index == IndexEnd
call PolledWait(GetRandomReal(0.015,0.3))
if ModuloInteger(Index,3) == 0 then
call DisplayCineFilterBJ(true)
call PolledWait(0.05)
call DisplayCineFilterBJ(false)
elseif ModuloInteger(Index,2) == 1 then
call PlaySoundBJ(Thunder)
endif
set Index = Index + 1
endloop
call PolledWait(1.2)
call EnableWeatherEffect(WFX,false)
call RemoveWeatherEffectBJ(WFX)
set WFX = null
call DestroyTrigger(Gew)
set Gew = null
call RemoveLocation(Center)
set Center = null
call DestroyMovingSpecialEffect(L)
endfunction
function Gewitter takes integer AnzahlBlitze, location Center returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXCounter[L] = AnzahlBlitze
set udg_zz_MovingSFXCenter[L] = Center
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoGewitter)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function DoUnitBurn takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local unit U = udg_zz_MovingSFXUnit[L]
local string Path = udg_zz_MovingSFXPath[L]
local real Time = udg_zz_MovingSFXWait[L]
local integer Index = 1
local effect array FX
call AddSpecialEffectTargetUnitBJ("head",U,Path)
set FX[1] = GetLastCreatedEffectBJ()
call AddSpecialEffectTargetUnitBJ("chest",U,Path)
set FX[2] = GetLastCreatedEffectBJ()
call AddSpecialEffectTargetUnitBJ("hand left",U,Path)
set FX[3] = GetLastCreatedEffectBJ()
call AddSpecialEffectTargetUnitBJ("hand right",U,Path)
set FX[4] = GetLastCreatedEffectBJ()
call AddSpecialEffectTargetUnitBJ("foot left",U,Path)
set FX[5] = GetLastCreatedEffectBJ()
call AddSpecialEffectTargetUnitBJ("foot right",U,Path)
set FX[6] = GetLastCreatedEffectBJ()
if IsUnitType(U,UNIT_TYPE_HERO) == true then
call AddSpecialEffectTargetUnitBJ("head",U,Path)
set FX[0] = GetLastCreatedEffectBJ()
set Index = 0
endif
call PolledWait(Time)
loop
call DestroyEffectBJ(FX[Index])
set FX[Index] = null
exitwhen Index == 6
set Index = Index + 1
endloop
call DestroyMovingSpecialEffect(L)
endfunction
function MakeUnitBurnStyle takes string Path, unit U, real Time returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXUnit[L] = U
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXWait[L] = Time
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoUnitBurn)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function MakeUnitBurn takes unit U, string Style, real Time returns nothing
if Style == "Undead" then
call MakeUnitBurnStyle("Environment\\UndeadBuildingFire\\UndeadLargeBuildingFire0.mdl",U,Time)
elseif Style == "Extreme" then
call MakeUnitBurnStyle("Doodads\\Cinematic\\TownBurningFireEmitter\\TownBurningFireEmitter.mdl",U,Time)
elseif Style == "Clean" then
call MakeUnitBurnStyle("Doodads\\Cinematic\\FireRockSmall\\FireRockSmall.mdl",U,Time)
elseif Style == "Smoke" then
call MakeUnitBurnStyle("Environment\\LargeBuildingFire\\LargeBuildingFire1.mdl",U,Time)
elseif Style == "Elf" then
call MakeUnitBurnStyle("Environment\\NightElfBuildingFire\\ElfLargeBuildingFire1.mdl",U,Time)
else
call MakeUnitBurnStyle(Style,U,Time)
endif
endfunction
function DoTransparenzverlauf takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local string Row = udg_zz_MovingSFXPath[L]
local integer R = S2I(SubStringBJ(Row,1,3))
local integer G = S2I(SubStringBJ(Row,4,6))
local integer B = S2I(SubStringBJ(Row,7,9))
local integer T = S2I(SubStringBJ(Row,10,12))
local integer TR = S2I(SubStringBJ(Row,13,15))
local integer TG = S2I(SubStringBJ(Row,16,18))
local integer TB = S2I(SubStringBJ(Row,19,21))
local integer TT = S2I(SubStringBJ(Row,22,24))
local unit U = udg_zz_MovingSFXUnit[L]
local real Zeitabstand = udg_zz_MovingSFXWait[L]
local real array Differenz
local real array Abstand
local real array Interval
local real Max = 0
local integer Index = 0
set Differenz[0] = I2R(TR - R)
set Differenz[1] = I2R(TG - G)
set Differenz[2] = I2R(TB - B)
set Differenz[3] = I2R(TT - T)
loop
if Differenz[Index] < 0 then
set Abstand[Index] = Differenz[Index] - 2*Differenz[Index]
endif
exitwhen Index == 3
set Index = Index + 1
endloop
set Index = 0
loop
if Abstand[Index] > Max then
set Max = Abstand[Index]
endif
exitwhen Index == 3
set Index = Index + 1
endloop
set Interval[0] = Differenz[0]/Max
set Interval[1] = Differenz[1]/Max
set Interval[2] = Differenz[2]/Max
set Interval[3] = Differenz[3]/Max
set Index = 0
loop
call SetUnitVertexColorBJ(U,R + Interval[0]*Index,G + Interval[1]*Index,B + Interval[2]*Index,T + Interval[3]*Index)
exitwhen Index >= Max
call PolledWait(Zeitabstand)
set Index = Index + 1
endloop
call SetUnitVertexColorBJ(U,TR,TG,TB,TT)
call DestroyMovingSpecialEffect(L)
endfunction
function Transparenzverlauf takes integer R, integer G, integer B, integer T, integer TR, integer TG, integer TB, integer TT, unit U, real Zeitabstand returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXWait[L] = Zeitabstand
set udg_zz_MovingSFXPath[L] = DreistelligerInteger(R) + DreistelligerInteger(G) + DreistelligerInteger(B) + DreistelligerInteger(T) + DreistelligerInteger(TR) + DreistelligerInteger(TG) + DreistelligerInteger(TB) + DreistelligerInteger(TT)
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoTransparenzverlauf)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function DoErdbeben takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local location Center = udg_zz_MovingSFXCenter[L]
local real Time = udg_zz_MovingSFXWait[L]
local integer Index = 0
local integer IndexEnd = 0
local effect array FX
local effect MainEffect
if ModuloReal(Time,2) >= 1 then
set Time = Time + 2 - ModuloReal(Time,2)
else
set Time = Time - ModuloReal(Time,2)
endif
set IndexEnd = R2I(Time) * 2
loop
call CameraSetSourceNoiseForPlayer(Player(Index),100.00,20.00)
call CameraSetTargetNoiseForPlayer(Player(Index),100.00,20.00)
exitwhen Index == 11
set Index = Index + 1
endloop
set Index = 0
set MainEffect = AddSpecialEffectLocBJ(Center,"Abilities\\Spells\\Orc\\EarthQuake\\EarthQuakeTarget.mdl")
loop
exitwhen Index == IndexEnd
call PolledWait(0.5)
if GetRandomInt(0,10) > 2 then
set FX[Index] = AddSpecialEffectLocBJ(PolarProjectionBJ(Center,GetRandomReal(0,1000),GetRandomDirectionDeg()),"Abilities\\Spells\\Orc\\EarthQuake\\EarthQuakeTarget.mdl")
endif
set Index = Index + 1
endloop
set IndexEnd = 0
loop
call CameraClearNoiseForPlayer(Player(IndexEnd))
exitwhen IndexEnd == 11
set IndexEnd = IndexEnd + 1
endloop
loop
set Index = Index - 1
call PolledWait(GetRandomReal(0.05,0.2))
call DestroyEffectBJ(FX[Index])
set FX[Index] = null
exitwhen Index == 0
endloop
call PolledWait(0.5)
call DestroyEffectBJ(MainEffect)
set MainEffect = null
call RemoveLocation(Center)
set Center = null
call DestroyMovingSpecialEffect(L)
endfunction
function SetCinematicSkipClearTextState takes boolean B returns nothing
if not B then
call TriggerClearActions(bj_cineSceneBeingSkipped)
call TriggerAddAction(bj_cineSceneBeingSkipped,function DoNothing)
else
call TriggerClearActions(bj_cineSceneBeingSkipped)
call TriggerAddAction(bj_cineSceneBeingSkipped,function CancelCineSceneBJ)
endif
endfunction
function MakeUnitUnselectable takes unit U returns nothing
call UnitAddAbilityBJ('Aloc',U)
endfunction
function Erdbeben takes location Center, real Time returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXCenter[L] = Center
set udg_zz_MovingSFXWait[L] = Time
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoErdbeben)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function MatrixOn takes nothing returns nothing
call SetUnitTimeScalePercent(GetEnumUnit(),50)
call SetUnitTurnSpeedBJ(GetEnumUnit(),0.3)
endfunction
function MatrixOff takes nothing returns nothing
call SetUnitTimeScalePercent(GetEnumUnit(),100)
call SetUnitTurnSpeedBJ(GetEnumUnit(),0.5)
endfunction
function MatrixStyle takes boolean On returns nothing
local group All = CreateGroup()
call GroupEnumUnitsInRect(All,GetEntireMapRect(),null)
if On == true then
set bj_cineModePriorSpeed = GetGameSpeed()
call ForGroup(All,function MatrixOn)
call SetGameSpeed(MAP_SPEED_SLOWEST)
else
call ForGroup(All,function MatrixOff)
call SetGameSpeed(bj_cineModePriorSpeed)
endif
call DestroyGroup(All)
set All = null
endfunction
function DoTheCircle takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local location Center = udg_zz_MovingSFXCenter[L]
local real Rad = udg_zz_MovingSFXRadius[L]
local integer Anz = udg_zz_MovingSFXCounter[L]
local string Path = udg_zz_MovingSFXPath[L]
local real Time = udg_zz_MovingSFXWait[L]
local integer Index = 0
local real Steps = 360/Anz
local effect array FX
loop
call AddSpecialEffectLocBJ(PolarProjectionBJ(Center,Rad,Index*Steps),Path)
set FX[Index] = GetLastCreatedEffectBJ()
exitwhen Index == Anz
set Index = Index + 1
endloop
call PolledWait(Time)
loop
call DestroyEffectBJ(FX[Index])
set FX[Index] = null
exitwhen Index == 0
set Index = Index - 1
endloop
call RemoveLocation(Center)
set Center = null
call DestroyMovingSpecialEffect(L)
endfunction
function CreateSpecialEffectCircle takes location Center, real Rad, integer Anz, string Path, real Time returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXCenter[L] = Center
set udg_zz_MovingSFXRadius[L] = Rad
set udg_zz_MovingSFXCounter[L] = Anz
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXWait[L] = Time
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoTheCircle)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function DoSFXWave takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local real Distance = udg_zz_MovingSFXAbstand[L]
local string Path = udg_zz_MovingSFXPath[L]
local real angle = udg_zz_MovingSFXWait[L]
local location Start = udg_zz_MovingSFXCenter[L]
local integer i = 1
local integer iend = 0
local effect array effects
if Distance > 1600 then
set Distance = 1600
elseif Distance < 80 then
set Distance = 80
endif
if ModuloReal(Distance,40) >= 20 then
set Distance = Distance + 40 - ModuloReal(Distance,40)
else
set Distance = Distance - ModuloReal(Distance,40)
endif
set iend = R2I(Distance / 40)
set i = 1
loop
exitwhen i > iend
if (i < iend - 5) and (i > 1) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i) * 40.00),angle-20.0),Path)
set effects[(i-1)*17+1] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ( PolarProjectionBJ(Start,((i) * 40.00),angle+20.0),Path)
set effects[(i-1)*17+2] = GetLastCreatedEffectBJ()
endif
if (i < iend - 4) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-17.5),Path)
set effects[(i-1)*17+10] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+17.5),Path)
set effects[(i-1)*17+11] = GetLastCreatedEffectBJ()
endif
if (i < iend - 3) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-15.0),Path)
set effects[(i-1)*17+3] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+15.0),Path)
set effects[(i-1)*17+4] = GetLastCreatedEffectBJ()
endif
if (i < iend - 2) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-12.5),Path)
set effects[(i-1)*17+12] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+12.5),Path)
set effects[(i-1)*17+13] = GetLastCreatedEffectBJ()
endif
if (i < iend - 1) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-10.0),Path)
set effects[(i-1)*17+5] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+10.0),Path)
set effects[(i-1)*17+6] = GetLastCreatedEffectBJ()
endif
if (i < iend - 1) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-7.5),Path)
set effects[(i-1)*17+14] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+7.5),Path)
set effects[(i-1)*17+15] = GetLastCreatedEffectBJ()
endif
if (i < iend) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-5.0),Path)
set effects[(i-1)*17+7] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+5.0),Path)
set effects[(i-1)*17+8] = GetLastCreatedEffectBJ()
endif
if (i < iend) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle-2.5),Path)
set effects[(i-1)*17+16] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle+2.5),Path)
set effects[(i-1)*17+17] = GetLastCreatedEffectBJ()
endif
call AddSpecialEffectLocBJ(PolarProjectionBJ(Start,((i+1) * 40.00),angle),Path)
set effects[(i-1)*17+9] = GetLastCreatedEffectBJ()
if (ModuloInteger(i,4) == 0) then
call PolledWait(0.01)
endif
set i = i + 1
endloop
call PolledWait(0.5)
set i = 1
loop
exitwhen i > iend
if (i < iend - 5) then
call DestroyEffectBJ(effects[(i-1)*17+1])
call DestroyEffectBJ(effects[(i-1)*17+2])
set effects[(i-1)*17+1] = null
set effects[(i-1)*17+2] = null
endif
if (i < iend - 4) then
call DestroyEffectBJ(effects[(i-1)*17+10])
call DestroyEffectBJ(effects[(i-1)*17+11])
set effects[(i-1)*17+10] = null
set effects[(i-1)*17+11] = null
endif
if (i < iend - 3) then
call DestroyEffectBJ(effects[(i-1)*17+3])
call DestroyEffectBJ(effects[(i-1)*17+4])
set effects[(i-1)*17+3] = null
set effects[(i-1)*17+4] = null
endif
if (i < iend - 2) then
call DestroyEffectBJ(effects[(i-1)*17+12])
call DestroyEffectBJ(effects[(i-1)*17+13])
set effects[(i-1)*17+12] = null
set effects[(i-1)*17+13] = null
endif
if (i < iend - 1) then
call DestroyEffectBJ(effects[(i-1)*17+5])
call DestroyEffectBJ(effects[(i-1)*17+6])
set effects[(i-1)*17+5] = null
set effects[(i-1)*17+6] = null
endif
if (i < iend - 1) then
call DestroyEffectBJ(effects[(i-1)*17+14])
call DestroyEffectBJ(effects[(i-1)*17+15])
set effects[(i-1)*17+14] = null
set effects[(i-1)*17+15] = null
endif
if (i < iend) then
call DestroyEffectBJ(effects[(i-1)*17+7])
call DestroyEffectBJ(effects[(i-1)*17+8])
set effects[(i-1)*17+7] = null
set effects[(i-1)*17+8] = null
endif
if (i < iend) then
call DestroyEffectBJ(effects[(i-1)*17+16])
call DestroyEffectBJ(effects[(i-1)*17+17])
set effects[(i-1)*17+16] = null
set effects[(i-1)*17+17] = null
endif
call DestroyEffectBJ(effects[(i-1)*17+9])
set effects[(i-1)*17+9] = null
if (ModuloInteger(i,4) == 0) then
call PolledWait(0.01)
endif
set i = i + 1
endloop
call RemoveLocation(Start)
set Start = null
call DestroyMovingSpecialEffect(L)
endfunction
function SFXWave takes string Path, location Start, real angle, real Distance returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXCenter[L] = Start
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXWait[L] = angle
set udg_zz_MovingSFXAbstand[L] = Distance
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoSFXWave)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function DoAttachedSFXWave takes nothing returns nothing
local integer L = GetTriggeringSFXTriggerIndex(GetTriggeringTrigger())
local real Distance = udg_zz_MovingSFXAbstand[L]
local string Path = udg_zz_MovingSFXPath[L]
local unit U = udg_zz_MovingSFXUnit[L]
local integer i = 1
local integer iend = 0
local effect array effects
local real angle = GetUnitFacing(U)
if Distance > 1600 then
set Distance = 1600
elseif Distance < 80 then
set Distance = 80
endif
if ModuloReal(Distance,40) >= 20 then
set Distance = Distance + 40 - ModuloReal(Distance,40)
else
set Distance = Distance - ModuloReal(Distance,40)
endif
set iend = R2I(Distance / 40)
set i = 1
loop
exitwhen i > iend
if (i < iend - 5) and (i > 1) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i) * 40.00),angle-20.0),Path)
set effects[(i-1)*17+1] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i) * 40.00),angle+20.0),Path)
set effects[(i-1)*17+2] = GetLastCreatedEffectBJ()
endif
if (i < iend - 4) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-17.5),Path)
set effects[(i-1)*17+10] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+17.5),Path)
set effects[(i-1)*17+11] = GetLastCreatedEffectBJ()
endif
if (i < iend - 3) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-15.0),Path)
set effects[(i-1)*17+3] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+15.0),Path)
set effects[(i-1)*17+4] = GetLastCreatedEffectBJ()
endif
if (i < iend - 2) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-12.5),Path)
set effects[(i-1)*17+12] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+12.5),Path)
set effects[(i-1)*17+13] = GetLastCreatedEffectBJ()
endif
if (i < iend - 1) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-10.0),Path)
set effects[(i-1)*17+5] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+10.0),Path)
set effects[(i-1)*17+6] = GetLastCreatedEffectBJ()
endif
if (i < iend - 1) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-7.5),Path)
set effects[(i-1)*17+14] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+7.5),Path)
set effects[(i-1)*17+15] = GetLastCreatedEffectBJ()
endif
if (i < iend) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-5.0),Path)
set effects[(i-1)*17+7] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+5.0),Path)
set effects[(i-1)*17+8] = GetLastCreatedEffectBJ()
endif
if (i < iend) and (i > 14) then
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle-2.5),Path)
set effects[(i-1)*17+16] = GetLastCreatedEffectBJ()
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle+2.5),Path)
set effects[(i-1)*17+17] = GetLastCreatedEffectBJ()
endif
call AddSpecialEffectLocBJ(PolarProjectionBJ(GetUnitLoc(U),((i+1) * 40.00),angle),Path)
set effects[(i-1)*17+9] = GetLastCreatedEffectBJ()
if (ModuloInteger(i,4) == 0) then
call PolledWait(0.01)
endif
set i = i + 1
endloop
call PolledWait(0.5)
set i = 1
loop
exitwhen i > iend
if (i < iend - 5) then
call DestroyEffectBJ(effects[(i-1)*17+1])
call DestroyEffectBJ(effects[(i-1)*17+2])
set effects[(i-1)*17+1] = null
set effects[(i-1)*17+2] = null
endif
if (i < iend - 4) then
call DestroyEffectBJ(effects[(i-1)*17+10])
call DestroyEffectBJ(effects[(i-1)*17+11])
set effects[(i-1)*17+10] = null
set effects[(i-1)*17+11] = null
endif
if (i < iend - 3) then
call DestroyEffectBJ(effects[(i-1)*17+3])
call DestroyEffectBJ(effects[(i-1)*17+4])
set effects[(i-1)*17+3] = null
set effects[(i-1)*17+4] = null
endif
if (i < iend - 2) then
call DestroyEffectBJ(effects[(i-1)*17+12])
call DestroyEffectBJ(effects[(i-1)*17+13])
set effects[(i-1)*17+12] = null
set effects[(i-1)*17+13] = null
endif
if (i < iend - 1) then
call DestroyEffectBJ(effects[(i-1)*17+5])
call DestroyEffectBJ(effects[(i-1)*17+6])
set effects[(i-1)*17+5] = null
set effects[(i-1)*17+6] = null
endif
if (i < iend - 1) then
call DestroyEffectBJ(effects[(i-1)*17+14])
call DestroyEffectBJ(effects[(i-1)*17+15])
set effects[(i-1)*17+14] = null
set effects[(i-1)*17+15] = null
endif
if (i < iend) then
call DestroyEffectBJ(effects[(i-1)*17+7])
call DestroyEffectBJ(effects[(i-1)*17+8])
set effects[(i-1)*17+7] = null
set effects[(i-1)*17+8] = null
endif
if (i < iend) then
call DestroyEffectBJ(effects[(i-1)*17+16])
call DestroyEffectBJ(effects[(i-1)*17+17])
set effects[(i-1)*17+16] = null
set effects[(i-1)*17+17] = null
endif
call DestroyEffectBJ(effects[(i-1)*17+9])
set effects[(i-1)*17+9] = null
if (ModuloInteger(i,4) == 0) then
call PolledWait(0.01)
endif
set i = i + 1
endloop
call DestroyMovingSpecialEffect(L)
endfunction
function AttachSFXWaveToUnit takes string Path, unit U, real Distance returns nothing
local integer L = GetFreeMovingSFXIndex()
set udg_zz_MovingSFXKilled[L] = false
set udg_zz_MovingSFXTrigger[L] = CreateTrigger()
set udg_zz_MovingSFXUnit[L] = U
set udg_zz_MovingSFXPath[L] = Path
set udg_zz_MovingSFXAbstand[L] = Distance
call TriggerAddAction(udg_zz_MovingSFXTrigger[L],function DoAttachedSFXWave)
call TriggerExecute(udg_zz_MovingSFXTrigger[L])
endfunction
function FindNextUnit takes location L returns unit
local group G = CreateGroup()
local real Dist = 1000000
local unit Closest
local unit U
call GroupEnumUnitsInRect(G,GetEntireMapRect(),null)
loop
set U = FirstOfGroup(G)
exitwhen U == null
if DistanceBetweenPoints(GetUnitLoc(U),L) < Dist then
set Closest = U
set Dist = DistanceBetweenPoints(GetUnitLoc(U),L)
endif
call GroupRemoveUnit(G,U)
endloop
call DestroyGroup(G)
set G = null
return Closest
endfunction
function FindNextUnitMatching takes location L, boolexpr Cond returns unit
local group G = CreateGroup()
local real Dist = 1000000
local unit Closest
local unit U
call GroupEnumUnitsInRect(G,GetEntireMapRect(),Cond)
loop
set U = FirstOfGroup(G)
exitwhen U == null
if DistanceBetweenPoints(GetUnitLoc(U),L) < Dist then
set Closest = U
set Dist = DistanceBetweenPoints(GetUnitLoc(U),L)
endif
call GroupRemoveUnit(G,U)
endloop
call DestroyGroup(G)
set G = null
return Closest
endfunction
function GetNextDestBJ takes nothing returns nothing
if DistanceBetweenPoints(GetDestructableLoc(GetEnumDestructable()),udg_zz_CheckLocation) < udg_zz_ClosestDistance then
set udg_zz_ClosestDestructable = GetEnumDestructable()
set udg_zz_ClosestDistance = DistanceBetweenPoints(GetDestructableLoc(GetEnumDestructable()),udg_zz_CheckLocation)
endif
endfunction
function FindNextDoodad takes location L returns destructable
set udg_zz_ClosestDistance = 1000000
set udg_zz_CheckLocation = L
call EnumDestructablesInRectAll(GetEntireMapRect(),function GetNextDestBJ)
return udg_zz_ClosestDestructable
endfunction
function GetNextItemBJ takes nothing returns nothing
if DistanceBetweenPoints(GetItemLoc(GetEnumItem()),udg_zz_CheckLocation) < udg_zz_ClosestDistance then
set udg_zz_ClosestItem = GetEnumItem()
set udg_zz_ClosestDistance = DistanceBetweenPoints(GetItemLoc(GetEnumItem()),udg_zz_CheckLocation)
endif
endfunction
function FindNextItem takes location L returns item
set udg_zz_ClosestDistance = 1000000
set udg_zz_CheckLocation = L
call EnumItemsInRect(GetEntireMapRect(),null,function GetNextItemBJ)
return udg_zz_ClosestItem
endfunction
function GetUnitsSkillLevel takes unit U, integer Sk returns integer
return 0
endfunction
function GetXOrder takes unit U returns string
return ""
endfunction
function GetXTargetLoc takes unit U returns location
return null
endfunction
function GetXTargetItem takes unit U returns item
return null
endfunction
function GetXTargetDest takes unit U returns destructable
return null
endfunction
function GetXTargetUnit takes unit U returns unit
return null
endfunction
function GetXLearnedSkill takes unit U returns integer
return udg_zz_XLearnedSkill[GetUniqueEinheitsnummer(U)]
endfunction
function GetXResearchedUpgrade takes unit U returns integer
return udg_zz_XResearchedUpgrade[GetUniqueEinheitsnummer(U)]
endfunction
function GetXSummonedItem takes unit U returns unit
return udg_zz_XSummonedUnit[GetUniqueEinheitsnummer(U)]
endfunction
function GetXAttackedUnit takes unit U returns unit
return null
endfunction
function GetXAcquiredItem takes unit U returns item
return udg_zz_XAcquiredItem[GetUniqueEinheitsnummer(U)]
endfunction
function GetXDroppedItem takes unit U returns item
return udg_zz_XDroppedItem[GetUniqueEinheitsnummer(U)]
endfunction
function GetXSoldUnit takes unit U returns unit
return udg_zz_XSoldUnit[GetUniqueEinheitsnummer(U)]
endfunction
function GetXSoldItem takes unit U returns item
return udg_zz_XSoldItem[GetUniqueEinheitsnummer(U)]
endfunction
function GetXTrainedUnit takes unit U returns unit
return udg_zz_XTrainedUnit[GetUniqueEinheitsnummer(U)]
endfunction
function GetXBuiltConstruction takes unit U returns unit
return udg_zz_XBuiltConstruction[GetUniqueEinheitsnummer(U)]
endfunction
function ReplaceResizeDoodad takes destructable D, real Height, real Facing, real Scale, integer Variation returns nothing
local integer Type = GetDestructableTypeId(D)
local real X = GetDestructableX(D)
local real Y = GetDestructableY(D)
local real life = GetDestructableLife(D)*100 / GetDestructableMaxLife(D)
call CreateDestructableZ(Type,X,Y,Height,Facing,Scale,Variation)
call SetDestructableLifePercentBJ(GetLastCreatedDestructable(),life)
endfunction
function AddCustomSpellToEnhancer takes string OrderString, integer UnitType, real Mana, real Range, string Func returns nothing
set udg_zz_SEAnzahl = udg_zz_SEAnzahl + 1
set udg_zz_SEOrder[udg_zz_SEAnzahl] = OrderString
set udg_zz_SECastingType[udg_zz_SEAnzahl] = UnitType
set udg_zz_SEMana[udg_zz_SEAnzahl] = Mana
set udg_zz_SERange[udg_zz_SEAnzahl] = Range
set udg_zz_SEFunc[udg_zz_SEAnzahl] = Func
endfunction
function CreateMissileEffect takes location Start, location End, string Path, real Scale, boolean Ground returns nothing
local unit Attacker
local unit Target
local integer Index = 0
loop
exitwhen udg_zz_MissileModel[Index] == Path
set Index = Index + 1
endloop
set Attacker = CreateUnit(Player(PLAYER_NEUTRAL_AGGRESSIVE),udg_zz_MissileUnitType[Index],GetLocationX(Start),GetLocationY(Start),90)
call ShowUnitHide(Attacker)
call SetUnitScalePercent(Attacker,Scale,Scale,Scale)
if Index == 34 then
call IssueImmediateOrderBJ(Attacker,"flamingarrows")
endif
if Ground == true then
set Target = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE),'ewsp',GetLocationX(End),GetLocationY(End),90)
else
set Target = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE),'nshf',GetLocationX(End),GetLocationY(End),90)
call SetUnitFlyHeightBJ(Target,20.00,0.00)
endif
call SetUnitScalePercent(Target,1,1,1)
call IssueTargetOrderBJ(Attacker,udg_zz_MissileOrder[Index],Target)
call PolledWait(2)
call RemoveUnit(Attacker)
call RemoveUnit(Target)
endfunction
function MovWalk takes integer Pid returns nothing
call IssuePointOrderLocBJ(udg_zz_MovUnit[Pid],"move",PolarProjectionBJ(GetUnitLoc(udg_zz_MovUnit[Pid]),250,GetUnitFacing(udg_zz_MovUnit[Pid]) + I2R(udg_zz_MovLeft[Pid]) - I2R(udg_zz_MovRight[Pid])))
endfunction
function DisableKeyControlForPlayer takes player P returns nothing
local integer Pid = GetPlayerId(P)
local integer Index = 0
local integer Notactive = 0
local group G = CreateGroup()
set udg_zz_MovUnit[Pid] = FirstOfGroup(G)
loop
if udg_zz_MovUnit[Index] == null or IsUnitAliveBJ(udg_zz_MovUnit[Index]) == false then
set Notactive = Notactive + 1
endif
exitwhen Index == 11
set Index = Index + 1
endloop
if Notactive == 12 then
call DisableTrigger(udg_zz_MovForward)
call DisableTrigger(udg_zz_MovSidewards)
call DisableTrigger(udg_zz_PressUp)
call DisableTrigger(udg_zz_ReleaseUp)
call DisableTrigger(udg_zz_PressLeft)
call DisableTrigger(udg_zz_ReleaseLeft)
call DisableTrigger(udg_zz_PressRight)
call DisableTrigger(udg_zz_ReleaseRight)
call DisableTrigger(udg_zz_PressDown)
endif
call DestroyGroup(G)
set G = null
endfunction
function MovForward_Actions takes nothing returns nothing
local integer Index = 0
loop
if IsUnitAliveBJ(udg_zz_MovUnit[Index]) and udg_zz_MovMoving[Index] then
call MovWalk(Index)
elseif IsUnitAliveBJ(udg_zz_MovUnit[Index]) == false then
call DisableKeyControlForPlayer(Player(Index))
endif
exitwhen Index == 11
set Index = Index + 1
endloop
endfunction
function MovSidewards_Actions takes nothing returns nothing
local integer Index = 0
loop
if IsUnitAliveBJ(udg_zz_MovUnit[Index]) and udg_zz_MovMoving[Index] == false then
if udg_zz_MovLeft[Index] > 0 and udg_zz_MovRight[Index] == 0 then
call SetUnitFacingTimed(udg_zz_MovUnit[Index],GetUnitFacing(udg_zz_MovUnit[Index]) + 90,1.00)
elseif udg_zz_MovRight[Index] > 0 then
call SetUnitFacingTimed(udg_zz_MovUnit[Index],GetUnitFacing(udg_zz_MovUnit[Index]) - 90,1.00)
endif
endif
exitwhen Index == 11
set Index = Index + 1
endloop
endfunction
function PressUp_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
set udg_zz_MovMoving[Pid] = true
call MovWalk(Pid)
endif
endfunction
function ReleaseUp_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
set udg_zz_MovMoving[Pid] = false
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
call IssueImmediateOrderBJ(udg_zz_MovUnit[Pid],"stop")
endif
endfunction
function PressLeft_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
set udg_zz_MovLeft[Pid] = 20
if udg_zz_MovMoving[Pid] then
call MovWalk(Pid)
endif
endif
endfunction
function PressRight_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
set udg_zz_MovRight[Pid] = 20
if udg_zz_MovMoving[Pid] then
call MovWalk(Pid)
endif
endif
endfunction
function ReleaseLeft_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
set udg_zz_MovLeft[Pid] = 0
if udg_zz_MovMoving[Pid] then
call MovWalk(Pid)
endif
endif
endfunction
function ReleaseRight_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
set udg_zz_MovRight[Pid] = 0
if udg_zz_MovMoving[Pid] then
call MovWalk(Pid)
endif
endif
endfunction
function PressDown_Actions takes nothing returns nothing
local integer Pid = GetPlayerId(GetTriggerPlayer())
if IsUnitAliveBJ(udg_zz_MovUnit[Pid]) then
call IssuePointOrderLocBJ(udg_zz_MovUnit[Pid],"move",PolarProjectionBJ(GetUnitLoc(udg_zz_MovUnit[Pid]),200,GetUnitFacing(udg_zz_MovUnit[Pid]) + 180))
endif
endfunction
function EnableKeyControlForPlayer takes player P, unit U returns nothing
local integer Pid = GetPlayerId(P)
if Pid > 11 then
return
endif
call EnableTrigger(udg_zz_MovForward)
call EnableTrigger(udg_zz_MovSidewards)
call EnableTrigger(udg_zz_PressUp)
call EnableTrigger(udg_zz_ReleaseUp)
call EnableTrigger(udg_zz_PressLeft)
call EnableTrigger(udg_zz_ReleaseLeft)
call EnableTrigger(udg_zz_PressRight)
call EnableTrigger(udg_zz_ReleaseRight)
call EnableTrigger(udg_zz_PressDown)
set udg_zz_MovUnit[Pid] = U
set udg_zz_MovMoving[Pid] = false
set udg_zz_MovLeft[Pid] = 0
set udg_zz_MovRight[Pid] = 0
endfunction
function IsKeyControlEnabledForPlayer takes player P returns boolean
local integer Pid = GetPlayerId(P)
return udg_zz_MovUnit[Pid] != null and IsUnitAliveBJ(udg_zz_MovUnit[Pid])
endfunction
function CamStopFollowing takes player P returns nothing
local integer Index = 0
local integer Notactive = 0
local group G = CreateGroup()
set udg_zz_CamFollowUnit[GetPlayerId(P)] = FirstOfGroup(G)
set udg_zz_AdjustCam[GetPlayerId(P)] = false
call DisableKeyControlForPlayer(P)
loop
if udg_zz_CamFollowUnit[Index] == null or IsUnitAliveBJ(udg_zz_CamFollowUnit[Index]) == false then
set Notactive = Notactive + 1
endif
exitwhen Index == 11
set Index = Index + 1
endloop
if Notactive == 12 then
call DisableTrigger(udg_zz_TrigAlways)
endif
call DestroyGroup(G)
set G = null
endfunction
function GetCamFollowUnit takes player P returns unit
return udg_zz_CamFollowUnit[GetPlayerId(P)]
endfunction
function GetKeyControlUnit takes player P returns unit
return udg_zz_MovUnit[GetPlayerId(P)]
endfunction
function AdjustCam takes nothing returns nothing
local integer Index = 0
local player P
loop
if udg_zz_AdjustCam[Index] == true then
set P = Player(Index)
if IsUnitAliveBJ(udg_zz_CamFollowUnit[Index]) == false then
call CamStopFollowing(Player(Index))
endif
if udg_zz_UseOffset[Index] == true then
call PanCameraToTimedLocForPlayer(P,PolarProjectionBJ(GetUnitLoc(udg_zz_CamFollowUnit[Index]),udg_zz_CamOffset[Index],GetUnitFacing(udg_zz_CamFollowUnit[Index])),1)
endif
if udg_zz_UseDistance[Index] == true then
call SetCameraFieldForPlayer(P,CAMERA_FIELD_TARGET_DISTANCE,udg_zz_TargetDistance[Index],1.00)
endif
if udg_zz_UseRoll[Index] == true then
call SetCameraFieldForPlayer(P,CAMERA_FIELD_ROLL,udg_zz_CamRoll[Index],1.00)
endif
if udg_zz_UseRotation[Index] == true then
call SetCameraFieldForPlayer(P,CAMERA_FIELD_ROTATION,GetUnitFacing(udg_zz_CamFollowUnit[Index]),1)
endif
if udg_zz_UseAngle[Index] == true then
call SetCameraFieldForPlayer(P,CAMERA_FIELD_ANGLE_OF_ATTACK,udg_zz_CamAngle[Index],1.00)
endif
if udg_zz_UseZOffset[Index] == true then
call SetCameraFieldForPlayer(P,CAMERA_FIELD_ZOFFSET,udg_zz_CamZOffset[Index],1.00)
endif
endif
exitwhen Index == 11
set Index = Index + 1
endloop
endfunction
function SetStartupSkills takes integer Sk, unit U, integer Level returns nothing
endfunction
function XSkill_Actions takes nothing returns nothing
local integer Id = GetUniqueEinheitsnummer(GetLearningUnit())
local integer Sk = GetLearnedSkill()
set udg_zz_XLearnedSkill[Id] = Sk
if udg_zz_HeroSkill1[Id] == Sk then
elseif udg_zz_HeroSkill2[Id] == Sk then
elseif udg_zz_HeroSkill3[Id] == Sk then
elseif udg_zz_HeroSkill4[Id] == Sk then
elseif udg_zz_HeroSkill5[Id] == Sk then
else
if udg_zz_HeroSkill1[Id] == 0 or udg_zz_HeroSkill1[Id] == null then
set udg_zz_HeroSkill1[Id] = Sk
elseif udg_zz_HeroSkill2[Id] == 0 or udg_zz_HeroSkill2[Id] == null then
set udg_zz_HeroSkill2[Id] = Sk
elseif udg_zz_HeroSkill3[Id] == 0 or udg_zz_HeroSkill3[Id] == null then
set udg_zz_HeroSkill3[Id] = Sk
elseif udg_zz_HeroSkill4[Id] == 0 or udg_zz_HeroSkill4[Id] == null then
set udg_zz_HeroSkill4[Id] = Sk
else
set udg_zz_HeroSkill5[Id] = Sk
endif
endif
endfunction
function XTrain_Actions takes nothing returns nothing
set udg_zz_XTrainedUnit[GetUniqueEinheitsnummer(GetTriggerUnit())] = GetTrainedUnit()
endfunction
function XResearch_Actions takes nothing returns nothing
set udg_zz_XResearchedUpgrade[GetUniqueEinheitsnummer(GetTriggerUnit())] = GetResearched()
endfunction
function XSummon_Actions takes nothing returns nothing
set udg_zz_XSummonedUnit[GetUniqueEinheitsnummer(GetSummoningUnit())] = GetSummonedUnit()
endfunction
function XConstruction_Actions takes nothing returns nothing
set udg_zz_XBuiltConstruction[GetUniqueEinheitsnummer(GetTriggerUnit())] = GetConstructedStructure()
endfunction
function XPickup_Actions takes nothing returns nothing
set udg_zz_XAcquiredItem[GetUniqueEinheitsnummer(GetTriggerUnit())] = GetManipulatedItem()
endfunction
function XDrop_Actions takes nothing returns nothing
set udg_zz_XDroppedItem[GetUniqueEinheitsnummer(GetTriggerUnit())] = GetManipulatedItem()
endfunction
function XSellunit_Actions takes nothing returns nothing
if GetUnitTypeId(GetSellingUnit()) == 'nshf' then
call RemoveUnit(GetSellingUnit())
call RemoveUnit(GetSoldUnit())
else
set udg_zz_XSoldUnit[GetUniqueEinheitsnummer(GetSellingUnit())] = GetSoldUnit()
endif
endfunction
function XSellitem_Actions takes nothing returns nothing
set udg_zz_XSoldItem[GetUniqueEinheitsnummer(GetSellingUnit())] = GetSoldItem()
endfunction
function CreateSelectableHero takes integer Type, location Loc, real Facing returns nothing
local unit H
call CreateNUnitsAtLoc(1,Type,Player(PLAYER_NEUTRAL_PASSIVE),Loc,Facing)
set H = GetLastCreatedUnit()
call SetHeroLevelBJ(H,10,false)
call SetUnitManaPercentBJ(H,100)
call SetUnitLifePercentBJ(H,100)
call UnitRemoveAbilityBJ('Amov',H)
call UnitRemoveAbilityBJ('Aatk',H)
call UnitRemoveAbilityBJ('Afin',H)
call UnitAddAbilityBJ('Ax0H',H)
call UnitAddAbilityBJ('Ax0I',H)
call GroupAddUnitSimple(H,udg_zz_SelectableHeros)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_TARGET_ORDER)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_POINT_ORDER)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_ORDER)
endfunction
function MakeHeroSelectable takes unit H returns nothing
call SetUnitOwner(H,Player(PLAYER_NEUTRAL_PASSIVE),true)
call SetHeroLevelBJ(H,10,false)
call SetUnitManaPercentBJ(H,100)
call SetUnitLifePercentBJ(H,100)
call UnitRemoveAbilityBJ('Amov',H)
call UnitRemoveAbilityBJ('Aatk',H)
call UnitRemoveAbilityBJ('Afin',H)
call UnitAddAbilityBJ('Ax0H',H)
call UnitAddAbilityBJ('Ax0I',H)
call GroupAddUnitSimple(H,udg_zz_SelectableHeros)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_TARGET_ORDER)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_POINT_ORDER)
call TriggerRegisterUnitEvent(udg_zz_HeroChoice,H,EVENT_UNIT_ISSUED_ORDER)
endfunction
function GetRandomSelectionHeroType takes nothing returns integer
return GetUnitTypeId(GroupPickRandomUnit(udg_zz_SelectableHeros))
endfunction
function GetSelectableHeros takes nothing returns group
return udg_zz_SelectableHeros
endfunction
function HeroSelection_Conditions takes nothing returns boolean
if GetOwningPlayer(GetTriggerUnit()) != Player(PLAYER_NEUTRAL_PASSIVE) then
return false
elseif not IsUnitInGroup(GetTriggerUnit(),udg_zz_SelectableHeros) then
return false
endif
return true
endfunction
function HeroSelection_Actions takes nothing returns nothing
local player Owner = GetTriggerPlayer()
local integer Id = GetPlayerId(Owner)
local unit U = GetTriggerUnit()
if udg_zz_CurrentlySelectedHero[Id] == U then
return
elseif udg_zz_CurrentlySelectedHero[Id] != null then
call SetUnitOwner(udg_zz_CurrentlySelectedHero[Id],Player(PLAYER_NEUTRAL_PASSIVE),true)
call SetUnitManaPercentBJ(udg_zz_CurrentlySelectedHero[Id],100)
call SetUnitLifePercentBJ(udg_zz_CurrentlySelectedHero[Id],100)
call UnitRemoveAbilityBJ('Ax0G',udg_zz_CurrentlySelectedHero[Id])
endif
call UnitAddAbilityBJ('Ax0G',U)
set udg_zz_CurrentlySelectedHero[Id] = U
call SetUnitManaPercentBJ(U,100)
call SetUnitOwner(U,Owner,true)
endfunction
function HeroChoice_Actions takes nothing returns nothing
if OrderId2StringBJ(GetIssuedOrderIdBJ()) == "berserk" then
set udg_zz_DetectSelected = 1
set udg_zz_DetectSelected = 0
call SetUnitManaPercentBJ(GetTriggerUnit(),100)
call SetUnitLifePercentBJ(GetTriggerUnit(),100)
call UnitRemoveAbilityBJ('Ax0G',GetTriggerUnit())
set udg_zz_CurrentlySelectedHero[GetPlayerId(GetOwningPlayer(GetTriggerUnit()))] = null
call SetUnitOwner(GetTriggerUnit(),Player(PLAYER_NEUTRAL_PASSIVE),true)
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "taunt" then
set udg_zz_DetectRandom = 1
set udg_zz_DetectRandom = 0
call SetUnitManaPercentBJ(GetTriggerUnit(),100)
call SetUnitLifePercentBJ(GetTriggerUnit(),100)
call UnitRemoveAbilityBJ('Ax0G',GetTriggerUnit())
set udg_zz_CurrentlySelectedHero[GetPlayerId(GetOwningPlayer(GetTriggerUnit()))] = null
call SetUnitOwner(GetTriggerUnit(),Player(PLAYER_NEUTRAL_PASSIVE),true)
elseif OrderId2StringBJ(GetIssuedOrderIdBJ()) == "(null)" then
call TriggerSleepAction(0.01)
return
endif
call DisableTrigger(GetTriggeringTrigger())
call PauseUnitBJ(true,GetTriggerUnit())
call IssueImmediateOrderBJ(GetTriggerUnit(),"stop")
call PauseUnitBJ(false,GetTriggerUnit())
call TriggerSleepAction(0.01)
call EnableTrigger(GetTriggeringTrigger())
endfunction
function Enhancer_Conditions takes nothing returns boolean
local boolean Held = false
local boolean VorhandenerString = false
local integer Index = 1
local string Order = OrderId2StringBJ(GetIssuedOrderIdBJ())
if Order == "(null)" then
return false
elseif Order == "resumeharvesting" then
return false
elseif Order == "stop" then
return false
endif
set udg_zz_SELastOrder = Order
if Order == "smart" then
return false
elseif Order == "board" then
return false
elseif Order == "holdposition" then
return false
elseif Order == "move" or Order == "attack" then
return false
elseif Order == "patrol" or Order == "attackground" then
return false
elseif Order == "battlestations" or Order == "standdown" then
return false
elseif Order == "unloadall" or Order == "unload" then
return false
elseif Order == "restoration" or Order == "repair" or Order == "renew" or Order == "revive" then
return false
elseif Order == "unloadallinstant" or Order == "load" or Order == "loadarcher" or Order == "loadcorpse" then
return false
endif
loop
if udg_zz_SEOrder[Index] == OrderId2StringBJ(GetIssuedOrderIdBJ()) then
if udg_zz_SECastingType[Index] == GetUnitTypeId(GetOrderedUnit()) then
set udg_zz_SEIndex = Index
return true
endif
endif
exitwhen Index == udg_zz_SEAnzahl
set Index = Index + 1
endloop
return false
endfunction
function Enhancer_Actions takes nothing returns nothing
local integer Index = udg_zz_SEIndex
local real Distanz
local boolean UnitTarget = false
set udg_zz_SECaster = GetOrderedUnit()
if udg_zz_SERange[Index] > 0 then
if GetLocationX(GetOrderPointLoc()) == 0 and GetLocationY(GetOrderPointLoc()) == 0 then
set udg_zz_SETarget = GetOrderTargetUnit()
set udg_zz_SETX = GetUnitX(udg_zz_SETarget)
set udg_zz_SETY = GetUnitY(udg_zz_SETarget)
set UnitTarget = true
else
set udg_zz_SETX = GetLocationX(GetOrderPointLoc())
set udg_zz_SETY = GetLocationY(GetOrderPointLoc())
endif
set Distanz = DistanceBetweenPoints(GetUnitLoc(udg_zz_SECaster),Location(udg_zz_SETX,udg_zz_SETY)) - 150
if Distanz <= udg_zz_SERange[Index] then
call ExecuteFunc(udg_zz_SEFunc[Index])
return
else
loop
call PolledWait(0.5)
if udg_zz_SELastOrder != udg_zz_SEOrder[Index] then
return
elseif IsUnitDeadBJ(udg_zz_SECaster) == true then
return
elseif DistanceBetweenPoints(GetUnitLoc(udg_zz_SECaster),Location(udg_zz_SETX,udg_zz_SETY)) - 150 <= udg_zz_SERange[Index] and GetUnitStateSwap(UNIT_STATE_MANA,udg_zz_SECaster) < udg_zz_SEMana[Index] then
call ErrorMsg(GetOwningPlayer(udg_zz_SECaster),"Not enough mana.")
return
elseif udg_zz_SETarget != null and IsUnitDeadBJ(udg_zz_SETarget) == true then
call ErrorMsg(GetOwningPlayer(udg_zz_SETarget),"Target unit is already dead.")
return
endif
if UnitTarget == true then
set udg_zz_SETX = GetUnitX(udg_zz_SETarget)
set udg_zz_SETY = GetUnitY(udg_zz_SETarget)
endif
exitwhen DistanceBetweenPoints(GetUnitLoc(udg_zz_SECaster),Location(udg_zz_SETX,udg_zz_SETY)) - 150 <= udg_zz_SERange[Index] and GetUnitStateSwap(UNIT_STATE_MANA,udg_zz_SECaster) >= udg_zz_SEMana[Index]
endloop
call ExecuteFunc(udg_zz_SEFunc[Index])
return
endif
endif
call ExecuteFunc(udg_zz_SEFunc[Index])
endfunction
function Bau_Actions takes nothing returns nothing
set udg_zz_UnfertigeGebIndex = udg_zz_UnfertigeGebIndex + 1
set udg_zz_UnfertigeGebaeude[udg_zz_UnfertigeGebIndex] = GetTriggerUnit()
endfunction
function Bauende_Actions takes nothing returns nothing
local integer Index = 0
loop
exitwhen udg_zz_UnfertigeGebaeude[Index] == GetTriggerUnit()
exitwhen Index == udg_zz_UnfertigeGebIndex + 1
set Index = Index + 1
endloop
if Index == udg_zz_UnfertigeGebIndex + 1 then
return
endif
set udg_zz_UnfertigeGebaeude[Index] = null
endfunction
function Upgrade_Actions takes nothing returns nothing
set udg_zz_UnfertigeUpgradesIndex = udg_zz_UnfertigeUpgradesIndex + 1
set udg_zz_UnfertigeUpgrades[udg_zz_UnfertigeUpgradesIndex] = GetTriggerUnit()
endfunction
function Upgradeende_Actions takes nothing returns nothing
local integer Index = 0
loop
exitwhen udg_zz_UnfertigeUpgrades[Index] == GetTriggerUnit()
exitwhen Index == udg_zz_UnfertigeUpgradesIndex + 1
set Index = Index + 1
endloop
if Index == udg_zz_UnfertigeUpgradesIndex + 1 then
return
endif
set udg_zz_UnfertigeUpgrades[Index] = null
endfunction
function Beschwoerung_Actions takes nothing returns nothing
set udg_zz_ErweckteIndex = udg_zz_ErweckteIndex + 1
set udg_zz_ErweckteKreaturen[udg_zz_ErweckteIndex] = GetTriggerUnit()
endfunction
function Tod_Conditions takes nothing returns boolean
if IsUnitType(GetTriggerUnit(),UNIT_TYPE_STRUCTURE) == true then
return true
endif
return false
endfunction
function Tod_Actions takes nothing returns nothing
local integer Index = 0
loop
exitwhen Index > udg_zz_UnfertigeGebIndex
if udg_zz_UnfertigeGebaeude[Index] == GetTriggerUnit() then
set udg_zz_UnfertigeGebaeude[Index] = null
return
endif
set Index = Index + 1
endloop
set Index = 0
loop
exitwhen Index > udg_zz_UnfertigeUpgradesIndex
if udg_zz_UnfertigeUpgrades[Index] == GetTriggerUnit() then
set udg_zz_UnfertigeUpgrades[Index] = null
return
endif
set Index = Index + 1
endloop
endfunction
function MJSelection_Conditions takes nothing returns boolean
if udg_zz_MJAuswahl[GetPlayerId(GetOwningPlayer(GetTriggerUnit())) * 6] == true then
if GetUnitTypeId(GetTriggerUnit()) == 'Hmkg' then
return true
endif
endif
return false
endfunction
function MJSelection_Actions takes nothing returns nothing
local integer Index = 0
local integer id = GetPlayerId(GetOwningPlayer(GetTriggerUnit()))
loop
if udg_zz_MJAuswahleinheit[id * 6 + Index] == GetTriggerUnit() then
set udg_zz_MJAuswahl[id * 6 + Index + 1] = true
endif
exitwhen Index == 4
set Index = Index + 1
endloop
call StopSoundBJ(udg_zz_MJLastSound[id],false)
endfunction
function MJSkip_Actions takes nothing returns nothing
local integer id = GetPlayerId(GetTriggerPlayer())
call StopSoundBJ(udg_zz_MJLastSound[id],false)
if udg_zz_ATToBeSkipped[id] == true then
call StopSoundBJ(udg_zz_ATLastSound[id],false)
endif
endfunction
function IsCamFollowEnabled takes player P returns boolean
local integer Pid = GetPlayerId(P)
return udg_zz_CamFollowUnit[Pid] != null and IsUnitAliveBJ(udg_zz_CamFollowUnit[Pid]) == true
endfunction
function CamFollowUnit takes player P, unit U, boolean KeyControl returns nothing
local integer Pid = GetPlayerId(P)
set udg_zz_CamOffset[Pid] = 450
set udg_zz_CamRoll[Pid] = 0
set udg_zz_CamRotation[Pid] = 90
set udg_zz_TargetDistance[Pid] = 2000
set udg_zz_CamAngle[Pid] = 315
set udg_zz_CamZOffset[Pid] = 0
set udg_zz_UseRoll[Pid] = true
set udg_zz_UseAngle[Pid] = true
set udg_zz_UseZOffset[Pid] = true
set udg_zz_UseDistance[Pid] = true
set udg_zz_UseRotation[Pid] = true
set udg_zz_UseOffset[Pid] = true
set udg_zz_AdjustCam[Pid] = true
set udg_zz_CamAlreadyOff[Pid] = false
set udg_zz_CamFollowUnit[Pid] = U
call EnableTrigger(udg_zz_TrigAlways)
if KeyControl == true then
call EnableKeyControlForPlayer(P,U)
endif
endfunction
function SetFollowDetails takes player P, integer Field, real Wert returns nothing
local integer Pid = GetPlayerId(P)
if Field == 0 then
set udg_zz_CamOffset[Pid] = Wert
elseif Field == 1 then
set udg_zz_CamRoll[Pid] = Wert
elseif Field == 2 then
set udg_zz_CamRotation[Pid] = Wert
elseif Field == 3 then
set udg_zz_TargetDistance[Pid] = Wert
elseif Field == 4 then
set udg_zz_CamAngle[Pid] = Wert
elseif Field == 5 then
set udg_zz_CamZOffset[Pid] = Wert
endif
endfunction
function SetFollowOptions takes player P, integer Field, boolean Wert returns nothing
local integer Pid = GetPlayerId(P)
if Field == 0 then
set udg_zz_UseOffset[Pid] = Wert
elseif Field == 1 then
set udg_zz_UseRoll[Pid] = Wert
elseif Field == 2 then
set udg_zz_UseRotation[Pid] = Wert
elseif Field == 3 then
set udg_zz_UseDistance[Pid] = Wert
elseif Field == 4 then
set udg_zz_UseAngle[Pid] = Wert
elseif Field == 5 then
set udg_zz_UseZOffset[Pid] = Wert
endif
endfunction
function GetFollowDetails takes player P, integer Field returns real
local integer Pid = GetPlayerId(P)
if Field == 0 then
return udg_zz_CamOffset[Pid]
elseif Field == 1 then
return udg_zz_CamRoll[Pid]
elseif Field == 2 then
return GetUnitFacing(udg_zz_CamFollowUnit[Pid])
elseif Field == 3 then
return udg_zz_TargetDistance[Pid]
elseif Field == 4 then
return udg_zz_CamAngle[Pid]
endif
return udg_zz_CamZOffset[Pid]
endfunction
function GetFollowOptions takes player P, integer Field returns boolean
local integer Pid = GetPlayerId(P)
if Field == 0 then
return udg_zz_UseOffset[Pid]
elseif Field == 1 then
return udg_zz_UseRoll[Pid]
elseif Field == 2 then
return udg_zz_UseRotation[Pid]
elseif Field == 3 then
return udg_zz_UseDistance[Pid]
elseif Field == 4 then
return udg_zz_UseAngle[Pid]
endif
return udg_zz_UseZOffset[Pid]
endfunction
function SetCustomStringValue takes unit U, string S returns nothing
set udg_zz_CustomStringValue[GetUniqueEinheitsnummer(U)] = S
endfunction
function SetCustomRealValue takes unit U, real R returns nothing
set udg_zz_CustomRealValue[GetUniqueEinheitsnummer(U)] = R
endfunction
function SetCustomBooleanValue takes unit U, boolean B returns nothing
set udg_zz_CustomBooleanValue[GetUniqueEinheitsnummer(U)] = B
endfunction
function GetCustomStringValue takes unit U returns string
return udg_zz_CustomStringValue[GetUniqueEinheitsnummer(U)]
endfunction
function GetCustomRealValue takes unit U returns real
return udg_zz_CustomRealValue[GetUniqueEinheitsnummer(U)]
endfunction
function GetCustomBooleanValue takes unit U returns boolean
return udg_zz_CustomBooleanValue[GetUniqueEinheitsnummer(U)]
endfunction
function TurnString takes string S returns string
local integer L = GetLength(S)
local string Ret = ""
loop
set Ret = Ret + SubStringBJ(S,L,L)
exitwhen L == 1
set L = L - 1
endloop
return Ret
endfunction
function IsPlayerCommandable takes player P returns boolean
local integer Pid = GetPlayerId(P)
local integer Wert
local string CompareStr
if Pid > 5 then
set Pid = Pid - 6
set Wert = GetPlayerState(Player(14),PLAYER_STATE_RESOURCE_GOLD)
else
set Wert = GetPlayerState(Player(14),PLAYER_STATE_RESOURCE_LUMBER)
endif
set CompareStr = I2S(Wert)
set CompareStr = TurnString(CompareStr)
set Pid = Pid + 1
if GetLength(CompareStr) < Pid then
return false
endif
if SubStringBJ(CompareStr,Pid,Pid) != "1" then
return false
endif
return true
endfunction
function GetCommandablePlayers takes nothing returns force
local integer Index = 1
local string CompStr = I2S(GetPlayerState(Player(14),PLAYER_STATE_RESOURCE_LUMBER))
local integer L = GetLength(CompStr)
local force Ret = CreateForce()
set CompStr = TurnString(CompStr)
loop
exitwhen Index > L
if SubStringBJ(CompStr,Index,Index) == "1" then
call ForceAddPlayer(Ret,Player(Index - 1))
endif
set Index = Index + 1
endloop
set CompStr = TurnString(I2S(GetPlayerState(Player(14),PLAYER_STATE_RESOURCE_GOLD)))
set L = GetLength(CompStr)
set Index = 1
loop
exitwhen Index > L
if SubStringBJ(CompStr,Index,Index) == "1" then
call ForceAddPlayer(Ret,Player(Index + 5))
endif
set Index = Index + 1
endloop
return Ret
endfunction
function MultiboardSetup takes integer Cols, integer Rows, string Name, integer BarRow returns nothing
local multiboarditem Temp
local integer Index = 0
local multiboard M = CreateMultiboardBJ(Cols,Rows,Name)
call MultiboardSetItemStyleBJ(M,0,0,true,false)
call MultiboardSetItemWidthBJ(M,0,0,0.05)
loop
exitwhen Index >= Cols
set Temp = MultiboardGetItem(M,BarRow - 1,Index)
call MultiboardSetItemStyle(Temp,false,true)
if Index == 0 then
call MultiboardSetItemWidth(Temp,0.006)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarLeftBase.blp")
elseif Index == Cols - 1 then
call MultiboardSetItemWidth(Temp,0.004)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarRightBase.blp")
else
call MultiboardSetItemWidth(Temp,0.005)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleBase.blp")
endif
call MultiboardReleaseItem(Temp)
set Index = Index + 1
endloop
call MultiboardMinimizeBJ(false,M)
endfunction
function MultiboardAddBar takes multiboard M, integer BarRow returns nothing
local multiboarditem Temp
local integer Index = 0
local integer Cols = MultiboardGetColumnCount(M)
if Cols < 5 then
return
endif
loop
exitwhen Index >= Cols
set Temp = MultiboardGetItem(M,BarRow - 1,Index)
call MultiboardSetItemStyle(Temp,false,true)
if Index == 0 then
call MultiboardSetItemWidth(Temp,0.006)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarLeftBase.blp")
elseif Index == Cols - 1 then
call MultiboardSetItemWidth(Temp,0.004)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarRightBase.blp")
else
call MultiboardSetItemWidth(Temp,0.005)
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleBase.blp")
endif
call MultiboardReleaseItem(Temp)
set Index = Index + 1
endloop
endfunction
function MultiboardUpdate takes multiboard M, integer Row, real Percentage returns nothing
local multiboarditem Temp
local integer Index = 0
local integer Cols = MultiboardGetColumnCount(M)
local integer Strength = R2I((Percentage * Cols) / 100)
loop
exitwhen Index >= Cols
set Temp = MultiboardGetItem(M,Row - 1,Index)
if Index == 0 then
if Strength <= 0 then
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarLeftBase.blp")
else
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarLeftGreen.blp")
endif
elseif Index == Cols - 1 then
if Strength >= Cols then
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarRightRed.blp")
else
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarRightBase.blp")
endif
elseif Strength > Index then
if Index <= R2I((Cols - 2) / 3) then
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleGreen.blp")
elseif Index > R2I((Cols - 2) / 3) * 2 then
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleRed.blp")
else
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleYellow.blp")
endif
else
call MultiboardSetItemIcon(Temp,"Objects\\Board\\BarMiddleBase.blp")
endif
call MultiboardReleaseItem(Temp)
set Index = Index + 1
endloop
endfunction
constant function LowWord takes integer i returns integer
if i < 0 then
return (i + 0x80000000) - (i + 0x80000000) / 0x10000 * 0x10000
endif
return i - i / 0x10000 * 0x10000
endfunction
constant function HighWord takes integer i returns integer
if i < 0 then
return (i + 0x80000000) / 0x10000 + 0x8000
endif
return i / 0x10000
endfunction
constant function CreateDWord takes integer low, integer high returns integer
return low + high * 0x10000
endfunction
constant function SetLowWord takes integer dword, integer low returns integer
if dword < 0 then
return dword / 0x10000 * 0x10000 + low - 0x10000
endif
return dword / 0x10000 * 0x10000 + low
endfunction
constant function SetHighWord takes integer dword, integer high returns integer
return LowWord(dword) + high * 0x10000
endfunction
constant function HeapGet takes integer index returns integer
local integer arrayId = index / JASS_MAX_ARRAY_SIZE
local integer arrayIndex = index - index / JASS_MAX_ARRAY_SIZE * JASS_MAX_ARRAY_SIZE
if arrayId == 0 then
return udg_zz_heap_array_0[arrayIndex]
elseif arrayId == 1 then
return udg_zz_heap_array_1[arrayIndex]
elseif arrayId == 2 then
return udg_zz_heap_array_2[arrayIndex]
endif
return 0xFFFFFFFF
endfunction
function HeapSet takes integer index, integer value returns nothing
local integer arrayId = index / JASS_MAX_ARRAY_SIZE
local integer arrayIndex = index - index / JASS_MAX_ARRAY_SIZE * JASS_MAX_ARRAY_SIZE
if arrayId == 0 then
set udg_zz_heap_array_0[arrayIndex] = value
elseif arrayId == 1 then
set udg_zz_heap_array_1[arrayIndex] = value
elseif arrayId == 2 then
set udg_zz_heap_array_2[arrayIndex] = value
endif
endfunction
constant function HeapDescriptorArrayGet takes integer index returns integer
local integer arrayId = index / JASS_MAX_ARRAY_SIZE
local integer arrayIndex = index - index / JASS_MAX_ARRAY_SIZE * JASS_MAX_ARRAY_SIZE
if arrayId == 0 then
return udg_zz_heap_descriptor_array_0[arrayIndex]
elseif arrayId == 1 then
return udg_zz_heap_descriptor_array_1[arrayIndex]
endif
return 0xFFFFFFFF
endfunction
function HeapDescriptorArraySet takes integer index, integer value returns nothing
local integer arrayId = index / JASS_MAX_ARRAY_SIZE
local integer arrayIndex = index - index / JASS_MAX_ARRAY_SIZE * JASS_MAX_ARRAY_SIZE
if arrayId == 0 then
set udg_zz_heap_descriptor_array_0[arrayIndex] = value
elseif arrayId == 1 then
set udg_zz_heap_descriptor_array_1[arrayIndex] = value
endif
endfunction
constant function HeapDescriptorGet takes integer descriptorId, integer field returns integer
local integer index = descriptorId * udg_zz_heap_descriptor_record_size
if field == 0 then
return LowWord(HeapDescriptorArrayGet(index))
elseif field == 1 then
return HighWord(HeapDescriptorArrayGet(index))
elseif field == 2 then
return HeapDescriptorArrayGet(index + 1)
elseif field == 3 then
return HeapDescriptorArrayGet(index + 2)
endif
return 0xFFFFFFFF
endfunction
function HeapDescriptorSet takes integer descriptorId, integer field, integer value returns nothing
local integer index = descriptorId * udg_zz_heap_descriptor_record_size
if field == 0 then
call HeapDescriptorArraySet(index, SetLowWord(HeapDescriptorArrayGet(index), value))
elseif field == 1 then
call HeapDescriptorArraySet(index, SetHighWord(HeapDescriptorArrayGet(index), value))
elseif field == 2 then
call HeapDescriptorArraySet(index + 1, value)
elseif field == 3 then
call HeapDescriptorArraySet(index + 2, value)
endif
endfunction
function IsHeapDescriptorFree takes integer descriptor returns boolean
return HeapDescriptorGet(descriptor, 2) == 0
endfunction
function HeapFindFirstFreeDescriptor takes nothing returns integer
local integer descriptor = udg_zz_heap_descriptor_alloccursor
loop
set descriptor = descriptor + 1
if descriptor == udg_zz_heap_descriptor_end then
set descriptor = 1
endif
exitwhen IsHeapDescriptorFree(descriptor) or descriptor == udg_zz_heap_descriptor_alloccursor
endloop
if descriptor == udg_zz_heap_descriptor_alloccursor then
return 0
endif
set udg_zz_heap_descriptor_alloccursor = descriptor
return descriptor
endfunction
function HeapMergeNewDescriptor takes integer previous, integer next, integer begin, integer end returns integer
local integer descriptor = HeapFindFirstFreeDescriptor()
if descriptor == 0 then
return 0
endif
call HeapDescriptorSet(descriptor, 0, next)
call HeapDescriptorSet(descriptor, 1, previous)
call HeapDescriptorSet(descriptor, 2, begin)
call HeapDescriptorSet(descriptor, 3, end)
if previous == 0 then
set udg_zz_heap_descriptor_first = descriptor
else
call HeapDescriptorSet(previous, 0, descriptor)
endif
if next == 0 then
set udg_zz_heap_descriptor_last = descriptor
else
call HeapDescriptorSet(next, 1, descriptor)
endif
return descriptor
endfunction
function HeapNew takes integer length returns integer
local integer last_begin = udg_zz_heap_array_begin
local integer last_end
local integer next = 0
local integer previous = 0
local integer descriptor = udg_zz_heap_descriptor_first
loop
exitwhen descriptor == 0
set last_end = HeapDescriptorGet(descriptor, 2)
exitwhen last_end - last_begin >= length
set last_begin = HeapDescriptorGet(descriptor, 3)
set previous = descriptor
set descriptor = HeapDescriptorGet(descriptor, 0)
endloop
if descriptor == 0 then
if udg_zz_heap_array_end - last_begin < length then
return 0
endif
set next = 0
else
set next = descriptor
endif
set last_end = last_begin + length
if HeapMergeNewDescriptor(previous, next, last_begin, last_end) == 0 then
return 0
endif
return last_begin
endfunction
function HeapDescriptorFind takes integer begin returns integer
local integer descriptor = udg_zz_heap_descriptor_first
loop
exitwhen descriptor == 0 or HeapDescriptorGet(descriptor, 2) == begin
set descriptor = HeapDescriptorGet(descriptor, 0)
endloop
return descriptor
endfunction
function HeapDescriptorClear takes integer descriptor returns nothing
local integer begin = descriptor * udg_zz_heap_descriptor_record_size
local integer end = begin + udg_zz_heap_descriptor_record_size
loop
exitwhen begin == end
call HeapDescriptorArraySet(begin, 0)
set begin = begin + 1
endloop
endfunction
function HeapDescriptorDelete takes integer descriptor returns boolean
local integer previous = HeapDescriptorGet(descriptor, 1)
local integer next = HeapDescriptorGet(descriptor, 0)
if next == 0 then
set udg_zz_heap_descriptor_last = previous
else
call HeapDescriptorSet(next, 1, previous)
endif
if previous == 0 then
set udg_zz_heap_descriptor_first = next
else
call HeapDescriptorSet(previous, 0, next)
endif
call HeapDescriptorClear(descriptor)
return true
endfunction
function HeapDeleteEx takes integer pointer returns boolean
local integer descriptor = HeapDescriptorFind(pointer)
if descriptor == 0 then
return false
endif
return HeapDescriptorDelete(descriptor)
endfunction
function HeapDelete takes integer pointer, integer length returns boolean
return HeapDeleteEx(pointer)
endfunction
function HeapSetRange takes integer start1, integer end1, integer value returns nothing
loop
exitwhen start1 == end1
call HeapSet(start1, value)
set start1 = start1 + 1
endloop
endfunction
function HeapCopyRange takes integer start1, integer end1, integer start2 returns nothing
loop
exitwhen start1 == end1
call HeapSet(start2, HeapGet(start1))
set start1 = start1 + 1
set start2 = start2 + 1
endloop
endfunction
function ListNew takes nothing returns integer
return 0
endfunction
constant function ListIsEmpty takes integer list returns boolean
return list == 0
endfunction
function ListAddItem takes integer list, integer value returns integer
local integer pointer = HeapNew(2)
call HeapSet(pointer, list)
call HeapSet(pointer + 1, value)
return pointer
endfunction
constant function ListGetHead takes integer list returns integer
return HeapGet(list + 1)
endfunction
constant function ListGetNext takes integer list returns integer
return HeapGet(list)
endfunction
function ListSetHead takes integer list, integer head returns nothing
call HeapSet(list + 1, head)
endfunction
function ListSetNext takes integer list, integer tail returns nothing
call HeapSet(list, tail)
endfunction
function ListDeleteHead takes integer list returns integer
local integer next = HeapGet(list)
call HeapDeleteEx(list)
return next
endfunction
function ListDeleteAll takes integer list returns nothing
loop
exitwhen list == 0
set list = ListDeleteHead(list)
endloop
endfunction
constant function ListGetTail takes integer list returns integer
local integer next
loop
set next = HeapGet(list)
exitwhen next == 0
set list = next
endloop
return list
endfunction
constant function ListGetSize takes integer list returns integer
local integer count = 0
loop
exitwhen list == 0
set list = HeapGet(list)
set count = count + 1
endloop
return count
endfunction
function ListAddList takes integer list1, integer list2 returns nothing
call HeapSet(ListGetTail(list1), list2)
endfunction
function AddQuestEffect takes unit U returns effect
call AddSpecialEffectTargetUnitBJ("overhead",U,"Abilities\\Spells\\Other\\TalkToMe\\TalkToMe.mdl")
return GetLastCreatedEffectBJ()
endfunction
function I2HexS takes integer I returns string
if GetLength(I2S(I)) == 1 then
return "00" + I2S(I)
elseif GetLength(I2S(I)) == 2 then
return "0" + I2S(I)
endif
return I2S(I)
endfunction
function Player2ColorPercentage takes player P returns string
local string Combine
local playercolor PC
if GetPlayerId(P) == bj_PLAYER_NEUTRAL_VICTIM or GetPlayerId(P) == PLAYER_NEUTRAL_AGGRESSIVE or GetPlayerId(P) == PLAYER_NEUTRAL_PASSIVE then
set Combine = I2HexS(R2I(HexS2Dez("f0")/2.5)) + I2HexS(R2I(HexS2Dez("f0")/2.5)) + I2HexS(R2I(HexS2Dez("f0")/2.5))
else
set PC = GetPlayerColor(P)
if PC == PLAYER_COLOR_RED then
set Combine = I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5))
elseif PC == PLAYER_COLOR_BLUE then
set Combine = I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5))
elseif PC == PLAYER_COLOR_CYAN then
set Combine = I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5))
elseif PC == PLAYER_COLOR_PURPLE then
set Combine = I2HexS(R2I(HexS2Dez("66")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("99")/2.5))
elseif PC == PLAYER_COLOR_YELLOW then
set Combine = I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5))
elseif PC == PLAYER_COLOR_ORANGE then
set Combine = I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("99")/2.5)) + I2HexS(R2I(HexS2Dez("33")/2.5))
elseif PC == PLAYER_COLOR_GREEN then
set Combine = I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5))
elseif PC == PLAYER_COLOR_PINK then
set Combine = I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5))
elseif PC == PLAYER_COLOR_LIGHT_GRAY then
set Combine = I2HexS(R2I(HexS2Dez("dd")/2.5)) + I2HexS(R2I(HexS2Dez("dd")/2.5)) + I2HexS(R2I(HexS2Dez("dd")/2.5))
elseif PC == PLAYER_COLOR_LIGHT_BLUE then
set Combine = I2HexS(R2I(HexS2Dez("33")/2.5)) + I2HexS(R2I(HexS2Dez("cc")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5))
elseif PC == PLAYER_COLOR_AQUA then
set Combine = I2HexS(R2I(HexS2Dez("7f")/2.5)) + I2HexS(R2I(HexS2Dez("ff")/2.5)) + I2HexS(R2I(HexS2Dez("d4")/2.5))
elseif PC == PLAYER_COLOR_BROWN then
set Combine = I2HexS(R2I(HexS2Dez("66")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5)) + I2HexS(R2I(HexS2Dez("00")/2.5))
endif
endif
return Combine
endfunction
function SetPlayerLabels takes integer Index, string L, boolean UsePlayerNames returns string
if L != "" then
if UsePlayerNames == true then
return GetPlayerName(Player(Index))
endif
endif
return L
endfunction
function AdvancedLeaderboard takes force Targetforce, string Title, boolean UsePlayerColor, boolean UsePlayerNames, integer SortingMethod, boolean Aufsteigend, string L1, integer V1, string L2, integer V2, string L3, integer V3, string L4, integer V4, string L5, integer V5, string L6, integer V6, boolean Show returns leaderboard
local leaderboard LB
local string array Label
local integer array Value
local string Farbe
local integer Index = 0
call CreateLeaderboardBJ(Targetforce,Title)
set LB = GetLastCreatedLeaderboard()
set Label[0] = SetPlayerLabels(0,L1,UsePlayerNames)
set Label[1] = SetPlayerLabels(1,L2,UsePlayerNames)
set Label[2] = SetPlayerLabels(2,L3,UsePlayerNames)
set Label[3] = SetPlayerLabels(3,L4,UsePlayerNames)
set Label[4] = SetPlayerLabels(4,L5,UsePlayerNames)
set Label[5] = SetPlayerLabels(5,L6,UsePlayerNames)
set Value[0] = V1
set Value[1] = V2
set Value[2] = V3
set Value[3] = V4
set Value[4] = V5
set Value[5] = V6
loop
if Label[Index] != "" then
call LeaderboardAddItemBJ(Player(Index),LB,Label[Index],Value[Index])
endif
if UsePlayerColor == true then
set Farbe = Player2ColorPercentage(Player(Index))
call LeaderboardSetPlayerItemLabelColorBJ(Player(Index),LB,S2I(SubStringBJ(Farbe,1,3)),S2I(SubStringBJ(Farbe,4,6)),S2I(SubStringBJ(Farbe,7,9)),0)
call LeaderboardSetPlayerItemValueColorBJ(Player(Index),LB,S2I(SubStringBJ(Farbe,1,3)),S2I(SubStringBJ(Farbe,4,6)),S2I(SubStringBJ(Farbe,7,9)),0)
endif
exitwhen Index == 5
set Index = Index + 1
endloop
if SortingMethod >= 0 and SortingMethod <= 3 then
call LeaderboardSortItemsBJ(LB,SortingMethod,Aufsteigend)
endif
if Show == true then
call LeaderboardDisplayBJ(true,LB)
endif
return LB
endfunction
function AdvancedLeaderboardAddPlayers takes leaderboard LB, boolean UsePlayerColor, boolean UsePlayerNames, integer SortingMethod, boolean Aufsteigend, string L7, integer V7, string L8, integer V8, string L9, integer V9, string L10, integer V10, string L11, integer V11, string L12, integer V12, string L13, integer V13, string L14, integer V14, string L15, integer V15 returns nothing
local string array Label
local integer array Value
local string Farbe
local integer Index = 6
set Label[6] = SetPlayerLabels(6,L7,UsePlayerNames)
set Label[7] = SetPlayerLabels(7,L8,UsePlayerNames)
set Label[8] = SetPlayerLabels(8,L9,UsePlayerNames)
set Label[9] = SetPlayerLabels(9,L10,UsePlayerNames)
set Label[10] = SetPlayerLabels(10,L11,UsePlayerNames)
set Label[11] = SetPlayerLabels(11,L12,UsePlayerNames)
set Label[12] = L13
set Label[13] = L14
set Label[15] = L15
set Value[6] = V7
set Value[7] = V8
set Value[8] = V9
set Value[9] = V10
set Value[10] = V11
set Value[11] = V12
set Value[12] = V13
set Value[13] = V14
set Value[15] = V15
loop
if Label[Index] != "" then
call LeaderboardAddItemBJ(Player(Index),LB,Label[Index],Value[Index])
endif
if UsePlayerColor == true then
set Farbe = Player2ColorPercentage(Player(Index))
call LeaderboardSetPlayerItemLabelColorBJ(Player(Index),LB,S2I(SubStringBJ(Farbe,1,3)),S2I(SubStringBJ(Farbe,4,6)),S2I(SubStringBJ(Farbe,7,9)),0)
call LeaderboardSetPlayerItemValueColorBJ(Player(Index),LB,S2I(SubStringBJ(Farbe,1,3)),S2I(SubStringBJ(Farbe,4,6)),S2I(SubStringBJ(Farbe,7,9)),0)
endif
exitwhen Index == 15
if Index == 13 then
set Index = 15
else
set Index = Index + 1
endif
endloop
if SortingMethod >= 0 and SortingMethod <= 3 then
call LeaderboardSortItemsBJ(LB,SortingMethod,Aufsteigend)
endif
call LeaderboardDisplayBJ(true,LB)
endfunction
function UpdateAdvancedLeaderboard takes leaderboard LB, integer SortingMethod, boolean Aufsteigend, integer V1, integer V2, integer V3, integer V4, integer V5, integer V6, integer V7, integer V8, integer V9, integer V10, integer V11, integer V12, integer V13, integer V14, integer V15 returns nothing
call LeaderboardSetPlayerItemValueBJ(Player(0),LB,V1)
call LeaderboardSetPlayerItemValueBJ(Player(1),LB,V2)
call LeaderboardSetPlayerItemValueBJ(Player(2),LB,V3)
call LeaderboardSetPlayerItemValueBJ(Player(3),LB,V4)
call LeaderboardSetPlayerItemValueBJ(Player(4),LB,V5)
call LeaderboardSetPlayerItemValueBJ(Player(5),LB,V6)
call LeaderboardSetPlayerItemValueBJ(Player(6),LB,V7)
call LeaderboardSetPlayerItemValueBJ(Player(7),LB,V8)
call LeaderboardSetPlayerItemValueBJ(Player(8),LB,V9)
call LeaderboardSetPlayerItemValueBJ(Player(9),LB,V10)
call LeaderboardSetPlayerItemValueBJ(Player(10),LB,V11)
call LeaderboardSetPlayerItemValueBJ(Player(11),LB,V12)
call LeaderboardSetPlayerItemValueBJ(Player(12),LB,V13)
call LeaderboardSetPlayerItemValueBJ(Player(13),LB,V14)
call LeaderboardSetPlayerItemValueBJ(Player(14),LB,V15)
if SortingMethod >= 0 and SortingMethod <= 3 then
call LeaderboardSortItemsBJ(LB,SortingMethod,Aufsteigend)
endif
endfunction
function TimerOhneFenster takes real Zeit, boolean Wiederholen, code Folge returns timer
local timer T = CreateTimer()
call TimerStart(T,Zeit,Wiederholen,Folge)
return GetLastCreatedTimerBJ()
endfunction
function AddTimerToArray takes timer T, timerdialog TD returns nothing
local integer Index = 0
loop
if udg_zz_EngineTimers[Index] == T then
set udg_zz_EngineTimerDialogs[Index] = TD
return
endif
exitwhen Index == udg_zz_TimerCounter
set Index = Index + 1
endloop
set udg_zz_EngineTimers[udg_zz_TimerCounter] = T
set udg_zz_EngineTimerDialogs[udg_zz_TimerCounter] = TD
set udg_zz_TimerCounter = udg_zz_TimerCounter + 1
endfunction
function GetDialogOfTimer takes timer T returns timerdialog
local integer Index = 0
loop
if udg_zz_EngineTimers[Index] == T then
return udg_zz_EngineTimerDialogs[Index]
endif
exitwhen Index == udg_zz_TimerCounter - 1
set Index = Index + 1
endloop
return null
endfunction
function TimerMitFenster takes string Title, string TimeColor, real Zeit, boolean Wiederholen, code Folge, boolean Show returns timer
local timer T = CreateTimer()
local integer array Farbe
local timerdialog TD
call TimerStart(T,Zeit,Wiederholen,Folge)
call CreateTimerDialogBJ(T,Title)
set TD = GetLastCreatedTimerDialogBJ()
if Show == true then
call TimerDialogDisplayBJ(true,TD)
if TimeColor != "" then
set Farbe[0] = R2I(HexS2Dez(SubStringBJ(TimeColor,1,2))/2.5)
set Farbe[1] = R2I(HexS2Dez(SubStringBJ(TimeColor,3,4))/2.5)
set Farbe[2] = R2I(HexS2Dez(SubStringBJ(TimeColor,5,6))/2.5)
call TimerDialogSetTimeColorBJ(TD,Farbe[0],Farbe[1],Farbe[2],0)
endif
else
call TimerDialogDisplayBJ(false,TD)
endif
call AddTimerToArray(T,TD)
set bj_lastStartedTimer = T
return T
endfunction
function AddAuswahl takes integer I, string S, string F returns integer
if S != "" then
set udg_zz_VotingAuswahl[I] = S
set udg_zz_VotingFolge[I] = F
return I + 1
endif
return I
endfunction
function GetSpielerFarbe takes player P returns string
local string Colored
local playercolor PColor = GetPlayerColor(P)
if (PColor == PLAYER_COLOR_RED) then
set Colored = "Red"
elseif (PColor == PLAYER_COLOR_BLUE) then
set Colored = "Blue"
elseif (PColor == PLAYER_COLOR_CYAN) then
set Colored = "Teal"
elseif (PColor == PLAYER_COLOR_PURPLE) then
set Colored = "Purple"
elseif (PColor == PLAYER_COLOR_YELLOW) then
set Colored = "Yellow"
elseif (PColor == PLAYER_COLOR_ORANGE) then
set Colored = "Orange"
elseif (PColor == PLAYER_COLOR_GREEN) then
set Colored = "Green"
elseif (PColor == PLAYER_COLOR_PINK) then
set Colored = "Pink"
elseif (PColor == PLAYER_COLOR_LIGHT_GRAY) then
set Colored = "Gray"
elseif (PColor == PLAYER_COLOR_LIGHT_BLUE) then
set Colored = "Light Blue"
elseif (PColor == PLAYER_COLOR_AQUA) then
set Colored = "Dark Green"
elseif (PColor == PLAYER_COLOR_BROWN) then
set Colored = "Brown"
endif
return Colored
endfunction
function VotingTimerWeg takes nothing returns nothing
local integer Index = 0
local integer Zaehler = -1
local string Text = ""
local integer L = GetLength(udg_zz_VotingErgebnis)
loop
if udg_zz_Stimmen[Index] > Zaehler then
set Zaehler = Index
endif
exitwhen Index == 11
set Index = Index + 1
endloop
call DestroyTrigger(udg_zz_StimmenAbgabe)
set udg_zz_StimmenAbgabe = null
call TimerDialogDisplayBJ(false,udg_zz_VotingTimer)
call DestroyTimerDialog(udg_zz_VotingTimer)
set udg_zz_VotingTimer = null
set Index = 1
loop
if SubStringBJ(udg_zz_VotingErgebnis,Index,Index) == "@" then
if Index == 1 then
set Text = udg_zz_VotingAuswahl[Zaehler] + SubStringBJ(udg_zz_VotingErgebnis,Index + 1,L)
elseif Index == L then
set Text = SubStringBJ(udg_zz_VotingErgebnis,1,L-1) + udg_zz_VotingAuswahl[Zaehler]
else
set Text = SubStringBJ(udg_zz_VotingErgebnis,1,Index - 1) + udg_zz_VotingAuswahl[Zaehler] + SubStringBJ(udg_zz_VotingErgebnis,Index + 1,L)
endif
endif
exitwhen Index == L
set Index = Index + 1
endloop
set Index = 0
loop
call DisplayTimedTextToPlayer(Player(Index),0,0,5,Text)
exitwhen Index == 11
set Index = Index + 1
endloop
set Index = 0
loop
call LeaderboardDisplayBJ(false,udg_zz_VotingBoard[Index])
call DestroyLeaderboard(udg_zz_VotingBoard[Index])
set udg_zz_VotingBoard[Index] = null
exitwhen Index == 11
set Index = Index + 1
endloop
call ExecuteFunc(udg_zz_VotingFolge[Zaehler])
endfunction
function Stimmenauswertung takes nothing returns nothing
local integer Index = 0
if udg_zz_StimmeAbgegeben[GetPlayerId(GetTriggerPlayer())] == false then
set udg_zz_StimmeAbgegeben[GetPlayerId(GetTriggerPlayer())] = true
set udg_zz_StimmenAbgegeben = udg_zz_StimmenAbgegeben + 1
set udg_zz_Stimmen[S2I(GetEventPlayerChatString()) - 1] = udg_zz_Stimmen[S2I(GetEventPlayerChatString()) - 1] + 1
if udg_zz_VotingGeheim == true then
call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,5,"Player " + GetSpielerFarbe(GetTriggerPlayer()) + " has chosen " + udg_zz_VotingAuswahl[S2I(GetEventPlayerChatString()) - 1] + ".")
loop
call UpdateAdvancedLeaderboard(udg_zz_VotingBoard[Index],bj_SORTTYPE_SORTBYVALUE,false,udg_zz_Stimmen[0],udg_zz_Stimmen[1],udg_zz_Stimmen[2],udg_zz_Stimmen[3],udg_zz_Stimmen[4],udg_zz_Stimmen[5],udg_zz_Stimmen[6],udg_zz_Stimmen[7],udg_zz_Stimmen[8],udg_zz_Stimmen[9],udg_zz_Stimmen[10],udg_zz_Stimmen[11],udg_zz_Stimmen[12],udg_zz_Stimmen[13],udg_zz_Stimmen[14])
exitwhen Index == 11
set Index = Index + 1
endloop
else
loop
call DisplayTimedTextToPlayer(Player(Index),0,0,5,"Player " + GetSpielerFarbe(GetTriggerPlayer()) + " has chosen " + udg_zz_VotingAuswahl[S2I(GetEventPlayerChatString()) - 1] + ".")
call UpdateAdvancedLeaderboard(udg_zz_VotingBoard[Index],bj_SORTTYPE_SORTBYVALUE,false,udg_zz_Stimmen[0],udg_zz_Stimmen[1],udg_zz_Stimmen[2],udg_zz_Stimmen[3],udg_zz_Stimmen[4],udg_zz_Stimmen[5],udg_zz_Stimmen[6],udg_zz_Stimmen[7],udg_zz_Stimmen[8],udg_zz_Stimmen[9],udg_zz_Stimmen[10],udg_zz_Stimmen[11],udg_zz_Stimmen[12],udg_zz_Stimmen[13],udg_zz_Stimmen[14])
exitwhen Index == 11
set Index = Index + 1
endloop
endif
else
call DisplayTimedTextToPlayer(GetTriggerPlayer(),0,0,5,"Cheater!")
endif
endfunction
function Voting takes string Frage, real Zeitlimit, boolean Geheim, string Ergebnis, string M1, string F1, string M2, string F2, string M3, string F3, string M4, string F4, string M5, string F5, string M6, string F6, string M7, string F7, string M8, string F8, string M9, string F9, string M10, string F10, string M11, string F11, string M12, string F12 returns nothing
local integer Anzahl = 0
local integer Index = 0
local string array Nachricht
local integer NIndex = 0
local timer T = CreateTimer()
local integer Zaehler = 0
loop
set udg_zz_Stimmen[Index] = 0
set udg_zz_StimmeAbgegeben[Index] = false
set udg_zz_VotingAuswahl[Index] = ""
exitwhen Index == 11
set Index = Index + 1
endloop
set udg_zz_VotingAuswahl[12] = ""
set udg_zz_VotingAuswahl[13] = ""
set udg_zz_VotingAuswahl[14] = ""
set udg_zz_VotingGeheim = Geheim
set udg_zz_AnzahlVoter = GetAnzahlSpieler()
set udg_zz_StimmenAbgegeben = 0
set Nachricht[NIndex] = Frage
set NIndex = NIndex + 1
set Index = 0
set Index = AddAuswahl(Index,M1,F1)
set Index = AddAuswahl(Index,M2,F2)
set Index = AddAuswahl(Index,M3,F3)
set Index = AddAuswahl(Index,M4,F4)
set Index = AddAuswahl(Index,M5,F5)
set Index = AddAuswahl(Index,M6,F6)
set Index = AddAuswahl(Index,M7,F7)
set Index = AddAuswahl(Index,M8,F8)
set Index = AddAuswahl(Index,M9,F9)
set Index = AddAuswahl(Index,M10,F10)
set Index = AddAuswahl(Index,M11,F11)
set Index = AddAuswahl(Index,M12,F12)
set Index = 0
loop
if udg_zz_VotingAuswahl[Index] != "" then
set Anzahl = Anzahl + 1
set Nachricht[NIndex] = I2S(Anzahl) + ". " + udg_zz_VotingAuswahl[Index]
set NIndex = NIndex + 1
endif
exitwhen Index == 11
set Index = Index + 1
endloop
set Nachricht[NIndex] = "Please vote now by typing in the appropriate Number!"
set Index = 0
set Zaehler = 0
loop
loop
call DisplayTimedTextToPlayer(Player(Index),0,0,Zeitlimit,Nachricht[Zaehler])
exitwhen Zaehler == NIndex
set Zaehler = Zaehler + 1
endloop
set Zaehler = 0
exitwhen Index == 11
set Index = Index + 1
endloop
set T = TimerMitFenster("|cffffffffRemaining Time|r","ffffff",Zeitlimit,false,function VotingTimerWeg,true)
set udg_zz_VotingTimer = GetDialogOfTimer(T)
set udg_zz_StimmenAbgabe = CreateTrigger()
set Index = 1
set Zaehler = 0
loop
if GetPlayerSlotState(Player(Zaehler)) == PLAYER_SLOT_STATE_PLAYING and GetPlayerController(Player(Zaehler)) == MAP_CONTROL_USER and IsPlayerObserver(Player(Zaehler)) == false then
loop
call TriggerRegisterPlayerChatEvent(udg_zz_StimmenAbgabe,Player(Zaehler),I2S(Index),true)
exitwhen Index == Anzahl
set Index = Index + 1
endloop
set Index = 1
endif
exitwhen Zaehler == 11
set Zaehler = Zaehler + 1
endloop
call TriggerAddAction(udg_zz_StimmenAbgabe,function Stimmenauswertung)
set Index = 0
loop
set udg_zz_VotingBoard[Index] = AdvancedLeaderboard(bj_FORCE_PLAYER[Index],"Current Results",false,false,bj_SORTTYPE_SORTBYVALUE,false,udg_zz_VotingAuswahl[0],udg_zz_Stimmen[0],udg_zz_VotingAuswahl[1],udg_zz_Stimmen[1],udg_zz_VotingAuswahl[2],udg_zz_Stimmen[2],udg_zz_VotingAuswahl[3],udg_zz_Stimmen[3],udg_zz_VotingAuswahl[4],udg_zz_Stimmen[4],udg_zz_VotingAuswahl[5],udg_zz_Stimmen[5],false)
call AdvancedLeaderboardAddPlayers(udg_zz_VotingBoard[Index],false,false,bj_SORTTYPE_SORTBYVALUE,false,udg_zz_VotingAuswahl[6],udg_zz_Stimmen[6],udg_zz_VotingAuswahl[7],udg_zz_Stimmen[7],udg_zz_VotingAuswahl[8],udg_zz_Stimmen[8],udg_zz_VotingAuswahl[9],udg_zz_Stimmen[9],udg_zz_VotingAuswahl[10],udg_zz_Stimmen[10],udg_zz_VotingAuswahl[11],udg_zz_Stimmen[11],udg_zz_VotingAuswahl[12],udg_zz_Stimmen[12],udg_zz_VotingAuswahl[13],udg_zz_Stimmen[13],udg_zz_VotingAuswahl[14],udg_zz_Stimmen[14])
exitwhen Index == 11
set Index = Index + 1
endloop
set udg_zz_VotingErgebnis = Ergebnis
endfunction
function MJToPassivePlayer takes nothing returns nothing
call SetUnitOwner(GetEnumUnit(),Player(PLAYER_NEUTRAL_PASSIVE),false)
endfunction
function MJAddToGroup takes nothing returns nothing
local integer id = udg_zz_MJPlayerPointer
if GetOwningPlayer(GetEnumUnit()) == Player(id) then
call GroupAddUnit(udg_zz_MJSelected[id],GetEnumUnit())
endif
endfunction
function GetWaitSoundSmallerThanThree takes real Zeit returns sound
if Zeit == 1 then
return udg_zz_Empty1
elseif Zeit == 1.5 then
return udg_zz_Empty1p5
elseif Zeit == 2 then
return udg_zz_Empty2
elseif Zeit == 2.5 then
return udg_zz_Empty2p5
endif
return udg_zz_Empty2
endfunction
function GetWaitSoundSmallerThanElf takes real Zeit returns sound
if Zeit == 3 then
return udg_zz_Empty3
elseif Zeit == 4 then
return udg_zz_Empty4
elseif Zeit == 5 then
return udg_zz_Empty5
elseif Zeit == 6 then
return udg_zz_Empty6
elseif Zeit == 7 then
return udg_zz_Empty7
elseif Zeit == 8 then
return udg_zz_Empty8
elseif Zeit == 9 then
return udg_zz_Empty9
elseif Zeit == 10 then
return udg_zz_Empty10
elseif Zeit == 11 then
return udg_zz_Empty11
endif
return udg_zz_Empty8
endfunction
function GetWaitSoundSmallerThanThirty takes real Zeit returns sound
if Zeit == 12 then
return udg_zz_Empty12
elseif Zeit == 14 then
return udg_zz_Empty14
elseif Zeit == 16 then
return udg_zz_Empty16
elseif Zeit == 18 then
return udg_zz_Empty18
elseif Zeit == 20 then
return udg_zz_Empty20
elseif Zeit == 22 then
return udg_zz_Empty22
elseif Zeit == 24 then
return udg_zz_Empty24
elseif Zeit == 26 then
return udg_zz_Empty26
elseif Zeit == 28 then
return udg_zz_Empty28
elseif Zeit == 30 then
return udg_zz_Empty30
endif
return udg_zz_Empty20
endfunction
function GetAppropriateWaitSound takes real Zeit returns sound
local sound Dauer
local real Mod = 0
if Zeit < 0.75 then
return udg_zz_Empty0p5
elseif Zeit >= 0.75 and Zeit < 2.75 then
set Mod = ModuloReal(Zeit,0.5)
if Mod < 0.25 then
set Zeit = Zeit - Mod
else
set Zeit = Zeit - Mod + 0.5
endif
return GetWaitSoundSmallerThanThree(Zeit)
elseif Zeit >= 2.75 and Zeit < 11 then
set Mod = ModuloReal(Zeit,1)
if Mod < 0.5 then
set Zeit = Zeit - Mod
else
set Zeit = Zeit - Mod + 1
endif
return GetWaitSoundSmallerThanElf(Zeit)
elseif Zeit >= 11 and Zeit <= 30 then
set Mod = ModuloReal(Zeit,2)
if Mod < 1 then
set Zeit = Zeit - Mod
else
set Zeit = Zeit - Mod + 2
endif
return GetWaitSoundSmallerThanThirty(Zeit)
endif
return udg_zz_Empty32
endfunction
function AbbrechbareTransmission takes player P, string Name, unit Sprecher, real Zeit, string Text returns nothing
local integer Index = 1
local force Zielgruppe = GetPlayersAll()
local sound Dauer
local integer id = GetPlayerId(P)
set Dauer = GetAppropriateWaitSound(Zeit)
call TransmissionFromUnitWithNameBJ(Zielgruppe,Sprecher,Name,Dauer,Text,0,0,false)
set udg_zz_ATLastSound[id] = GetLastPlayedSound()
set udg_zz_ATToBeSkipped[id] = true
call WaitForSoundBJ(udg_zz_ATLastSound[id],0.00)
set udg_zz_ATToBeSkipped[id] = false
set Zielgruppe = null
endfunction
function InitMultipleChoiceSystem takes player P returns nothing
local integer Index = 0
local integer id = GetPlayerId(P)
if udg_zz_MJTrig1[id] != null then
call DestroyTrigger(udg_zz_MJTrig1[id])
set udg_zz_MJTrig1[id] = null
endif
if udg_zz_MJTrig2[id] != null then
call DestroyTrigger(udg_zz_MJTrig2[id])
set udg_zz_MJTrig2[id] = null
endif
set udg_zz_MJTrig1[id] = CreateTrigger()
set udg_zz_MJTrig2[id] = CreateTrigger()
loop
call CreateNUnitsAtLoc(1,'Hmkg',Player(PLAYER_NEUTRAL_PASSIVE),Location(0,0),0)
set udg_zz_MJAuswahleinheit[id * 6 + Index] = GetLastCreatedUnit()
set udg_zz_MJAuswahl[id * 6 + Index] = false
call SetUnitScalePercent(udg_zz_MJAuswahleinheit[id * 6 + Index],1,1,1)
call ShowUnitHide(udg_zz_MJAuswahleinheit[id * 6 + Index])
exitwhen Index == 4
set Index = Index + 1
endloop
set udg_zz_MJAuswahl[id * 6 + 5] = false
call TriggerRegisterPlayerSelectionEventBJ(udg_zz_MJTrig1[id],P,true)
call TriggerAddCondition(udg_zz_MJTrig1[id],Condition(function MJSelection_Conditions))
call TriggerAddAction(udg_zz_MJTrig1[id],function MJSelection_Actions)
call TriggerRegisterPlayerEventEndCinematic(udg_zz_MJTrig2[id],P)
call TriggerAddAction(udg_zz_MJTrig2[id],function MJSkip_Actions)
endfunction
function ChoiceDialog takes player Zielspieler, string Name, string Auswahl1, string Auswahl2, string Auswahl3, string Auswahl4, string Auswahl5, unit Sprecher, real Zeit, real Antwortzeit returns integer
local integer Index = 1
local integer Ergebnis
local location array Startort
local force Zielgruppe = GetPlayersAll()
local integer Anzahl = 5
local sound Dauer
local string Auswahl = "1. " + Auswahl1 + "|n2. " + Auswahl2
local unit Sichteinheit = GroupPickRandomUnit(GetUnitsOfPlayerAll(Zielspieler))
local group Helden = CreateGroup()
local unit Erste
local integer id = GetPlayerId(Zielspieler)
call InitMultipleChoiceSystem(Zielspieler)
set udg_zz_MJSelected[id] = CreateGroup()
set udg_zz_MJPlayerPointer = id
call ForGroup(GetUnitsSelectedAll(Zielspieler),function MJAddToGroup)
if Auswahl5 == "" then
set Anzahl = Anzahl - 1
if Auswahl4 == "" then
set Anzahl = Anzahl - 1
if Auswahl3 == "" then
set Anzahl = Anzahl -1
else
set Auswahl = Auswahl + "|n3. " + Auswahl3
endif
else
set Auswahl = Auswahl + "|n3. " + Auswahl3 + "|n4. " + Auswahl4
endif
else
set Auswahl = Auswahl + "|n3. " + Auswahl3 + "|n4. " + Auswahl4 + "|n5. " + Auswahl5
endif
set Dauer = GetAppropriateWaitSound(Zeit)
loop
set Startort[Index - 1] = GetUnitLoc(udg_zz_MJAuswahleinheit[id * 6 + Index - 1])
exitwhen Index == Anzahl
set Index = Index + 1
endloop
set Index = 1
call SyncSelections()
call GroupEnumUnitsOfPlayer(Helden,Zielspieler,Filter(function MJIstHeld))
call ForGroup(Helden,function MJToPassivePlayer)
loop
call SetUnitPositionLoc(udg_zz_MJAuswahleinheit[id * 6 + Index - 1],GetUnitLoc(Sichteinheit))
call SetUnitOwner(udg_zz_MJAuswahleinheit[id * 6 + Index - 1],Zielspieler,true)
call ShowUnitShow(udg_zz_MJAuswahleinheit[id * 6 + Index - 1])
exitwhen Index == Anzahl
set Index = Index + 1
endloop
call ClearSelectionForPlayer(Zielspieler)
call SetUserControlForceOn(Zielgruppe)
set udg_zz_MJAuswahl[id * 6] = true
call TransmissionFromUnitWithNameBJ(Zielgruppe,Sprecher,Name,Dauer,Auswahl,0,0,false)
set udg_zz_MJLastSound[id] = GetLastPlayedSound()
call WaitForSoundBJ(udg_zz_MJLastSound[id],0.00)
set Index = 1
loop
call SetUnitOwner(udg_zz_MJAuswahleinheit[id * 6 + Index - 1],Player(PLAYER_NEUTRAL_PASSIVE),false)
call SetUnitPositionLoc(udg_zz_MJAuswahleinheit[id * 6 + Index - 1],Startort[Index - 1])
call RemoveLocation(Startort[Index - 1])
set Startort[Index - 1] = null
call ShowUnitHide(udg_zz_MJAuswahleinheit[id * 6 + Index - 1])
exitwhen Index == Anzahl
set Index = Index + 1
endloop
loop
set Erste = FirstOfGroup(Helden)
exitwhen Erste == null
call SetUnitOwner(Erste,Zielspieler,true)
call GroupRemoveUnit(Helden,Erste)
endloop
call DestroyGroup(Helden)
set Helden = null
call SetUserControlForceOff(Zielgruppe)
set Zielgruppe = null
set udg_zz_MJAuswahl[id * 6] = false
if udg_zz_MJAuswahl[id * 6 + 5] == true then
set Auswahl = Auswahl5
set Ergebnis = 5
elseif udg_zz_MJAuswahl[id * 6 + 4] == true then
set Auswahl = Auswahl4
set Ergebnis = 4
elseif udg_zz_MJAuswahl[id * 6 + 3] == true then
set Auswahl = Auswahl3
set Ergebnis = 3
elseif udg_zz_MJAuswahl[id * 6 + 2] == true then
set Auswahl = Auswahl2
set Ergebnis = 2
else
set Auswahl = Auswahl1
set Ergebnis = 1
endif
call AbbrechbareTransmission(Zielspieler,Name,Sprecher,Antwortzeit,Auswahl)
set Index = 1
loop
set udg_zz_MJAuswahl[id * 6 + Index] = false
exitwhen Index == Anzahl
set Index = Index + 1
endloop
set udg_zz_LastMultipleChoice[id] = Ergebnis
set Index = 0
loop
call RemoveUnit(udg_zz_MJAuswahleinheit[id * 6 + Index])
exitwhen Index == 4
set Index = Index + 1
endloop
call DestroyTrigger(udg_zz_MJTrig1[id])
set udg_zz_MJTrig1[id] = null
call DestroyTrigger(udg_zz_MJTrig2[id])
set udg_zz_MJTrig2[id] = null
return Ergebnis
endfunction
function GetLastMultipleChoiceBJ takes player P returns integer
return udg_zz_LastMultipleChoice[GetPlayerId(P)]
endfunction
function IstUnfertig takes unit Einheit returns boolean
local integer Index = 0
loop
if udg_zz_UnfertigeGebaeude[Index] == Einheit then
return true
endif
exitwhen Index == udg_zz_UnfertigeGebIndex
set Index = Index + 1
endloop
return false
endfunction
function WirdAusgebaut takes unit Einheit returns boolean
local integer Index = 0
loop
if udg_zz_UnfertigeUpgrades[Index] == Einheit then
return true
endif
exitwhen Index == udg_zz_UnfertigeUpgradesIndex
set Index = Index + 1
endloop
return false
endfunction
function IstErweckt takes unit Einheit returns boolean
local integer Index = 0
loop
if udg_zz_ErweckteKreaturen[Index] == Einheit then
return true
endif
exitwhen Index == udg_zz_ErweckteIndex
set Index = Index + 1
endloop
return false
endfunction
function IstTransporter takes nothing returns boolean
if GetUnitTypeId(GetFilterUnit()) == 'otrb' or GetUnitTypeId(GetFilterUnit()) == 'nzep' or GetUnitTypeId(GetFilterUnit()) == 'egol' then
return true
endif
return false
endfunction
function SetItemIndex takes nothing returns integer
set udg_zz_ItemIndex = udg_zz_ItemIndex + 1
return udg_zz_ItemIndex
endfunction
function InArrayGebenItem takes item Hinzu returns nothing
set udg_zz_AllItems[SetItemIndex()] = Hinzu
endfunction
function GetUniqueGegenstandsnummer takes item Gegenstand returns integer
local integer Index = 1
local integer Id = udg_zz_ItemIndex + 1
loop
exitwhen Index > udg_zz_ItemIndex
if udg_zz_AllItems[Index] == Gegenstand then
set Id = Index
set Index = udg_zz_ItemIndex + 1
else
set Index = Index + 1
endif
endloop
if Id == udg_zz_ItemIndex + 1 then
call InArrayGebenItem(Gegenstand)
endif
return Id
endfunction
function RegisterItem takes item Geg returns nothing
call GetUniqueGegenstandsnummer(Geg)
endfunction
function RegItemInArray takes nothing returns nothing
call RegisterItem(GetEnumItem())
endfunction
function CancelAIOrders takes integer Type, player P returns nothing
call CommandAI(P,Type,0)
endfunction
function AIBuildOrders takes player P, integer Nr, integer Type returns nothing
call CommandAI(P,Type,Nr)
endfunction
function RestrictAI takes player P, integer Type returns nothing
call CommandAI(P,Type,0)
endfunction
function SetAIMode takes player P, integer Type returns nothing
call CommandAI(P,Type,0)
endfunction
function AIAttackSelected takes player P, player Target returns nothing
call CommandAI(P,14,GetPlayerId(Target))
endfunction
function AIAttackPoint takes player P, location Point returns nothing
call CommandAI(P,R2I(GetLocationX(Point)),R2I(GetLocationY(Point)))
call CommandAI(P,13,0)
endfunction
function AIAttackPlayer takes player P, player Target returns nothing
call CommandAI(P,12,GetPlayerId(Target))
endfunction
function AIChangeStrategy takes player P, integer Strat returns nothing
call CommandAI(P,70,Strat)
endfunction
function SmartCamMove takes nothing returns nothing
local real X = udg_zz_CameraSettingVal[0] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[1] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[2] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[3]
local real Y = udg_zz_CameraSettingVal[4] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[5] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[6] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[7]
local real H = udg_zz_CameraSettingVal[8] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[9] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[10] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[11]
local real A = udg_zz_CameraSettingVal[12] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[13] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[14] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[15]
local real R = udg_zz_CameraSettingVal[16] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[17] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[18] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[19]
local real Rot = udg_zz_CameraSettingVal[20] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[21] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[22] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[23]
local real D = udg_zz_CameraSettingVal[24] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[25] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[26] * udg_zz_CameraSettingVal[28] + udg_zz_CameraSettingVal[27]
call  PanCameraToTimedLocForPlayer(GetEnumPlayer(),OffsetLocation(GetRectCenter(GetPlayableMapRect()),X,Y),0)
call  SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_ANGLE_OF_ATTACK,A,0)
call  SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_ZOFFSET,H,0)
call  SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_ROLL,R,0)
call  SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_ROTATION,Rot,0)
call  SetCameraFieldForPlayer(GetEnumPlayer(),CAMERA_FIELD_TARGET_DISTANCE,D,0)
endfunction
function CamPeriodic takes nothing returns nothing
local integer Index = 0
local integer Indexb = 0
call ForForce(GetPlayersAll(),function SmartCamMove)
set udg_zz_CameraSettingVal[28] = udg_zz_CameraSettingVal[28] + (1.00 / (udg_zz_CameraSettingVal[29] * 100.00))
if udg_zz_CameraSettingVal[28] > 1 then
if udg_zz_CameraSettingVal[8191] >= udg_zz_CameraSettingVal[8190] then
call DestroyTrigger(GetTriggeringTrigger())
else
set Index = 0
loop
exitwhen Index > 29
set Indexb = 0
loop
exitwhen Indexb >= udg_zz_CameraSettingVal[8190] - udg_zz_CameraSettingVal[8191]
set udg_zz_CameraSettingVal[(Indexb * 30) + Index] = udg_zz_CameraSettingVal[((Indexb + 1) * 30) + Index]
set Indexb = Indexb + 1
endloop
set Index = Index + 1
endloop
set udg_zz_CameraSettingVal[8191] = udg_zz_CameraSettingVal[8191] + 1
endif
endif
endfunction
function ReturnAVal takes real X0, real X1, real X2, real X3 returns real
return X3 - (3 * X2) + (3 * X1) - X0
endfunction
function ReturnBVal takes real X0, real X1, real X2 returns real
return (3 * X2) - (6 * X1) + (3 * X0)
endfunction
function ReturnCVal takes real X0, real X1 returns real
return (3 * X1) - (3 * X0)
endfunction
function SaveBaseValues takes real X0, real X1, real X2, real X3, integer Index returns nothing
set udg_zz_CameraSettingVal[Index] = ReturnAVal(X0,X1,X2,X3)
set udg_zz_CameraSettingVal[Index + 1] = ReturnBVal(X0,X1,X2)
set udg_zz_CameraSettingVal[Index + 2] = ReturnCVal(X0,X1)
set udg_zz_CameraSettingVal[Index + 3] = X0
endfunction
function DoTheCameraThingyStuff takes camerasetup Start, camerasetup Next, camerasetup Middle, camerasetup End, real Time, boolean Continue returns nothing
local camerasetup Prev = udg_zz_PrevCam[0]
local integer Ptr = 0
local real X
local real Y
local real H
local real A0
local real A1
local real A2
local real A3
local real R0
local real R1
local real R2
local real R3
local real Rot0
local real Rot1
local real Rot2
local real Rot3
local real D
local trigger Trig = CreateTrigger()
set Time = Time * 3
set A0 = CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,Start)
set R0 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Start)
set Rot0 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Start)
if Continue then
set X = 2 * CameraSetupGetDestPositionX(Start) - CameraSetupGetDestPositionX(Prev)
set Y = 2 * CameraSetupGetDestPositionY(Start) - CameraSetupGetDestPositionY(Prev)
set H = 2 * CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Start) - CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Prev)
set A1 = 2 * CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,Start) - CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,Prev)
set R1 = 2 * CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Start) - CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev)
set Rot1 = 2 * CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Start) - CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Prev)
set D = 2 * CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Start) - CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Prev)
if ((A1 > 360.00)) then
set A1 = (A1 - 360.00)
endif
if ((A1 < 0.00)) then
set A1 = (A1 + 360.00)
endif
if ((CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev) >= 180.00) and (CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev) < 360.00)) then
if ((CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Prev) - R0) > 180.00) then
set R1 = (((360.00 - CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev)) + R0) + R0)
endif
endif
if ((R0 >= 180.00) and (R0 < 360.00)) then
if ((R0 - CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev)) > 180.00) then
set R1 = (R0 - (1.00 * ((CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Prev) + 360.00) - R0)))
endif
endif
if ((Rot1 > 360.00)) then
set Rot1 = (Rot1 - 360.00)
endif
if ((Rot1 < 0.00)) then
set Rot1 = (Rot1 + 360.00)
endif
else
set X = CameraSetupGetDestPositionX(Next)
set Y = CameraSetupGetDestPositionY(Next)
set H = CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Next)
set A1 = CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,Next)
set R1 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Next)
set Rot1 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Next)
set D = CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Next)
endif
set A2 = CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,Middle)
set A3 = CameraSetupGetFieldSwap(CAMERA_FIELD_ANGLE_OF_ATTACK,End)
set R2 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,Middle)
set R3 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROLL,End)
set Rot2 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,Middle)
set Rot3 = CameraSetupGetFieldSwap(CAMERA_FIELD_ROTATION,End)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = ( A0 + 360.00)
endif
if ((A1 - A2) >= 180.00) then
set A2 = (A2 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
endif
if ((A2 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
endif
if ((A2 - A3) >= 180.00) then
set A3 = (A3 + 360.00 )
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
if ((A1 - A2) >= 180.00) then
set A2 = (A2 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
endif
if ((A2 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
endif
endif
if ((A3 - A2) >= 180.00) then
set A2 = (A2 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
if ((A1 - A2)) >= 180.00 then
set A2 = (A2 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00 ) then
set A0 = (A0 + 360.00)
endif
endif
if ((A2 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
if ((A0 - A1) >= 180.00) then
set A1 = (A1 + 360.00)
endif
if ((A1 - A0) >= 180.00) then
set A0 = (A0 + 360.00)
endif
endif
endif
if ((R0 >= 180.00) and (R0 <= 360.00)) then
if ((R0 - R1) > 180.00) then
set R1 = (R1 + 360.00)
endif
if ((R0 - R2) > 180.00) then
set R2 = (R2 + 360.00)
endif
if ((R0 - R3) > 180.00) then
set R3 = (R3 + 360.00)
endif
endif
if ((R1 >= 180.00) and (R1 <= 360.00)) then
if ((R1 - R0) > 180.00) then
set R0 = (R0 + 360.00)
endif
if ((R1 - R2) > 180.00) then
set R2 = (R2 + 360.00)
endif
if ((R1 - R3) > 180.00) then
set R3 = (R3 + 360.00)
endif
endif
if ((R2 >= 180.00) and (R2 <= 360.00)) then
if ((R2 - R0) > 180.00) then
set R0 = (R0 + 360.00)
endif
if ((R2 - R1) > 180.00) then
set R1 = (R1 + 360.00)
endif
if ((R2 - R3) > 180.00) then
set R3 = (R3 + 360.00)
endif
endif
if ((R3 >= 180.00) and (R3 <= 360.00)) then
if ((R3 - R0) > 180.00) then
set R0 = (R0 + 360.00)
endif
if ((R3 - R1) > 180.00) then
set R1 = (R1 + 360.00)
endif
if ((R3 - R2) > 180.00) then
set R2 = (R2 + 360.00)
endif
endif
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
if ((Rot1 - Rot2) >= 180.00) then
set Rot2 = (Rot2 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
if ((Rot2 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
if ((Rot2 - Rot3) >= 180.00) then
set Rot3 = (Rot3 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
if ((Rot1 - Rot2) >= 180.00) then
set Rot2 = (Rot2 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
if ((Rot2 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
endif
if ((Rot3 - Rot2) >= 180.00) then
set Rot2 = (Rot2 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
if ((Rot1 - Rot2) >= 180.00) then
set Rot2 = (Rot2 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
if ((Rot2 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
if ((Rot0 - Rot1) >= 180.00) then
set Rot1 = (Rot1 + 360.00)
endif
if ((Rot1 - Rot0) >= 180.00) then
set Rot0 = (Rot0 + 360.00)
endif
endif
endif
if Continue then
set udg_zz_CameraSettingVal[8190] = udg_zz_CameraSettingVal[8190] + 1
set Ptr = R2I(udg_zz_CameraSettingVal[8190] - udg_zz_CameraSettingVal[8191])
set udg_zz_CameraSettingVal[(Ptr * 30) + 29] = Time
set udg_zz_CameraSettingVal[(Ptr * 30) + 28] = 0
call SaveBaseValues(CameraSetupGetDestPositionX(Start),X,CameraSetupGetDestPositionX(Middle),CameraSetupGetDestPositionX(End),(Ptr * 30))
call SaveBaseValues(CameraSetupGetDestPositionY(Start),Y,CameraSetupGetDestPositionY(Middle),CameraSetupGetDestPositionY(End),(Ptr * 30) + 4)
call SaveBaseValues(CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Start),H,CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Middle),CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,End),(Ptr * 30) + 8)
call SaveBaseValues(A0,A1,A2,A3,(Ptr * 30) + 12)
call SaveBaseValues(R0,R1,R2,R3,(Ptr * 30) + 16)
call SaveBaseValues(Rot0,Rot1,Rot2,Rot3,(Ptr * 30) + 20)
call SaveBaseValues(CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Start),D,CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Middle),CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,End),(Ptr * 30) + 24)
set udg_zz_PrevCam[0] = Middle
set udg_zz_PrevCam[1] = End
else
set udg_zz_CameraSettingVal[29] = Time
set udg_zz_CameraSettingVal[28] = 0
call SaveBaseValues(CameraSetupGetDestPositionX(Start),X,CameraSetupGetDestPositionX(Middle),CameraSetupGetDestPositionX(End),0)
call SaveBaseValues(CameraSetupGetDestPositionY(Start),Y,CameraSetupGetDestPositionY(Middle),CameraSetupGetDestPositionY(End),4)
call SaveBaseValues(CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Start),H,CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,Middle),CameraSetupGetFieldSwap(CAMERA_FIELD_ZOFFSET,End),8)
call SaveBaseValues(A0,A1,A2,A3,12)
call SaveBaseValues(R0,R1,R2,R3,16)
call SaveBaseValues(Rot0,Rot1,Rot2,Rot3,20)
call SaveBaseValues(CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Start),D,CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,Middle),CameraSetupGetFieldSwap(CAMERA_FIELD_TARGET_DISTANCE,End),24)
set udg_zz_PrevCam[0] = Middle
set udg_zz_PrevCam[1] = End
set udg_zz_CameraSettingVal[8190] = 1
set udg_zz_CameraSettingVal[8191] = 1
call TriggerRegisterTimerEventPeriodic(Trig,0.01)
call TriggerAddAction(Trig,function CamPeriodic)
call TriggerExecute(Trig)
endif
endfunction
function StartCameraMovement takes camerasetup Start, camerasetup Middle, camerasetup End, real Time returns nothing
call  DoTheCameraThingyStuff(Start,Start,Middle,End,Time / 3,false)
endfunction
function ContinueCameraMovement takes camerasetup Next, camerasetup Middle, camerasetup End, real Time returns nothing
call  DoTheCameraThingyStuff(udg_zz_PrevCam[1],Next,Middle,End,Time / 3,true)
endfunction
function EndCameraMovement takes camerasetup Next, camerasetup End, real Time returns nothing
call  DoTheCameraThingyStuff(udg_zz_PrevCam[1],Next,End,End,Time / 3,true)
endfunction
function Ucase takes string Ustring returns string
local integer Length = 1
local string Char = ""
local string Rest = ""
loop
exitwhen((SubStringBJ(Ustring,1,Length) == Ustring))
set Length = Length + 1
endloop
set Char = SubStringBJ(Ustring,1,1)
set Rest = SubStringBJ(Ustring,2,Length)
set Char = Uppercase(Char)
return Char + Rest
endfunction
function Parser takes string ChatMsg returns nothing
local integer Last = 0
local integer A = 1
local integer I = 0
local integer Length = 1
loop
exitwhen((SubStringBJ(ChatMsg,1,Length) == ChatMsg))
set Length = Length + 1
endloop
loop
if(SubStringBJ(ChatMsg,A,A) == " ") then
set udg_zz_parsed_command[I] = Ucase(SubStringBJ(ChatMsg, (Last + 1), (A - 1)))
set Last = A
set I = I + 1
elseif(A == Length) then
set udg_zz_parsed_command[I] = Ucase(SubStringBJ(ChatMsg, (Last + 1), A))
set I = I + 1
endif
set A = A + 1
exitwhen(A>Length)
endloop
loop
exitwhen I > 6
set udg_zz_parsed_command[I] = ""
set I = I + 1
endloop
endfunction
function ColorText takes player CPlayer returns string
local string Colored = ""
local playercolor PColor = GetPlayerColor(CPlayer)
if (PColor == PLAYER_COLOR_RED) then
set Colored = "Red"
elseif (PColor == PLAYER_COLOR_BLUE) then
set Colored = "Blue"
elseif (PColor == PLAYER_COLOR_CYAN) then
set Colored = "Cyan"
elseif (PColor == PLAYER_COLOR_PURPLE) then
set Colored = "Purple"
elseif (PColor == PLAYER_COLOR_YELLOW) then
set Colored = "Yellow"
elseif (PColor == PLAYER_COLOR_ORANGE) then
set Colored = "Orange"
elseif (PColor == PLAYER_COLOR_GREEN) then
set Colored = "Green"
elseif (PColor == PLAYER_COLOR_PINK) then
set Colored = "Pink"
elseif (PColor == PLAYER_COLOR_LIGHT_GRAY) then
set Colored = "Light Gray"
elseif (PColor == PLAYER_COLOR_LIGHT_BLUE) then
set Colored = "Light Blue"
elseif (PColor == PLAYER_COLOR_AQUA) then
set Colored = "Aqua"
elseif (PColor == PLAYER_COLOR_BROWN) then
set Colored = "Brown"
endif
return Colored
endfunction
function ColorPlayer takes string CompC returns playercolor
local playercolor Colored = null
if (CompC == "Red") then
set Colored = PLAYER_COLOR_RED
elseif (CompC == "Blue") then
set Colored = PLAYER_COLOR_BLUE
elseif (CompC == "Cyan") then
set Colored = PLAYER_COLOR_CYAN
elseif (CompC == "Purple") then
set Colored = PLAYER_COLOR_PURPLE
elseif (CompC == "Yellow") then
set Colored = PLAYER_COLOR_YELLOW
elseif (CompC == "Orange") then
set Colored = PLAYER_COLOR_ORANGE
elseif (CompC == "Green") then
set Colored = PLAYER_COLOR_GREEN
elseif (CompC == "Pink") then
set Colored = PLAYER_COLOR_PINK
elseif (CompC == "Light Gray") then
set Colored = PLAYER_COLOR_LIGHT_GRAY
elseif (CompC == "Light Blue") then
set Colored = PLAYER_COLOR_LIGHT_BLUE
elseif (CompC == "Aqua") then
set Colored = PLAYER_COLOR_AQUA
elseif (CompC == "Brown") then
set Colored = PLAYER_COLOR_BROWN
else
set Colored = null
endif
return Colored
endfunction
function cs2s takes string s, playercolor c returns string
if c == PLAYER_COLOR_RED then
return "|c00ff0000"+s+"|r"
elseif c == PLAYER_COLOR_BLUE then
return "|c000000ff"+s+"|r"
elseif c == PLAYER_COLOR_CYAN then
return "|c0000ffff"+s+"|r"
elseif c == PLAYER_COLOR_PURPLE then
return "|c00660099"+s+"|r"
elseif c == PLAYER_COLOR_YELLOW then
return "|c00ffff00"+s+"|r"
elseif c == PLAYER_COLOR_ORANGE then
return "|c00ff9933"+s+"|r"
elseif c == PLAYER_COLOR_GREEN then
return "|c0000ff00"+s+"|r"
elseif c == PLAYER_COLOR_PINK then
return "|c00ff00ff"+s+"|r"
elseif c == PLAYER_COLOR_LIGHT_GRAY then
return "|c00dddddd"+s+"|r"
elseif c == PLAYER_COLOR_LIGHT_BLUE then
return "|c0033ccff"+s+"|r"
elseif c == PLAYER_COLOR_AQUA then
return "|c007fffd4"+s+"|r"
else
return "|c00660000"+s+"|r"
endif
endfunction
function c2s takes player p returns string
return cs2s(GetPlayerName(p), GetPlayerColor(p)) + ": "
endfunction
function DisplayToTP takes string msg returns nothing
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 5, msg )
endfunction
function DisplayToPlayer takes player p, string msg returns nothing
call DisplayTimedTextToPlayer(p, 0, 0, 5, msg )
endfunction
function DisplayToAll takes string msg returns nothing
call DisplayTimedTextToPlayer(GetLocalPlayer(), 0, 0, 7, msg )
endfunction
function DisplayFromPlayer takes player p, string msg returns nothing
call DisplayToTP(c2s(p) + msg)
endfunction
function DisplayFromToPlayer takes player sp, player rp, string msg returns nothing
call DisplayToPlayer(rp, c2s(sp) + msg)
endfunction
function DisplayFromDlg takes string msg returns nothing
if msg == "" or udg_zz_commanded_player == Player(14) then
return
endif
if udg_zz_commanding_player != null then
if udg_zz_commanded_player != null then
call DisplayFromToPlayer(udg_zz_commanded_player, udg_zz_commanding_player, msg)
else
call DisplayToPlayer(udg_zz_commanded_player, msg)
endif
else
call DisplayToAll(msg)
endif
endfunction
function SyncInteger takes player sync_p, integer unsynced returns integer
local integer array source_int
local integer array target_int
local unit array sel_unit
local integer i = 1
local integer j = 0
local integer sum = unsynced
local group old_selection = CreateGroup()
local unit u = null
local integer bits_per_selection = 8
local integer selection_num = 2
local integer bits_number = selection_num * bits_per_selection
local timer t = CreateTimer()
if bj_isSinglePlayer then
return unsynced
endif
if sum < 0 then
set source_int[0] = 1
set sum = -sum
else
set source_int[0] = 0
endif
loop
exitwhen i >= bits_number
set source_int[i] = ModuloInteger(sum, 2)
set sum = sum / 2
set i = i + 1
endloop
set i = 0
loop
exitwhen i >= bits_per_selection
set sel_unit[i] = CreateUnitAtLoc( sync_p, 'nshf', GetPlayerStartLocationLoc(sync_p), bj_UNIT_FACING )
set i = i + 1
endloop
call SyncSelections()
call GroupEnumUnitsSelected(old_selection, sync_p, null)
set i = 0
loop
exitwhen i >= selection_num
if GetLocalPlayer() == sync_p then
set j = 0
call ClearSelection()
loop
exitwhen j >= bits_per_selection
if source_int[i*bits_per_selection + j] == 0 then
call SelectUnit(sel_unit[j], false)
else
call SelectUnit(sel_unit[j], true)
endif
set j = j + 1
endloop
endif
call TimerStart(t, 1, false, null)
loop
exitwhen TimerGetRemaining(t) <= 0
call PolledWait(0.5)
endloop
call SyncSelections()
set j = 0
loop
exitwhen j >= bits_per_selection
if IsUnitSelected(sel_unit[j], sync_p) then
set target_int[i*bits_per_selection + j] = 1
else
set target_int[i*bits_per_selection + j] = 0
endif
set j = j + 1
endloop
set i = i + 1
endloop
if GetLocalPlayer() == sync_p then
call ClearSelection()
loop
set u = FirstOfGroup(old_selection)
exitwhen u == null
call SelectUnit(u, true)
call GroupRemoveUnit(old_selection, u)
endloop
call DestroyGroup(old_selection)
set old_selection = null
endif
call SyncSelections()
set i = 0
loop
exitwhen i >= bits_per_selection
call RemoveUnit(sel_unit[i])
set i = i + 1
endloop
set i = bits_number - 1
set sum = 0
loop
exitwhen i < 1
set sum = 2 * sum + target_int[i]
set i = i - 1
endloop
if target_int[0] != 0 then
set sum = -sum
endif
return sum
endfunction
function Convert2Player takes string Comp, boolean all_allowed returns player
local integer j = 0
local playercolor CColor = ColorPlayer(Comp)
if Comp == "All" then
if all_allowed then
return Player(14)
else
call DisplayToTP("ERROR, All is not allowed here")
return null
endif
endif
if (CColor == null) then
if (S2I(Comp) >= 0) and (S2I(Comp) <= 11) then
return Player(S2I(Comp))
else
call DisplayToTP("ERROR, you mistyped the player id")
return null
endif
endif
loop
exitwhen(CColor == GetPlayerColor(Player(j)))
set j = j + 1
if (j > 12) then
call DisplayToTP("ERROR, you mistyped the player Color or Command word.")
return null
endif
endloop
return Player(j)
endfunction
function GetPlayersMatchingCode takes nothing returns boolean
return ( GetPlayerSlotState(GetFilterPlayer()) == PLAYER_SLOT_STATE_PLAYING)
endfunction
function ForForceCode takes nothing returns nothing
call LeaderboardAddItemBJ(GetEnumPlayer(), udg_zz_color_board, GetPlayerName(GetEnumPlayer()), 0)
call LeaderboardSetPlayerItemLabelBJ(GetEnumPlayer(), udg_zz_color_board, ColorText(GetEnumPlayer()))
call LeaderboardSetPlayerItemValueBJ(GetEnumPlayer(), udg_zz_color_board, GetPlayerId(GetEnumPlayer()))
endfunction
function CreateBoard takes nothing returns nothing
local integer j = 0
set udg_zz_color_board =CreateLeaderboardBJ( GetPlayersAll(), "Colorboard" )
call ForForce( GetPlayersMatching(Condition(function GetPlayersMatchingCode)), function ForForceCode )
call LeaderboardDisplay(udg_zz_color_board, false)
endfunction
function ShowBoard takes nothing returns nothing
call LeaderboardDisplay(udg_zz_color_board, not IsLeaderboardDisplayed(udg_zz_color_board))
endfunction
function Helpin takes nothing returns nothing
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "Commander Help")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "Here are the Commands for The Commander")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "ESC")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "-Starts dialog command")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "Cmd: Help")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "-Displays Help")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "Cmd: Board")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "-Displays Colorboard")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "Cmd: Chatter")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 10, "-Turns On/Off the Chat messages your allies will send you.")
call PolledWait( 5.00 )
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Here are the Commands for Ally use")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Trib (Amount) <G or L>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Using this command you can have your computer ally donate resources to you.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Cancel <All, Attack, Build, or Queue>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Cancels either All, Attack, Build or Queued Commands given so far.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Stop")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Stops the current command.")
call PolledWait( 15.00 )
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Here are some more Commands for Ally use")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) No <Attacks, Creep, or Players>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Stops the computer from attacking either Anything, Creeps, or Players.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Build (How Many) <A2A, A2G, G2A, or G2G>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-This will cause the ally to make sure that they have that many of the certain unit type.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Attack <Here, Select, or (Enemy)>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Will cause that ally either to attack/guard the center of your current screen position or Selected Computer.")
call PolledWait( 15.00 )
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Here are the Queue Commands")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Que <Start or Restart>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Starts the Queued Commands or REstarts them.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Que <Pause or Unpause>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Pauses or Unpauses the Queued Commands.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Que Undo")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Removes the last Queued Command.")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "Cmd: (Ally) Que Attack <Here or Select>")
call DisplayTimedTextToPlayer(GetTriggerPlayer(), 0, 0, 15, "-Will Queue the Current Screen Position or Selected Unit, to be started later.")
endfunction
function MapInit takes nothing returns nothing
call CreateBoard()
if udg_zz_command_language == "Deutsch" then
call DisplayToAll("|c0000ffffDiese Karte enthaelt den Commander und AMAI.|r")
call DisplayToAll("|c0000ffffSchreibe 'Cmd: Help', um Hilfe zu erhalten.|r")
call DisplayToAll("|c0000ffffDruecke ESC fuer den Befehlsdialog.|r")
call DisplayToAll("|c0000ffffBesuche www.wc3campaigns.com Foren fuer Updates und mehr|r")
call DisplayToAll("|c0000ffffAMAI homepage ist http://amai.wc3campaigns.com|r")
call DisplayToAll("|c0000ffffAIAndy, Zalamander und DKSlayer|r")
elseif udg_zz_command_language == "Swedish" then
call DisplayToAll("|c0000ffffDenna kartan anvander AMAI.|r")
call DisplayToAll("|c0000ffffSkriv 'Cmd: Help' for att fa hjalp.|r")
call DisplayToAll("|c0000ffffTryck ESC for meny.|r")
call DisplayToAll("|c0000ffffBesok www.wc3campaigns.com forum for uppdateringar|r")
call DisplayToAll("|c0000ffffAMAI hemsida http://amai.wc3campaigns.com|r")
call DisplayToAll("|c0000ffffAIAndy, Zalamander och DKSlayer|r")
elseif udg_zz_command_language == "French" then
call DisplayToAll("|c0000ffffCette carte contient the Commander and AMAI.|r")
call DisplayToAll("|c0000ffffTape 'Cmd: Help' pour obtenir l'aide(help).|r")
call DisplayToAll("|c0000ffffAppuie sur ESC pour la commande de dialogue.|r")
call DisplayToAll("|c0000ffffva sur les forums de www.wc3campaigns.com pour les futures versions et plus|r")
call DisplayToAll("|c0000ffffAMAI sur internet a l'adresse http://amai.wc3campaigns.com|r")
call DisplayToAll("|c0000ffffAIAndy, Zalamander and DKSlayer|r")
else
call DisplayToAll("|c0000ffffThis map contains the Commander and AMAI.|r")
call DisplayToAll("|c0000ffffType 'Cmd: Help' to get Help.|r")
call DisplayToAll("|c0000ffffPress ESC for a dialog of commands.|r")
call DisplayToAll("|c0000ffffGoto www.wc3campaigns.com forums to find updates and more|r")
call DisplayToAll("|c0000ffffThe AMAI homepage is http://amai.wc3campaigns.com|r")
call DisplayToAll("|c0000ffffAIAndy, Zalamander and DKSlayer|r")
endif
endfunction
function TributeGold takes player Commander, player Comp, integer res_amount returns nothing
if GetPlayerState(Comp, PLAYER_STATE_RESOURCE_GOLD) - 200 >= res_amount then
call SetPlayerState(Comp, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(Comp, PLAYER_STATE_RESOURCE_GOLD) - res_amount)
call SetPlayerState(Commander, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(Commander, PLAYER_STATE_RESOURCE_GOLD) + res_amount)
call DisplayFromToPlayer(Comp, Commander, "Tribute of "+ I2S(res_amount) + " Gold is complete.")
else
call DisplayFromToPlayer(Comp, Commander, "Sorry, I don't have enough Gold.")
endif
endfunction
function TributeWood takes player Commander, player Comp, integer res_amount returns nothing
if GetPlayerState(Comp, PLAYER_STATE_RESOURCE_LUMBER) - 200 >= res_amount then
call SetPlayerState(Comp, PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(Comp, PLAYER_STATE_RESOURCE_LUMBER) - res_amount)
call SetPlayerState(Commander, PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(Commander, PLAYER_STATE_RESOURCE_LUMBER) + res_amount)
call DisplayFromToPlayer(Comp, Commander, "Tribute of "+ I2S(res_amount) + " Lumber is complete.")
else
call DisplayFromToPlayer(Comp, Commander, "Sorry, I don't have enough Lumber.")
endif
endfunction
function TributeGoldFromAll takes player Commander, integer res_amount returns nothing
local integer i = 0
loop
exitwhen i >= 12
if IsPlayerAlly(Commander, Player(i)) and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
call TributeGold(Commander, Player(i),res_amount)
endif
set i = i + 1
endloop
endfunction
function TributeWoodFromAll takes player Commander, integer res_amount returns nothing
local integer i = 0
loop
exitwhen i >= 12
if IsPlayerAlly(Commander,Player(i)) and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
call TributeWood(Commander, Player(i),res_amount)
endif
set i = i + 1
endloop
endfunction
function Tribute takes player Commander, player Comp, string LorG, string ResAmount returns nothing
if (LorG == "G") or (LorG == "Gold") then
if Comp == Player(14) then
call TributeGoldFromAll(Commander, S2I(ResAmount))
else
call TributeGold(Commander, Comp, S2I(ResAmount))
endif
elseif (LorG == "L") or (LorG == "Lumber") then
if Comp == Player(14) then
call TributeWoodFromAll(Commander, S2I(ResAmount))
else
call TributeWood(Commander, Comp, S2I(ResAmount))
endif
else
call DisplayToPlayer(Commander, "Sorry, you mistyped your Tribute.")
endif
endfunction
function EndDialog takes nothing returns nothing
set udg_zz_dialog_in_use = false
endfunction
function GetParValue takes integer par returns integer
local player p = null
if par == -1 then
return 0
elseif par == -30 then
return SyncInteger(udg_zz_commanding_player, R2I(GetCameraTargetPositionX()))
elseif par == -31 then
return SyncInteger(udg_zz_commanding_player, R2I(GetCameraTargetPositionY()))
elseif par == -40 then
return GetPlayerId(GetTriggerPlayer())
elseif par < -100 then
set p = Convert2Player(udg_zz_parsed_command[-(par + 100)], false)
if p == null then
return -1000000
else
return GetPlayerId(p)
endif
elseif par < 0 then
return S2I(udg_zz_parsed_command[-par])
else
return par
endif
endfunction
function ExecuteCommand takes player Comp, integer number returns nothing
local integer cn = GetParValue(udg_zz_command_number[number])
local integer par1 = GetParValue(udg_zz_command_par1[number])
local integer par2 = GetParValue(udg_zz_command_par2[number])
local integer par3 = GetParValue(udg_zz_command_par3[number])
if cn == -1000000 or par1 == -1000000 or par2 == -1000000 or par3 == -1000000 then
return
endif
if udg_zz_command_par2[number] != -1 then
call CommandAI(Comp, par2, par3)
endif
if udg_zz_command_number[number] != -1 then
call CommandAI(Comp, cn, par1)
endif
call DisplayFromPlayer(Comp, udg_zz_command_msg[number])
endfunction
function ExecuteCommandForAll takes integer number returns nothing
local integer i = 0
loop
exitwhen i >= 12
if (IsPlayerAlly(GetTriggerPlayer(),Player(i)) or (IsPlayerObserver(GetTriggerPlayer()) and udg_zz_observer_god)) and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
call ExecuteCommand(Player(i), number)
endif
set i = i + 1
endloop
endfunction
function GetDlgParValue takes integer par returns integer
if par == -1 then
return 0
elseif par == -30 then
return SyncInteger(udg_zz_commanding_player, R2I(GetCameraTargetPositionX()))
elseif par == -31 then
return SyncInteger(udg_zz_commanding_player, R2I(GetCameraTargetPositionY()))
elseif par == -40 then
return GetPlayerId(udg_zz_commanding_player)
elseif par < -100 then
return udg_zz_current_player_par
elseif par < 0 then
return udg_zz_current_number_par
else
return par
endif
endfunction
function ExecuteDlgCommand takes player Comp, integer number returns nothing
local integer cn = GetDlgParValue(udg_zz_command_number[number])
local integer par1 = GetDlgParValue(udg_zz_command_par1[number])
local integer par2 = GetDlgParValue(udg_zz_command_par2[number])
local integer par3 = GetDlgParValue(udg_zz_command_par3[number])
if udg_zz_command_par2[number] != -1 then
call CommandAI(Comp, par2, par3)
endif
if udg_zz_command_number[number] != -1 then
call CommandAI(Comp, cn, par1)
endif
call DisplayFromDlg(udg_zz_command_msg[number])
endfunction
function ExecuteDlgCommandForAll takes integer number returns nothing
local integer i = 0
loop
exitwhen i >= 12
if (IsPlayerAlly(udg_zz_commanding_player,Player(i)) or (IsPlayerObserver(udg_zz_commanding_player) and udg_zz_observer_god)) and GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
set udg_zz_commanded_player = Player(i)
call ExecuteDlgCommand(Player(i), number)
endif
set i = i + 1
endloop
endfunction
function ExecuteDialogCommand takes player Comp, integer number returns nothing
if udg_zz_commanded_player == Player(14) then
call ExecuteDlgCommandForAll(number)
else
call ExecuteDlgCommand(Comp, number)
endif
call EndDialog()
endfunction
function FindCommand takes nothing returns integer
local integer i = 0
loop
exitwhen i >= udg_zz_command_length
if udg_zz_command_key1[i] == "" or udg_zz_command_key1[i] == udg_zz_parsed_command[2] then
if udg_zz_command_key2[i] == "" or udg_zz_command_key2[i] == udg_zz_parsed_command[3] then
exitwhen udg_zz_command_key3[i] == "" or udg_zz_command_key3[i] == udg_zz_parsed_command[4]
endif
endif
set i = i + 1
endloop
if i >= udg_zz_command_length then
return -1
else
return i
endif
endfunction
function Commander takes nothing returns nothing
local player Comp = null
local string ChatMsg = GetEventPlayerChatString()
local integer cn = 0
call Parser(ChatMsg)
if udg_zz_parsed_command[1] == "Help" then
call Helpin()
return
endif
if udg_zz_parsed_command[1] == "Board" then
call ShowBoard()
return
endif
set Comp = Convert2Player(udg_zz_parsed_command[1], true)
if Comp == null then
call DisplayToTP("You have not specified a valid player.")
return
elseif Comp != Player(14) then
if GetPlayerController(Comp) != MAP_CONTROL_COMPUTER then
call DisplayToTP("You have not specified a computer.")
return
elseif (not IsPlayerAlly(GetTriggerPlayer(), Comp)) and (not (IsPlayerObserver(GetTriggerPlayer()) and udg_zz_observer_god)) then
call DisplayFromPlayer(Comp, udg_zz_chat_no_ally)
return
endif
endif
if udg_zz_parsed_command[2] == "Tribute" or udg_zz_parsed_command[2] == "Trib" then
call Tribute(GetTriggerPlayer(), Comp, udg_zz_parsed_command[4], udg_zz_parsed_command[3])
return
endif
set cn = FindCommand()
if cn < 0 then
call DisplayFromPlayer(Comp, "I do not know that command.")
return
endif
if Comp == Player(14) then
call ExecuteCommandForAll(cn)
else
call ExecuteCommand(Comp, cn)
endif
endfunction
function DialogCommander takes nothing returns nothing
loop
exitwhen not udg_zz_dialog_in_use
call PolledWait(2)
endloop
set udg_zz_dialog_in_use = true
set udg_zz_commanded_player = null
set udg_zz_commanding_player = GetTriggerPlayer()
call DialogDisplay(GetTriggerPlayer(), udg_zz_start_dialog, true)
endfunction
function DialogResponse takes nothing returns nothing
local button b = GetClickedButton()
local integer i = 0
local dialog d = null
local integer cn = 0
loop
if i >= udg_zz_cdlg_length then
call EndDialog()
return
endif
exitwhen b == udg_zz_cdlg_button[i]
set i = i + 1
endloop
set d = udg_zz_cdlg_dialog[i]
set cn = udg_zz_cdlg_number[i]
if d != null then
set udg_zz_current_command = cn
call DialogDisplay(udg_zz_commanding_player, d, true)
return
endif
call ExecuteDialogCommand(udg_zz_commanded_player, cn)
endfunction
function StartDialogResponse takes nothing returns nothing
local integer i = 0
local button b = GetClickedButton()
loop
if i >= udg_zz_sdbn_length then
call EndDialog()
return
endif
exitwhen udg_zz_sdbn_button[i] == b
set i = i + 1
endloop
set udg_zz_commanded_player = Player(udg_zz_sdbn_number[i])
if udg_zz_commanded_player != Player(14) and (not IsPlayerAlly(udg_zz_commanding_player, udg_zz_commanded_player)) and (not (IsPlayerObserver(udg_zz_commanding_player) and udg_zz_observer_god)) then
call DisplayFromDlg(udg_zz_chat_no_ally)
call EndDialog()
return
endif
call DialogDisplay(udg_zz_commanding_player, udg_zz_root_dialog, true)
endfunction
function PlayerDialogResponse takes nothing returns nothing
local integer i = 0
local button b = GetClickedButton()
loop
if i >= udg_zz_pcbn_length then
call EndDialog()
return
endif
exitwhen udg_zz_pcbn_button[i] == b
set i = i + 1
endloop
set udg_zz_current_player_par = udg_zz_pcbn_number[i]
call ExecuteDialogCommand(udg_zz_commanded_player, udg_zz_current_command)
endfunction
function NumberDialogResponse takes nothing returns nothing
local integer i = 0
local button b = GetClickedButton()
loop
if i >= udg_zz_ndbn_length then
call EndDialog()
return
endif
exitwhen udg_zz_ndbn_button[i] == b
set i = i + 1
endloop
set udg_zz_current_number_par =i
call ExecuteDialogCommand(udg_zz_commanded_player, udg_zz_current_command)
endfunction
function TributeDialogResponse takes nothing returns nothing
local button b = GetClickedButton()
if b == udg_zz_tribute_g then
set udg_zz_tribute_type = "G"
elseif b == udg_zz_tribute_l then
set udg_zz_tribute_type = "L"
else
call EndDialog()
return
endif
call DialogDisplay(udg_zz_commanding_player, udg_zz_tribute_dlg, true)
endfunction
function TributeAmountDialogResponse takes nothing returns nothing
local integer i = 0
local button b = GetClickedButton()
loop
if i >= udg_zz_tribute_dlg_length then
call EndDialog()
return
endif
exitwhen udg_zz_tribute_dlg_button[i] == b
set i = i + 1
endloop
set udg_zz_tribute_amount = I2S((i+1) * 100)
call Tribute(udg_zz_commanding_player, udg_zz_commanded_player, udg_zz_tribute_type, udg_zz_tribute_amount)
call EndDialog()
endfunction
function RegisterCommand takes string c_key1, string c_key2, string c_key3, integer c_number, integer c_par1, integer c_par2, integer c_par3, string c_dlg1, integer c_hk1, string c_dlg2, integer c_hk2, string c_dlg3, integer c_hk3, string c_msg returns nothing
set udg_zz_command_key1[udg_zz_command_length] = c_key1
set udg_zz_command_key2[udg_zz_command_length] = c_key2
set udg_zz_command_key3[udg_zz_command_length] = c_key3
set udg_zz_command_number[udg_zz_command_length] = c_number
set udg_zz_command_par1[udg_zz_command_length] = c_par1
set udg_zz_command_par2[udg_zz_command_length] = c_par2
set udg_zz_command_par3[udg_zz_command_length] = c_par3
set udg_zz_command_dlg1[udg_zz_command_length] = c_dlg1
set udg_zz_command_hotkey1[udg_zz_command_length] = c_hk1
set udg_zz_command_dlg2[udg_zz_command_length] = c_dlg2
set udg_zz_command_hotkey2[udg_zz_command_length] = c_hk2
set udg_zz_command_dlg3[udg_zz_command_length] = c_dlg3
set udg_zz_command_hotkey3[udg_zz_command_length] = c_hk3
set udg_zz_command_msg[udg_zz_command_length] = c_msg
set udg_zz_command_length = udg_zz_command_length + 1
endfunction
function RegisterCommandsEnglish takes nothing returns nothing
call RegisterCommand("Chatter", "", "", 50, -1, -1, -1, "AI Setting", 0, "Chatter", 67, "", 0, "Turned On/Off Computer Chatter.")
call RegisterCommand("Debug", "", "", 51, -1, -1, -1, "", 0, "", 0, "", 0, "Turned On/Off Debug Mode.")
call RegisterCommand("Balance", "", "", 52, -1, -1, -1, "", 0, "", 0, "", 0, "Turned On/Off Balancing Mode.")
call RegisterCommand("Show", "Strategy", "", 60, -1, -1, -1, "Show", 87, "Current Strategy", 67, "", 0, "Showing current strategy.")
call RegisterCommand("Show", "Stratnames", "", 61, -1, -1, -1, "Show", 87, "Strategy names", 83, "", 0, "Showing all strategy names.")
call RegisterCommand("Change", "Strategy", "", 70, -4, -1, -1, "Change Strategy", 72, "#", 0, "", 0, "Changes current strategy.")
call RegisterCommand("Cancel", "All", "", 0, -1, -1, -1, "Cancel Orders", 67, "All Orders", 79, "", 0, "I have Canceled All commands you have given me so far.")
call RegisterCommand("Cancel", "Attack", "", 2, -1, -1, -1, "Cancel Orders", 67, "Attack Orders", 65, "", 0, "I have Canceled all Attack commands you have given me so far.")
call RegisterCommand("Cancel", "Build", "", 1, -1, -1, -1, "Cancel Orders", 67, "Build Orders", 66, "", 0, "I have Canceled all Build commands you have given me so far.")
call RegisterCommand("Cancel", "Queue", "", 30, -1, -1, -1, "Cancel Orders", 67, "Queue", 81, "", 0, "I have Canceled all Queued commands you have given me so far.")
call RegisterCommand("Cancel", "Que", "", 30, -1, -1, -1, "", 0, "", 0, "", 0, "I have Canceled all Queued commands you have given me so far.")
call RegisterCommand("Stop", "", "", 10, -1, -1, -1, "Stop", 83, "", 0, "", 0, "I will Stop any current Attack.")
call RegisterCommand("No", "Attacks", "", 11, -1, -1, -1, "Restrict", 82, "No Attacks", 65, "", 0, "I will not Attack Anything.")
call RegisterCommand("No", "Creep", "", 14, -1, -1, -1, "Restrict", 82, "No Creep Attacks", 67, "", 0, "I will not Attack Creeps.")
call RegisterCommand("No", "Players", "", 15, -1, -1, -1, "Restrict", 82, "No Enemy Attacks", 69, "", 0, "I will not Attack Enemies.")
call RegisterCommand("Build", "A2a", "", 20, -4, -1, -1, "Build", 66, "Air vs. Air", 65, "#", 0, "I will build Air2Air units now.")
call RegisterCommand("Build", "A2A", "", 20, -4, -1, -1, "", 0, "", 0, "", 0, "I will build Air2Air units now.")
call RegisterCommand("Build", "A2g", "", 21, -4, -1, -1, "Build", 66, "Air vs. Ground", 73, "#", 0, "I will build Air2Ground units now.")
call RegisterCommand("Build", "A2G", "", 21, -4, -1, -1, "", 0, "", 0, "", 0, "I will build Air2Ground units now.")
call RegisterCommand("Build", "G2a", "", 22, -4, -1, -1, "Build", 66, "Ground vs. Air", 82, "#", 0, "I will build Ground2Air units now.")
call RegisterCommand("Build", "G2A", "", 22, -4, -1, -1, "", 0, "", 0, "", 0, "I will build Ground2Air units now.")
call RegisterCommand("Build", "G2g", "", 23, -4, -1, -1, "Build", 66, "Ground vs. Ground", 71, "#", 0, "I will build Ground2Ground units now.")
call RegisterCommand("Build", "G2G", "", 23, -4, -1, -1, "", 0, "", 0, "", 0, "I will build Ground2Ground units now.")
call RegisterCommand("Build", "Farms", "", 24, -4, -1, -1, "Build", 66, "Farms", 70, "#", 0, "I will build farms now.")
call RegisterCommand("Build", "Towers", "", 25, -4, -1, -1, "Build", 66, "Towers", 84, "#", 0, "I will build towers now.")
call RegisterCommand("Attack", "Here", "", 13, 0, -30, -31, "Attack", 65, "Current screen", 67, "", 0, "I will Attack/Guard the location of current screen position.")
call RegisterCommand("Attack", "Select", "", 16, -40, -1, -1, "Attack", 65, "Selected unit", 83, "", 0, "I will Attack/Guard the currently selected unit.")
call RegisterCommand("Attack", "Towerrush", "", 17, -1, -1, -1, "Attack", 65, "Towerrush (Orc only)", 84, "", 0, "")
call RegisterCommand("Attack", "", "", 12, -103, -1, -1, "Attack", 65, "Enemy", 69, "e", 0, "I will Attack/Guard the specified player.")
call RegisterCommand("", "Start", "", 33, -1, -1, -1, "Queue", 81, "Start/Restart", 83, "", 0, "I have Started or Restarted your Queued commands.")
call RegisterCommand("", "Restart", "", 33, -1, -1, -1, "", 0, "", 0, "", 0, "I have Started or Restarted your Queued commands.")
call RegisterCommand("", "Pause", "", 34, -1, -1, -1, "Queue", 81, "Pause", 80, "", 0, "I have Paused your Queued commands.")
call RegisterCommand("", "Unpause", "", 35, -1, -1, -1, "Queue", 81, "Unpause", 78, "", 0, "I have Unpaused your Queued commands.")
call RegisterCommand("", "Undo", "", 36, -1, -1, -1, "Queue", 81, "Undo", 85, "", 0, "I have Removed your last Queued command.")
call RegisterCommand("", "Attack", "Here", 31, -1, -30, -31, "Queue", 81, "Attack Here", 65, "", 0, "I have Queued the Attack/Guard location of current screen position.")
call RegisterCommand("", "Attack", "Select", 32, -40, -1, -1, "Queue", 81, "Attack Select", 84, "", 0, "I have Queued the currently selected unit to Attack/Guard.")
call RegisterCommand("No", "Stratchange", "", 53, -1, -1, -1, "Restrict", 82, "No Strategy Change", 83, "", 0, "Turned On/Off Automatic Strategy Change.")
call RegisterCommand("Language", "English", "", 71, 0, -1, -1, "AI Setting", 0, "Language", 76, "English", 69, "Set language of AI to English.")
call RegisterCommand("Language", "Deutsch", "", 71, 1, -1, -1, "AI Setting", 0, "Language", 76, "Deutsch", 68, "AI Sprache ist jetzt Deutsch.")
call RegisterCommand("Language", "Svenska", "", 71, 2, -1, -1, "AI Setting", 0, "Language", 76, "Svenska", 83, "AI Sprak andrat till Svenska.")
call RegisterCommand("Language", "Francais", "", 71, 3, -1, -1, "AI Setting", 0, "Language", 76, "Francais", 70, "Langue de l'IA est maintenant Francais.")
endfunction
function RegisterCommandsDeutsch takes nothing returns nothing
call RegisterCommand("Chatter", "", "", 50, -1, -1, -1, "AI Einstellungen", 0, "Chatten", 67, "", 0, "Computer Chatten wurde an/ausgeschaltet.")
call RegisterCommand("Debug", "", "", 51, -1, -1, -1, "", 0, "", 0, "", 0, "Debug Modus wurde an/ausgeschaltet.")
call RegisterCommand("Balance", "", "", 52, -1, -1, -1, "", 0, "", 0, "", 0, "Balance Modus wurde an/ausgecshaltet.")
call RegisterCommand("Show", "Strategy", "", 60, -1, -1, -1, "Zeige", 87, "Momentane Strategie", 67, "", 0, "Ich zeige momentane Strategie an.")
call RegisterCommand("Show", "Stratnames", "", 61, -1, -1, -1, "Zeige", 87, "Strategienamen", 83, "", 0, "Ich zeige alle Strategienamen an.")
call RegisterCommand("Change", "Strategy", "", 70, -4, -1, -1, "Aendere Strategie", 72, "#", 0, "", 0, "Ich aendere die momentane Strategie.")
call RegisterCommand("Cancel", "All", "", 0, -1, -1, -1, "Befehle loeschen", 67, "Alle Befehle", 79, "", 0, "Ich habe alle Befehle geloescht, die du mir bis jetzt gegeben hast.")
call RegisterCommand("Cancel", "Attack", "", 2, -1, -1, -1, "Befehle loeschen", 67, "Angriffsbefehle", 65, "", 0, "Ich habe alle Angriffsbefehle geloescht, die du mir bis jetzt gegeben hast.")
call RegisterCommand("Cancel", "Build", "", 1, -1, -1, -1, "Befehle loeschen", 67, "Baubefehle", 66, "", 0, "Ich habe alle Baubefehle geloescht, die du mir bis jetzt gegeben hast.")
call RegisterCommand("Cancel", "Queue", "", 30, -1, -1, -1, "Befehle loeschen", 67, "Queuebefehle", 81, "", 0, "Ich habe alle Queuebefehle geloescht, die du mir bis jetzt gegeben hast.")
call RegisterCommand("Cancel", "Que", "", 30, -1, -1, -1, "", 0, "", 0, "", 0, "Ich habe alle Queuebefehle geloescht, die du mir bis jetzt gegeben hast.")
call RegisterCommand("Stop", "", "", 10, -1, -1, -1, "Stop", 83, "", 0, "", 0, "Ich breche den momentanen Angriff ab.")
call RegisterCommand("No", "Attacks", "", 11, -1, -1, -1, "Einschraenken", 82, "Kein Angriff", 65, "", 0, "Ich greife nichts an.")
call RegisterCommand("No", "Creep", "", 14, -1, -1, -1, "Einschraenken", 82, "Keine Creepangriffe", 67, "", 0, "Ich greife keine Creeps an.")
call RegisterCommand("No", "Players", "", 15, -1, -1, -1, "Einschraenken", 82, "Keine Feindangriffe", 69, "", 0, "Ich greife keine Feinde an.")
call RegisterCommand("Build", "A2a", "", 20, -4, -1, -1, "Bauen", 66, "Luft-Luft", 65, "#", 0, "Ich baue Luft-Luft-Einheiten.")
call RegisterCommand("Build", "A2A", "", 20, -4, -1, -1, "", 0, "", 0, "", 0, "Ich baue Luft-Luft-Einheiten.")
call RegisterCommand("Build", "A2g", "", 21, -4, -1, -1, "Bauen", 66, "Luft-Boden", 73, "#", 0, "Ich baue Luft-Boden-Einheiten.")
call RegisterCommand("Build", "A2G", "", 21, -4, -1, -1, "", 0, "", 0, "", 0, "Ich baue Luft-Boden-Einheiten.")
call RegisterCommand("Build", "G2a", "", 22, -4, -1, -1, "Bauen", 66, "Boden-Luft", 82, "#", 0, "Ich baue Boden-Luft-Einheiten.")
call RegisterCommand("Build", "G2A", "", 22, -4, -1, -1, "", 0, "", 0, "", 0, "Ich baue Boden-Luft-Einheiten.")
call RegisterCommand("Build", "G2g", "", 23, -4, -1, -1, "Bauen", 66, "Boden-Boden", 71, "#", 0, "Ich baue Boden-Boden-Einheiten.")
call RegisterCommand("Build", "G2G", "", 23, -4, -1, -1, "", 0, "", 0, "", 0, "Ich baue Boden-Boden-Einheiten.")
call RegisterCommand("Build", "Farms", "", 24, -4, -1, -1, "Bauen", 66, "Farmen", 70, "#", 0, "Ich baue Farmen.")
call RegisterCommand("Build", "Towers", "", 25, -4, -1, -1, "Bauen", 66, "Tuerme", 84, "#", 0, "Ich baue Tuerme.")
call RegisterCommand("Attack", "Here", "", 13, 0, -30, -31, "Angriff", 65, "Bildschirmposition", 67, "", 0, "Ich greife an/verteidige die momentane Bildschirmposition.")
call RegisterCommand("Attack", "Select", "", 16, -40, -1, -1, "Angriff", 65, "Gewaehlte Einheit", 83, "", 0, "Ich greife an/verteidige die gewaehlte Einheit.")
call RegisterCommand("Attack", "Towerrush", "", 17, -1, -1, -1, "Angriff", 65, "Towerrush (Nur Orks)", 84, "", 0, "")
call RegisterCommand("Attack", "", "", 12, -103, -1, -1, "Angriff", 65, "Feind", 69, "e", 0, "Ich greife an/verteidige den gewaehlten Spieler.")
call RegisterCommand("", "Start", "", 33, -1, -1, -1, "Queue", 81, "Start", 83, "", 0, "Ich habe die Befehlsqueue gestartet / erneut gestartet.")
call RegisterCommand("", "Restart", "", 33, -1, -1, -1, "", 0, "", 0, "", 0, "Ich habe die Befehlsqueue gestartet / erneut gestartet.")
call RegisterCommand("", "Pause", "", 34, -1, -1, -1, "Queue", 81, "Pause", 80, "", 0, "Ich habe die Befehlsqueue angehalten.")
call RegisterCommand("", "Unpause", "", 35, -1, -1, -1, "Queue", 81, "Ende Pause", 78, "", 0, "Ich habe die Befehlsqueue weiterlaufen lassen.")
call RegisterCommand("", "Undo", "", 36, -1, -1, -1, "Queue", 81, "Rueckgaengig", 85, "", 0, "Ich habe den letzten Befehl in der Befehlsqueue geloescht.")
call RegisterCommand("", "Attack", "Here", 31, -1, -30, -31, "Queue", 81, "Bildschirmposition angreifen", 65, "", 0, "Ich habe den Angriff/die Verteidigung der momentanen Bildschirmposition in die Queue hinzugefuegt.")
call RegisterCommand("", "Attack", "Select", 32, -40, -1, -1, "Queue", 81, "Gewaehlte Einheit angreifen", 84, "", 0, "Ich habe den Angriff/die Verteidigung der gewaehlten Einheit in die Queue hinzugefuegt.")
call RegisterCommand("No", "Stratchange", "", 53, -1, -1, -1, "Einschraenken", 82, "Kein Strategiewechsel", 83, "", 0, "Ich habe den automatischen Strategiewechsel an/ausgeschaltet.")
call RegisterCommand("Language", "English", "", 71, 0, -1, -1, "AI Einstellungen", 0, "Sprache", 76, "English", 69, "Set language of AI to English.")
call RegisterCommand("Language", "Deutsch", "", 71, 1, -1, -1, "AI Einstellungen", 0, "Sprache", 76, "Deutsch", 68, "AI Sprache ist jetzt Deutsch.")
call RegisterCommand("Language", "Svenska", "", 71, 2, -1, -1, "AI Einstellungen", 0, "Sprache", 76, "Svenska", 83, "AI Sprak andrat till Svenska.")
call RegisterCommand("Language", "Francais", "", 71, 3, -1, -1, "AI Einstellungen", 0, "Sprache", 76, "Francais", 70, "Langue de l'IA est maintenant Francais.")
endfunction
function RegisterCommandsSwedish takes nothing returns nothing
call RegisterCommand("Chatter", "", "", 50, -1, -1, -1, "AI Installningar", 0, "Chat", 67, "", 0, "Stangde av / satte pa dator chat.")
call RegisterCommand("Debug", "", "", 51, -1, -1, -1, "", 0, "", 0, "", 0, "Stangde av / satte pa felsokningsmedelande.")
call RegisterCommand("Balance", "", "", 52, -1, -1, -1, "", 0, "", 0, "", 0, "Stangde av / satte pa balanseringslage.")
call RegisterCommand("Show", "Strategy", "", 60, -1, -1, -1, "Visa", 87, "Nuvarande strategi", 67, "", 0, "Visar nuvarande strategi.")
call RegisterCommand("Show", "Stratnames", "", 61, -1, -1, -1, "Visa", 87, "Strateginamn", 83, "", 0, "Visar alla strateginamn.")
call RegisterCommand("Change", "Strategy", "", 70, -4, -1, -1, "Byt strategi", 72, "#", 0, "", 0, "Byter strategi.")
call RegisterCommand("Cancel", "All", "", 0, -1, -1, -1, "Avbryt Order", 67, "Alla order", 79, "", 0, "Jag har avbrutit alla kommando du gett mig hittills.")
call RegisterCommand("Cancel", "Attack", "", 2, -1, -1, -1, "Avbryt Order", 67, "Attack Order", 65, "", 0, "Jag har avbrutit alla attack order du gett mig hittills.")
call RegisterCommand("Cancel", "Build", "", 1, -1, -1, -1, "Avbryt Order", 67, "Bygg Order", 66, "", 0, "Jag har avbrutit alla bygg order du gett hittills.")
call RegisterCommand("Cancel", "Queue", "", 30, -1, -1, -1, "Avbryt Order", 67, "Foljd", 81, "", 0, "Jag har avbrutit alla foljdkommandon du gett mig hittills.")
call RegisterCommand("Cancel", "Que", "", 30, -1, -1, -1, "", 0, "", 0, "", 0, "Jag har avbrutit alla foljdkommando du gett mig hittills.")
call RegisterCommand("Stop", "", "", 10, -1, -1, -1, "Stopp", 83, "", 0, "", 0, "Jag avbryter nuvarande anfall.")
call RegisterCommand("No", "Attacks", "", 11, -1, -1, -1, "Begransa", 82, "Inga anfall", 65, "", 0, "Jag kommer inte anfalla nagot.")
call RegisterCommand("No", "Creep", "", 14, -1, -1, -1, "Begransa", 82, "Inga creepattacker", 67, "", 0, "Jag kommer inte anfalla creeps.")
call RegisterCommand("No", "Players", "", 15, -1, -1, -1, "Begransa", 82, "Inga fiendeanfall", 69, "", 0, "Jag kommer inte anfalla fienden.")
call RegisterCommand("Build", "A2a", "", 20, -4, -1, -1, "Bygg", 66, "Luft mot. Luft", 65, "#", 0, "Jag kommer bygga luft- mot luftenheter nu.")
call RegisterCommand("Build", "A2A", "", 20, -4, -1, -1, "", 0, "", 0, "", 0, "Jag kommer bygga luft- mot luftenheter nu.")
call RegisterCommand("Build", "A2g", "", 21, -4, -1, -1, "Bygg", 66, "Luft mot. Mark", 73, "#", 0, "Jag kommer bygga luft- mot markenheter nu.")
call RegisterCommand("Build", "A2G", "", 21, -4, -1, -1, "", 0, "", 0, "", 0, "Jag kommer bygga luft- mot markenheter nu.")
call RegisterCommand("Build", "G2a", "", 22, -4, -1, -1, "Bygg", 66, "Mark mot. Luft", 82, "#", 0, "Jag kommer bygga mark- mot luftenheter nu.")
call RegisterCommand("Build", "G2A", "", 22, -4, -1, -1, "", 0, "", 0, "", 0, "Jag kommer bygga mark- mot luftenheter nu.")
call RegisterCommand("Build", "G2g", "", 23, -4, -1, -1, "Bygg", 66, "Mark mot. Mark", 71, "#", 0, "Jag kommer bygga mark- mot markenheter nu.")
call RegisterCommand("Build", "G2G", "", 23, -4, -1, -1, "", 0, "", 0, "", 0, "Jag kommer bygga mark- mot markenheter nu.")
call RegisterCommand("Build", "Farms", "", 24, -4, -1, -1, "Bygg", 66, "Farms", 70, "#", 0, "Jag kommer bygga farms nu.")
call RegisterCommand("Build", "Towers", "", 25, -4, -1, -1, "Bygg", 66, "Torn", 84, "#", 0, "Jag kommer bygga torn nu.")
call RegisterCommand("Attack", "Here", "", 13, 0, -30, -31, "Anfall", 65, "Nuvarande bild", 67, "", 0, "Jag kommer anfalla/vakta nuvarande position av bilden.")
call RegisterCommand("Attack", "Select", "", 16, -40, -1, -1, "Anfall", 65, "Vald enhet", 83, "", 0, "Jag kommer anfalla/vakta den aktuellt valda enheten.")
call RegisterCommand("Attack", "Towerrush", "", 17, -1, -1, -1, "Anfall", 65, "Towerrush (Orc only)", 84, "", 0, "")
call RegisterCommand("Attack", "", "", 12, -103, -1, -1, "Anfall", 65, "Spelare", 69, "e", 0, "Jag kommer anfalla/vakta den valda spelaren.")
call RegisterCommand("", "Start", "", 33, -1, -1, -1, "Foljd", 81, "Starta/Starta om", 83, "", 0, "Jag har startat eller startat om dina foljdkommando.")
call RegisterCommand("", "Restart", "", 33, -1, -1, -1, "", 0, "", 0, "", 0, "Jag har startat eller startat om dina foljdkommando.")
call RegisterCommand("", "Pause", "", 34, -1, -1, -1, "Foljd", 81, "Paus", 80, "", 0, "Jag har pausat dina foljdkommando.")
call RegisterCommand("", "Unpause", "", 35, -1, -1, -1, "Foljd", 81, "Fortsatt", 78, "", 0, "Jag har fortsatt med dina foljdkommandon.")
call RegisterCommand("", "Undo", "", 36, -1, -1, -1, "Foljd", 81, "Angra", 85, "", 0, "Jag har tagit bort ditt senaste foljdkommando.")
call RegisterCommand("", "Attack", "Here", 31, -1, -30, -31, "Foljd", 81, "Anfall bild", 65, "", 0, "Jag har foljdlagt en order att anfalla/vakta nuvarande bild.")
call RegisterCommand("", "Attack", "Select", 32, -40, -1, -1, "Foljd", 81, "Anfall vald", 84, "", 0, "Jag har foljdlagt en order att anfalla/vakta valda enheten.")
call RegisterCommand("No", "Stratchange", "", 53, -1, -1, -1, "Begransa", 82, "Inget strategibyte", 83, "", 0, "Stangt av / satt pa automatiskt strategibyte.")
call RegisterCommand("Language", "English", "", 71, 0, -1, -1, "AI Installningar", 0, "Sprak", 76, "English", 69, "Set language of AI to English.")
call RegisterCommand("Language", "Deutsch", "", 71, 1, -1, -1, "AI Installningar", 0, "Sprak", 76, "Deutsch", 68, "AI Sprache ist jetzt Deutsch.")
call RegisterCommand("Language", "Svenska", "", 71, 2, -1, -1, "AI Installningar", 0, "Sprak", 76, "Svenska", 83, "AI Sprak andrat till Svenska.")
call RegisterCommand("Language", "Francais", "", 71, 3, -1, -1, "AI Installningar", 0, "Sprak", 76, "Francais", 70, "Langue de l'IA est maintenant Francais.")
endfunction
function RegisterCommandsFrench takes nothing returns nothing
call RegisterCommand("Chatter", "", "", 50, -1, -1, -1, "Configuration de l'IA", 0, "Discussion", 67, "", 0, "Permettre/Proscrire la discussion avec l'ordinateur.")
call RegisterCommand("Debug", "", "", 51, -1, -1, -1, "", 0, "", 0, "", 0, "Permettre/Proscrire le mode debogger .")
call RegisterCommand("Balance", "", "", 52, -1, -1, -1, "", 0, "", 0, "", 0, "Permettre/proscire le mode d'quilibrage.")
call RegisterCommand("Show", "Strategy", "", 60, -1, -1, -1, "Montrer", 87, "Strategie actuelle", 67, "", 0, "Montrer la strategie actuelle.")
call RegisterCommand("Show", "Stratnames", "", 61, -1, -1, -1, "Montrer", 87, "Noms des strategies", 83, "", 0, "Montrer tous les noms des strategies.")
call RegisterCommand("Change", "Strategy", "", 70, -4, -1, -1, "Changer la strategie", 72, "#", 0, "", 0, "Changer la strategie actuelle.")
call RegisterCommand("Cancel", "All", "", 0, -1, -1, -1, "Annuler les ordres", 67, "tous les ordres", 79, "", 0, "J'ai annule tous les ordres que tu m'as donne auparavant.")
call RegisterCommand("Cancel", "Attack", "", 2, -1, -1, -1, "Annuler les ordres", 67, "Les ordres d'attaques", 65, "", 0, "J'ai annule tous les ordres d'attaque que tu m'as donne auparavant.")
call RegisterCommand("Cancel", "Build", "", 1, -1, -1, -1, "Annuler les ordres", 67, "les ordres de construction", 66, "", 0, "J'ai annule tous les ordres de construction que tu m'as donne auparavant.")
call RegisterCommand("Cancel", "Queue", "", 30, -1, -1, -1, "Annuler les ordres", 67, "file d'attente", 81, "", 0, "J'ai annule tous les ordres dans la file d'attente que tu m'as donne auparavant.")
call RegisterCommand("Cancel", "Que", "", 30, -1, -1, -1, "", 0, "", 0, "", 0, "J'ai annule tous les ordres dans la file d'attente que tu m'as donne auparavant.")
call RegisterCommand("Stop", "", "", 10, -1, -1, -1, "Stop", 83, "", 0, "", 0, "Je vais annuler toutes attaques actuelles.")
call RegisterCommand("No", "Attacks", "", 11, -1, -1, -1, "Restrictions", 82, "Pas d'attaques", 65, "", 0, "Je vais attaqer personne.")
call RegisterCommand("No", "Creep", "", 14, -1, -1, -1, "Restrictions", 82, "Pas d'attaques de creep", 67, "", 0, "Je ne vais pas attquer de creep.")
call RegisterCommand("No", "Players", "", 15, -1, -1, -1, "Restrictions", 82, "Pas d'attaques contre des ennemis",69, "", 0, "Je ne vais pas attaquer d'ennemis.")
call RegisterCommand("Build", "A2a", "", 20, -4, -1, -1, "Construire", 66, "Air vs. Air", 65, "#", 0, "Je vais creer des unites air/air maintenant.")
call RegisterCommand("Build", "A2A", "", 20, -4, -1, -1, "", 0, "", 0, "", 0, "Je vais creer des unites air/air maintenant.")
call RegisterCommand("Build", "A2g", "", 21, -4, -1, -1, "Construire", 66, "Air vs. sol", 73, "#", 0, "Je vais creer des unites air/sol maintenant.")
call RegisterCommand("Build", "A2G", "", 21, -4, -1, -1, "", 0, "", 0, "", 0, "Je vais creer des unites air/sol maintenant.")
call RegisterCommand("Build", "G2a", "", 22, -4, -1, -1, "Construire", 66, "sol vs. Air", 82, "#", 0, "Je vais creer des unites sol/air maintenant.")
call RegisterCommand("Build", "G2A", "", 22, -4, -1, -1, "", 0, "", 0, "", 0, "Je vais creer des unites sol/air maintenant.")
call RegisterCommand("Build", "G2g", "", 23, -4, -1, -1, "Construire", 66, "sol vs. sol", 71, "#", 0, "Je vais creer des unites sol/sol maintenant.")
call RegisterCommand("Build", "G2G", "", 23, -4, -1, -1, "", 0, "", 0, "", 0, "Je vais creer des unites sol/sol maintenant.")
call RegisterCommand("Build", "Farms", "", 24, -4, -1, -1, "Construire", 66, "Fermes", 70, "#", 0, "Je vais creer des fermes maintenant.")
call RegisterCommand("Build", "Towers", "", 25, -4, -1, -1, "Construire", 66, "Tourelles", 84, "#", 0, "Je vais creer des tourelles maintenant.")
call RegisterCommand("Attack", "Here", "", 13, 0, -30, -31, "Attaquer", 65, "Position actuelle", 67, "", 0, "Je vais attaquer/garder a la position actuelle de l'ecran.")
call RegisterCommand("Attack", "Select", "", 16, -40, -1, -1, "Attaquer", 65, "L'unite selectionnee", 83, "", 0, "Je vais attaquer/garder cette unite selectionnee actuellement.")
call RegisterCommand("Attack", "Towerrush", "", 17, -1, -1, -1, "Attaquer", 65, "Towerrush (Orc seulement)", 84, "", 0, "")
call RegisterCommand("Attack", "", "", 12, -103, -1, -1, "Attaquer", 65, "Ennemi", 69, "e", 0, "Je vais attaquer/garder ce joueur specifique.")
call RegisterCommand("", "Start", "", 33, -1, -1, -1, "file d'attente", 81, "Commencer/Recommencer", 83, "", 0, "J'ai commence ou recommence tes ordres dans la file d'attente.")
call RegisterCommand("", "Restart", "", 33, -1, -1, -1, "", 0, "", 0, "", 0, "J'ai commence ou recommence tes ordres dans la file d'attente.")
call RegisterCommand("", "Pause", "", 34, -1, -1, -1, "file d'attente", 81, "Pause", 80, "", 0, "J'ai mis en veille vos ordres dans la file d'attente.")
call RegisterCommand("", "Unpause", "", 35, -1, -1, -1, "file d'attente", 81, "Reprise", 78, "", 0, "J'ai repris vos ordres dans la file d'attente.")
call RegisterCommand("", "Undo", "", 36, -1, -1, -1, "file d'attente", 81, "Annuler", 85, "", 0, "J'ai supprime vos derniers ordres dans la file d'attente.")
call RegisterCommand("", "Attack", "Here", 31, -1, -30, -31, "file d'attente", 81, "Attaquer ici", 65, "", 0, "J'ai mis dans la file d'attente l'attaque/la protection du lieu de l'ecran actuel.")
call RegisterCommand("", "Attack", "Select", 32, -40, -1, -1, "file d'attente", 81, "Attaque choisie", 84, "", 0, "J'ai mis dans la file d'attente l'unite choisir a attaquer/garder.")
call RegisterCommand("No", "Stratchange", "", 53, -1, -1, -1, "Restrictions", 82, "Pas de changement de strategie", 83, "", 0, "Permettre/Proscire les changements automatiques de strategie.")
call RegisterCommand("Language", "English", "", 71, 0, -1, -1, "Configuration de l'IA", 0, "Langue", 76, "English", 69, "Set language of AI to English.")
call RegisterCommand("Language", "Deutsch", "", 71, 1, -1, -1, "Configuration de l'IA", 0, "Langue", 76, "Deutsch", 68, "AI Sprache ist jetzt Deutsch.")
call RegisterCommand("Language", "Svenska", "", 71, 2, -1, -1, "Configuration de l'IA", 0, "Langue", 76, "Svenska", 83, "AI Sprak andrat till Svenska.")
call RegisterCommand("Language", "Francais", "", 71, 3, -1, -1, "Configuration de l'IA", 0, "Langue", 76, "Francais", 70, "Langue de l'IA est maintenant Francais.")
endfunction
function RegisterAllCommands takes nothing returns nothing
if udg_zz_command_language == "Deutsch" then
call RegisterCommandsDeutsch()
elseif udg_zz_command_language == "Swedish" then
call RegisterCommandsSwedish()
elseif udg_zz_command_language == "French" then
call RegisterCommandsFrench()
else
call RegisterCommandsEnglish()
endif
endfunction
function AddCancelButton takes dialog d returns nothing
call DialogAddButton(d, udg_zz_dlgbutton_cancel, 512)
endfunction
function RegisterCDialogButton takes button b, integer cn, dialog d returns nothing
set udg_zz_cdlg_button[udg_zz_cdlg_length] = b
set udg_zz_cdlg_number[udg_zz_cdlg_length] = cn
set udg_zz_cdlg_dialog[udg_zz_cdlg_length] = d
set udg_zz_cdlg_length = udg_zz_cdlg_length + 1
endfunction
function RegisterDialog takes string s returns dialog
local dialog d = DialogCreate()
local trigger t = CreateTrigger()
if s == "" then
call DialogSetMessage(d, udg_zz_dlghdr_root)
else
call DialogSetMessage(d, s)
endif
set udg_zz_dlg_dialog[udg_zz_dlg_length] = d
set udg_zz_dlg_string[udg_zz_dlg_length] = s
set udg_zz_dlg_length = udg_zz_dlg_length + 1
call TriggerRegisterDialogEvent(t, d)
call TriggerAddAction(t, function DialogResponse)
return d
endfunction
function FindDialog takes string s returns dialog
local integer i = 0
loop
exitwhen i >= udg_zz_dlg_length
if udg_zz_dlg_string[i] == s then
return udg_zz_dlg_dialog[i]
endif
set i = i + 1
endloop
return null
endfunction
function BuildStartDialog takes nothing returns nothing
local trigger t = CreateTrigger()
local integer i = 0
set udg_zz_start_dialog = DialogCreate()
call DialogSetMessage(udg_zz_start_dialog, udg_zz_dlghdr_choose_ally)
set udg_zz_sdbn_button[udg_zz_sdbn_length] = DialogAddButton(udg_zz_start_dialog, udg_zz_dlgbutton_all, 65)
set udg_zz_sdbn_number[udg_zz_sdbn_length] = 14
set udg_zz_sdbn_length = udg_zz_sdbn_length + 1
loop
exitwhen i > 11
if GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
set udg_zz_sdbn_button[udg_zz_sdbn_length] = DialogAddButton(udg_zz_start_dialog, cs2s(GetPlayerName(Player(i)), GetPlayerColor(Player(i))), IMinBJ(48 + i, 57))
set udg_zz_sdbn_number[udg_zz_sdbn_length] = i
set udg_zz_sdbn_length = udg_zz_sdbn_length + 1
endif
set i = i + 1
endloop
call AddCancelButton(udg_zz_start_dialog)
call TriggerRegisterDialogEvent(t, udg_zz_start_dialog )
call TriggerAddAction(t, function StartDialogResponse)
endfunction
function BuildNumberDialog takes nothing returns nothing
local trigger t = CreateTrigger()
local integer i = 0
set udg_zz_number_dialog = DialogCreate()
call DialogSetMessage(udg_zz_number_dialog, udg_zz_dlghdr_choose_number)
loop
exitwhen i >= 10
set udg_zz_ndbn_button[udg_zz_ndbn_length] = DialogAddButton(udg_zz_number_dialog, I2S(i), IMinBJ(48 + i, 57))
set udg_zz_ndbn_length = udg_zz_ndbn_length + 1
set i = i + 1
endloop
call AddCancelButton(udg_zz_number_dialog)
call TriggerRegisterDialogEvent(t, udg_zz_number_dialog )
call TriggerAddAction(t, function NumberDialogResponse)
endfunction
function BuildPlayerDialog takes nothing returns nothing
local trigger t = CreateTrigger()
local integer i = 0
set udg_zz_player_dialog = DialogCreate()
call DialogSetMessage(udg_zz_player_dialog, udg_zz_dlghdr_choose_player)
loop
exitwhen i > 11
if not IsPlayerObserver(Player(i)) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
set udg_zz_pcbn_button[udg_zz_pcbn_length] = DialogAddButton(udg_zz_player_dialog, cs2s(GetPlayerName(Player(i)), GetPlayerColor(Player(i))), IMinBJ(48 + i, 57))
set udg_zz_pcbn_number[udg_zz_pcbn_length] = i
set udg_zz_pcbn_length = udg_zz_pcbn_length + 1
endif
set i = i + 1
endloop
call AddCancelButton(udg_zz_player_dialog)
call TriggerRegisterDialogEvent(t, udg_zz_player_dialog )
call TriggerAddAction(t, function PlayerDialogResponse)
endfunction
function AddCommandDialog takes integer i returns nothing
local dialog udg_zz_current_dialog = null
local dialog next_dialog = null
local string udg_zz_current_name = ""
if udg_zz_command_dlg3[i] != "" then
if udg_zz_command_dlg3[i] == "#" then
set next_dialog = udg_zz_number_dialog
elseif udg_zz_command_dlg3[i] == "e" then
set next_dialog = udg_zz_player_dialog
else
set udg_zz_current_name = udg_zz_command_dlg1[i]+" "+udg_zz_command_dlg2[i]
set udg_zz_current_dialog = FindDialog(udg_zz_current_name)
if udg_zz_current_dialog != null then
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg3[i], udg_zz_command_hotkey3[i]), i, next_dialog)
return
endif
set udg_zz_current_dialog = RegisterDialog(udg_zz_current_name)
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg3[i], udg_zz_command_hotkey3[i]), i, next_dialog)
set next_dialog = udg_zz_current_dialog
endif
endif
if udg_zz_command_dlg2[i] != "" then
if udg_zz_command_dlg2[i] == "#" then
set next_dialog = udg_zz_number_dialog
elseif udg_zz_command_dlg2[i] == "e" then
set next_dialog = udg_zz_player_dialog
else
set udg_zz_current_name = udg_zz_command_dlg1[i]
set udg_zz_current_dialog = FindDialog(udg_zz_current_name)
if udg_zz_current_dialog != null then
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg2[i], udg_zz_command_hotkey2[i]), i, next_dialog)
return
endif
set udg_zz_current_dialog = RegisterDialog(udg_zz_current_name)
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg2[i], udg_zz_command_hotkey2[i]), i, next_dialog)
set next_dialog = udg_zz_current_dialog
endif
endif
if udg_zz_command_dlg1[i] != "" then
set udg_zz_current_name = ""
set udg_zz_current_dialog = FindDialog(udg_zz_current_name)
if udg_zz_current_dialog != null then
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg1[i], udg_zz_command_hotkey1[i]), i, next_dialog)
return
endif
set udg_zz_current_dialog = RegisterDialog(udg_zz_current_name)
call RegisterCDialogButton(DialogAddButton(udg_zz_current_dialog, udg_zz_command_dlg1[i], udg_zz_command_hotkey1[i]), i, next_dialog)
endif
endfunction
function AddCDCancelButtons takes nothing returns nothing
local integer i = 0
loop
exitwhen i >= udg_zz_dlg_length
call AddCancelButton(udg_zz_dlg_dialog[i])
set i = i + 1
endloop
endfunction
function BuildCommandDialogs takes nothing returns nothing
local integer i = 0
loop
exitwhen i >=udg_zz_command_length
call AddCommandDialog(i)
set i = i + 1
endloop
set udg_zz_root_dialog = FindDialog("")
endfunction
function BuildTributeDialogs takes nothing returns nothing
local dialog d = DialogCreate()
local trigger t = CreateTrigger()
local integer i = 0
call DialogSetMessage(d, udg_zz_dlghdr_tribute_type)
set udg_zz_tribute_g = DialogAddButton(d, udg_zz_dlgbutton_gold, 71)
set udg_zz_tribute_l = DialogAddButton(d, udg_zz_dlgbutton_lumber, 76)
call AddCancelButton(d)
call TriggerRegisterDialogEvent(t, d)
call TriggerAddAction(t, function TributeDialogResponse)
call RegisterCDialogButton(DialogAddButton(udg_zz_root_dialog, udg_zz_dlgbutton_tribute, 84), 0, d)
set udg_zz_tribute_dlg = DialogCreate()
call DialogSetMessage(udg_zz_tribute_dlg, udg_zz_dlghdr_tribute_amount)
loop
exitwhen i >= 10
set udg_zz_tribute_dlg_button[i] = DialogAddButton(udg_zz_tribute_dlg, I2S(100 * (i+1)), IMinBJ(48 + i + 1, 57))
set i = i + 1
endloop
call AddCancelButton(udg_zz_tribute_dlg)
set udg_zz_tribute_dlg_length = i
set t = CreateTrigger()
call TriggerRegisterDialogEvent(t, udg_zz_tribute_dlg)
call TriggerAddAction(t, function TributeAmountDialogResponse)
endfunction
function BuildDialogs takes nothing returns nothing
call BuildStartDialog()
call BuildNumberDialog()
call BuildPlayerDialog()
call BuildCommandDialogs()
call BuildTributeDialogs()
call AddCDCancelButtons()
endfunction
function InitCommanderPart takes nothing returns nothing
local integer i = 0
local trigger commander_trigger = CreateTrigger()
local trigger udg_zz_cdlg_trigger = CreateTrigger()
local timer t = CreateTimer()
loop
exitwhen i >= 12
call TriggerRegisterPlayerChatEvent( commander_trigger, Player(i), udg_zz_command_prefix, false )
call TriggerRegisterPlayerEvent( udg_zz_cdlg_trigger, Player(i), EVENT_PLAYER_END_CINEMATIC )
set i = i + 1
endloop
call TriggerAddAction( commander_trigger, function Commander )
call TriggerAddAction( udg_zz_cdlg_trigger, function DialogCommander )
call RegisterAllCommands()
call BuildDialogs()
call TimerStart(t,3.0, false, function MapInit)
endfunction
function SendToAllAIs takes integer cmd, integer data returns nothing
local integer i = 0
loop
exitwhen i > 11
if GetPlayerController(Player(i)) == MAP_CONTROL_COMPUTER then
call CommandAI(Player(i), cmd, data)
endif
set i = i + 1
endloop
endfunction
function GetNextHuman takes integer last returns integer
local integer i = last + 1
loop
exitwhen i > 11
if GetPlayerController(Player(i)) == MAP_CONTROL_USER and not IsPlayerObserver(Player(i)) and GetPlayerSlotState(Player(i)) == PLAYER_SLOT_STATE_PLAYING then
return i
endif
set i = i + 1
endloop
return -1
endfunction
function GetFirstHuman takes nothing returns integer
return GetNextHuman(-1)
endfunction
function CheckAllyToControl takes player p returns boolean
local integer q = 0
loop
exitwhen q > 11
if IsPlayerAlly(Player(q), p) and GetPlayerController(Player(q)) == MAP_CONTROL_COMPUTER then
return true
endif
set q = q + 1
endloop
return false
endfunction
function EnumKillUnit takes nothing returns nothing
call KillUnit(GetEnumUnit())
endfunction
function RemoveHumanUnitsAndRes takes nothing returns nothing
local player p = GetEnumPlayer()
local group g = null
if GetPlayerController(p) != MAP_CONTROL_USER then
return
endif
set g = CreateGroup()
call GroupEnumUnitsOfPlayer(g, p, null)
call ForGroup(g, function EnumKillUnit)
call SetPlayerState(p, PLAYER_STATE_RESOURCE_GOLD, 0)
call SetPlayerState(p, PLAYER_STATE_RESOURCE_LUMBER, 0)
endfunction
function GameStartDlgResponse takes nothing returns nothing
local button cb = GetClickedButton()
if cb != udg_zz_ai_only_mode then
call InitCommanderPart()
if cb == udg_zz_no_human_mode then
call ForForce(GetPlayersAll(), function RemoveHumanUnitsAndRes)
call SendToAllAIs(53,0)
endif
endif
call DialogDestroy(udg_zz_game_start_dialog)
set udg_zz_game_start_dialog = null
call DestroyTrigger(udg_zz_game_start_trigger)
set udg_zz_game_start_trigger = null
endfunction
function GameStartDlg takes nothing returns nothing
local integer host = GetFirstHuman()
local integer p = host
loop
if p == -1 then
return
endif
exitwhen CheckAllyToControl(Player(p))
set p = GetNextHuman(p)
endloop
set udg_zz_game_start_dialog = DialogCreate()
call DialogSetMessage(udg_zz_game_start_dialog, udg_zz_dlghdr_game_type)
set udg_zz_commander_mode = DialogAddButton(udg_zz_game_start_dialog, udg_zz_dlgbutton_commander, 67)
set udg_zz_no_human_mode = DialogAddButton(udg_zz_game_start_dialog, udg_zz_dlgbutton_no_human, 79)
set udg_zz_ai_only_mode = DialogAddButton(udg_zz_game_start_dialog, udg_zz_dlgbutton_ai_only, 78)
set udg_zz_game_start_trigger = CreateTrigger()
call TriggerRegisterDialogEvent(udg_zz_game_start_trigger, udg_zz_game_start_dialog)
call TriggerAddAction(udg_zz_game_start_trigger, function GameStartDlgResponse)
call DialogDisplay(Player(host), udg_zz_game_start_dialog, true)
endfunction
function initLanguageEnglish takes nothing returns nothing
set udg_zz_chat_no_ally = "I will never obey you."
set udg_zz_dlghdr_choose_ally = "Choose Ally"
set udg_zz_dlghdr_choose_number = "Choose Number"
set udg_zz_dlghdr_choose_player = "Choose Player"
set udg_zz_dlghdr_game_type = "Choose Game Type"
set udg_zz_dlghdr_root = "Choose Command"
set udg_zz_dlghdr_tribute_type = "Choose Tribute Type"
set udg_zz_dlghdr_tribute_amount = "Choose Tribute Amount"
set udg_zz_dlgbutton_cancel = "Cancel"
set udg_zz_dlgbutton_all = "All"
set udg_zz_dlgbutton_gold = "Gold"
set udg_zz_dlgbutton_lumber = "Lumber"
set udg_zz_dlgbutton_tribute = "Tribute"
set udg_zz_dlgbutton_commander = "Commander"
set udg_zz_dlgbutton_no_human = "Computers only"
set udg_zz_dlgbutton_ai_only = "No Commander"
endfunction
function initLanguageDeutsch takes nothing returns nothing
set udg_zz_chat_no_ally = "Ich werde dir nie gehorchen."
set udg_zz_dlghdr_choose_ally = "Waehle einen Verbuendeten"
set udg_zz_dlghdr_choose_number = "Zahl waehlen"
set udg_zz_dlghdr_choose_player = "Waehle einen Spieler"
set udg_zz_dlghdr_game_type = "Waehle den Spielmodus"
set udg_zz_dlghdr_root = "Befehl waehlen"
set udg_zz_dlghdr_tribute_type = "Waehle die Tributart"
set udg_zz_dlghdr_tribute_amount = "Waehle die Tributmenge"
set udg_zz_dlgbutton_cancel = "Abbrechen"
set udg_zz_dlgbutton_all = "Alle"
set udg_zz_dlgbutton_gold = "Gold"
set udg_zz_dlgbutton_lumber = "Holz"
set udg_zz_dlgbutton_tribute = "Tribut"
set udg_zz_dlgbutton_commander = "Commander"
set udg_zz_dlgbutton_no_human = "Nur Computer"
set udg_zz_dlgbutton_ai_only = "Kein Commander"
endfunction
function initLanguageSwedish takes nothing returns nothing
set udg_zz_chat_no_ally = "jag kommer aldrig lyda dig."
set udg_zz_dlghdr_choose_ally = "Valj din lierade"
set udg_zz_dlghdr_choose_number = "Valj nummer"
set udg_zz_dlghdr_choose_player = "Valj spelare"
set udg_zz_dlghdr_game_type = "Valj speltyp"
set udg_zz_dlghdr_root = "Valj kommando"
set udg_zz_dlghdr_tribute_type = "Valj beskattningsmetod"
set udg_zz_dlghdr_tribute_amount = "Valj skattemangd"
set udg_zz_dlgbutton_cancel = "Avbryt"
set udg_zz_dlgbutton_all = "Alla"
set udg_zz_dlgbutton_gold = "Guld"
set udg_zz_dlgbutton_lumber = "Tra"
set udg_zz_dlgbutton_tribute = "Skatt"
set udg_zz_dlgbutton_commander = "Commander"
set udg_zz_dlgbutton_no_human = "Endast datorer"
set udg_zz_dlgbutton_ai_only = "Ingen Commander"
endfunction
function initLanguageFrench takes nothing returns nothing
set udg_zz_chat_no_ally = "Je ne t'obirai jamais."
set udg_zz_dlghdr_choose_ally = "Choisir un allie."
set udg_zz_dlghdr_choose_number = "Choisir un nombre."
set udg_zz_dlghdr_choose_player = "Choisir un joueur."
set udg_zz_dlghdr_game_type = "Choisir un type de partie."
set udg_zz_dlghdr_root = "Choisissez la Commande."
set udg_zz_dlghdr_tribute_type = "Choisir le type de tributs."
set udg_zz_dlghdr_tribute_amount = "Choisirla quantite de tributs."
set udg_zz_dlgbutton_cancel = "Annuler."
set udg_zz_dlgbutton_all = "Tout."
set udg_zz_dlgbutton_gold = "Or."
set udg_zz_dlgbutton_lumber = "Bois."
set udg_zz_dlgbutton_tribute = "Tributs."
set udg_zz_dlgbutton_commander = "Commandant."
set udg_zz_dlgbutton_no_human = "Seulement des ordinateurs"
set udg_zz_dlgbutton_ai_only = "Pas de commandant."
endfunction
function LanguageDlgResponse takes nothing returns nothing
local button b = GetClickedButton()
if b == udg_zz_deutsch_button then
set udg_zz_command_language = "Deutsch"
call SendToAllAIs(71,1)
call initLanguageDeutsch()
elseif b == udg_zz_swedish_button then
set udg_zz_command_language = "Swedish"
call SendToAllAIs(71,2)
call initLanguageSwedish()
elseif b == udg_zz_french_button then
set udg_zz_command_language = "French"
call SendToAllAIs(71,3)
call initLanguageFrench()
else
set udg_zz_command_language = "English"
call SendToAllAIs(71,0)
call initLanguageEnglish()
endif
call GameStartDlg()
endfunction
function LanguageDlg takes nothing returns nothing
local integer host = GetFirstHuman()
if host == -1 then
return
endif
set udg_zz_language_dialog = DialogCreate()
call DialogSetMessage(udg_zz_language_dialog, "Choose Language")
set udg_zz_english_button = DialogAddButton(udg_zz_language_dialog, "English", 69)
set udg_zz_deutsch_button = DialogAddButton(udg_zz_language_dialog, "Deutsch", 68)
set udg_zz_swedish_button = DialogAddButton(udg_zz_language_dialog, "Svenska", 83)
set udg_zz_french_button = DialogAddButton(udg_zz_language_dialog, "Francais", 70)
set udg_zz_language_trigger = CreateTrigger()
call TriggerRegisterDialogEvent(udg_zz_language_trigger, udg_zz_language_dialog)
call TriggerAddAction(udg_zz_language_trigger, function LanguageDlgResponse)
call DialogDisplay(Player(host), udg_zz_language_dialog, true)
endfunction
function InitCommander takes nothing returns nothing
local timer t = CreateTimer()
set udg_zz_observer_god = true
set udg_zz_command_length = 0
set udg_zz_command_prefix = "Cmd:"
set udg_zz_cdlg_length = 0
set udg_zz_current_command = 0
set udg_zz_current_player_par = 0
set udg_zz_current_number_par = 0
set udg_zz_tribute_type = ""
set udg_zz_tribute_amount = ""
set udg_zz_tribute_dlg_length = 0
set udg_zz_sdbn_length = 0
set udg_zz_pcbn_length = 0
set udg_zz_ndbn_length = 0
set udg_zz_dlg_length = 0
set udg_zz_dialog_in_use = false
set udg_zz_command_language = "English"
set udg_zz_chat_no_ally = ""
set udg_zz_dlghdr_choose_ally = ""
set udg_zz_dlghdr_choose_number = ""
set udg_zz_dlghdr_choose_player = ""
set udg_zz_dlghdr_game_type = ""
set udg_zz_dlghdr_root = ""
set udg_zz_dlghdr_tribute_type = ""
set udg_zz_dlghdr_tribute_amount = ""
set udg_zz_dlgbutton_cancel = ""
set udg_zz_dlgbutton_all = ""
set udg_zz_dlgbutton_gold = ""
set udg_zz_dlgbutton_lumber = ""
set udg_zz_dlgbutton_tribute = ""
set udg_zz_dlgbutton_commander = ""
set udg_zz_dlgbutton_no_human = ""
set udg_zz_dlgbutton_ai_only = ""
call TimerStart(t,1.0, false, function LanguageDlg)
endfunction
function DebugGimmeEnum takes nothing returns nothing
local player thePlayer = GetEnumPlayer()
call DisplayTextToPlayer(thePlayer, 0, 0, "Player "+I2S(GetPlayerId(GetTriggerPlayer())+1)+" cheated: Give 5000 gold and 5000 lumber to all players")
call SetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_GOLD) + 5000)
call SetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_LUMBER, GetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_LUMBER) + 5000)
endfunction
function DebugGimme takes nothing returns nothing
call ForForce(bj_FORCE_ALL_PLAYERS, function DebugGimmeEnum)
endfunction
function DebugDemoEnum takes nothing returns nothing
local player thePlayer = GetEnumPlayer()
call SetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_GOLD, 0)
call SetPlayerState(thePlayer, PLAYER_STATE_RESOURCE_LUMBER, 0)
endfunction
function DebugDemo takes nothing returns nothing
local player thePlayer = GetTriggerPlayer()
local integer gold = GetRandomInt(750, 1500)
local integer lumber = GetRandomInt(200, 450)
call ForForce(bj_FORCE_ALL_PLAYERS, function DebugDemoEnum)
call MultiboardSuppressDisplay(true)
if (GetLocalPlayer() == GetTriggerPlayer()) then
call Cheat("warnings")
call Cheat("fastbuild")
call Cheat("techtree")
call Cheat("research")
call Cheat("food")
call Cheat("mana")
call Cheat("dawn")
call Cheat("gold " + I2S(gold))
call Cheat("lumber " + I2S(lumber))
endif
endfunction
function DebugTeleportEnum takes nothing returns nothing
local unit u = GetEnumUnit()
call SetUnitPosition(u, GetCameraTargetPositionX(), GetCameraTargetPositionY())
endfunction
function DebugTeleport takes nothing returns nothing
local group g = CreateGroup()
call SyncSelections()
call GroupEnumUnitsSelected(g, GetTriggerPlayer(), null)
call ForGroup(g, function DebugTeleportEnum)
endfunction
function DebugUnitInfoEnum takes nothing returns nothing
local player thePlayer = GetTriggerPlayer()
local unit theUnit = GetEnumUnit()
local string message
set message = "Player " + I2S(GetPlayerId(GetOwningPlayer(theUnit))+1)
set message = message + " '" + DebugIdInteger2IdString(GetUnitTypeId(theUnit)) + "'"
set message = message + " " + GetUnitName(theUnit)
set message = message + " (" + R2SW(GetUnitX(theUnit), 0, 0) + ", " + R2SW(GetUnitY(theUnit), 0, 0)
set message = message + ": " + R2SW(GetUnitFacing(theUnit), 0, 0) + ") "
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_HERO), " Hero", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_DEAD), " Dead", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_STRUCTURE), " Structure", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_GROUND), " Grnd", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_FLYING), " Air", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_ATTACKS_GROUND), " VsGrnd", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_ATTACKS_FLYING), " VsAir", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_MELEE_ATTACKER), " Melee", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_RANGED_ATTACKER), " Ranged", "")
set message = message + TertiaryStringOp(IsUnitType(theUnit, UNIT_TYPE_SUMMONED), " Summoned", "")
call DisplayTextToPlayer(thePlayer, 0, 0, message)
endfunction
function DebugUnitInfo takes nothing returns nothing
local group g = CreateGroup()
call SyncSelections()
call GroupEnumUnitsSelected(g, GetTriggerPlayer(), null)
call ForGroup(g, function DebugUnitInfoEnum)
call DestroyGroup(g)
set g = null
endfunction
function DebugCamInfo takes nothing returns nothing
local player thePlayer = GetTriggerPlayer()
local string message
set message = "Targ(" + R2SW(GetCameraTargetPositionX(), 0, 0)
set message = message + "," + R2SW(GetCameraTargetPositionY(), 0, 0)
set message = message + "," + R2SW(GetCameraTargetPositionZ(), 0, 0)
set message = message + ")"
set message = message + ", Dist=" + R2SW(GetCameraField(CAMERA_FIELD_TARGET_DISTANCE), 0, 0)
set message = message + ", FarZ=" + R2SW(GetCameraField(CAMERA_FIELD_FARZ), 0, 0)
set message = message + ", AoA=" + R2SW(GetCameraField(CAMERA_FIELD_ANGLE_OF_ATTACK) * bj_RADTODEG, 0, 2)
set message = message + ", FoV=" + R2SW(GetCameraField(CAMERA_FIELD_FIELD_OF_VIEW) * bj_RADTODEG, 0, 2)
set message = message + ", Roll=" + R2SW(GetCameraField(CAMERA_FIELD_ROLL) * bj_RADTODEG, 0, 2)
set message = message + ", Rot=" + R2SW(GetCameraField(CAMERA_FIELD_ROTATION) * bj_RADTODEG, 0, 2)
call DisplayTextToPlayer(thePlayer, 0, 0, message)
endfunction
function DebugCamField takes camerafield whichField, integer cheatLength, real defaultValue returns nothing
local string param = SubString(GetEventPlayerChatString(), cheatLength, 50)
local real value = S2R(param)
loop
exitwhen not (SubString(param, 0, 1) == " ")
set param = SubString(param, 1, 50)
endloop
if param == "" then
set value = defaultValue
endif
if (whichField == CAMERA_FIELD_FARZ) and (value <= bj_CAMERA_MIN_FARZ) then
return
endif
call SetCameraFieldForPlayer(GetTriggerPlayer(), whichField, value, 0)
endfunction
function DebugCamDist takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_TARGET_DISTANCE, 7, 1600)
endfunction
function DebugCamFarZ takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_FARZ, 7, 4000)
endfunction
function DebugCamFOV takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_FIELD_OF_VIEW, 6, 65)
endfunction
function DebugCamAOA takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_ANGLE_OF_ATTACK, 6, 310)
endfunction
function DebugCamRoll takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_ROLL, 7, 0)
endfunction
function DebugCamRot takes nothing returns nothing
call DebugCamField(CAMERA_FIELD_ROTATION, 6, 90)
endfunction
function DebugCamReset takes nothing returns nothing
call ResetToGameCamera(0)
call EnableUserControl(true)
endfunction
function DebugCloneUnitEnum takes nothing returns nothing
local unit u = GetEnumUnit()
call CreateUnit(GetOwningPlayer(u), GetUnitTypeId(u), GetUnitX(u), GetUnitY(u), GetUnitFacing(u))
endfunction
function DebugCloneUnit takes nothing returns nothing
local group g = CreateGroup()
call SyncSelections()
call GroupEnumUnitsSelected(g, GetTriggerPlayer(), null)
call ForGroup(g, function DebugCloneUnitEnum)
call DestroyGroup(g)
set g = null
endfunction
function DebugDispelUnitEnum takes nothing returns nothing
call UnitRemoveBuffs(GetEnumUnit(), true, true)
endfunction
function DebugDispelUnit takes nothing returns nothing
local group g = CreateGroup()
call SyncSelections()
call GroupEnumUnitsSelected(g, GetTriggerPlayer(), null)
call ForGroup(g, function DebugDispelUnitEnum)
call DestroyGroup(g)
set g = null
endfunction
function DebugGotoX takes nothing returns nothing
local string chatString = GetEventPlayerChatString()
if ("gotox" + " " == SubString(chatString, 0, 6)) then
call SetCameraPositionForPlayer(GetTriggerPlayer(), S2R(SubString(chatString, 6, 50)), GetCameraTargetPositionY())
endif
endfunction
function DebugGotoY takes nothing returns nothing
local string chatString = GetEventPlayerChatString()
if ("gotoy" + " " == SubString(chatString, 0, 6)) then
call SetCameraPositionForPlayer(GetTriggerPlayer(), GetCameraTargetPositionX(), S2R(SubString(chatString, 6, 50)))
endif
endfunction
function DebugGotoXY takes nothing returns nothing
local string chatString = GetEventPlayerChatString()
local integer index
local boolean inParam1
if ("gotoxy" + " " == SubString(chatString, 0, 7)) then
set inParam1 = false
set index = 7
loop
if (SubString(chatString, index, index + 1) != " ") then
set inParam1 = true
endif
exitwhen (inParam1 and SubString(chatString, index, index + 1) == " ")
exitwhen index > 50
set index = index + 1
endloop
if (index > 50) then
call DisplayTextToPlayer(GetTriggerPlayer(), 0, 0, "Usage: GotoXY x y")
else
if (GetLocalPlayer() == GetTriggerPlayer()) then
call SetCameraPositionForPlayer(GetTriggerPlayer(), S2R(SubString(chatString, 7, index)), S2R(SubString(chatString, index, 50)))
endif
endif
endif
endfunction
function DebugGotoUnitEnum takes nothing returns nothing
local unit u = GetEnumUnit()
set udg_zz_debugGotoUnitX = udg_zz_debugGotoUnitX + GetUnitX(u)
set udg_zz_debugGotoUnitY = udg_zz_debugGotoUnitY + GetUnitY(u)
set udg_zz_debugGotoUnits = udg_zz_debugGotoUnits + 1
endfunction
function DebugGotoUnit takes nothing returns nothing
local group g = CreateGroup()
set udg_zz_debugGotoUnitX = 0
set udg_zz_debugGotoUnitY = 0
set udg_zz_debugGotoUnits = 0
call SyncSelections()
call GroupEnumUnitsSelected(g, GetTriggerPlayer(), null)
call ForGroup(g, function DebugGotoUnitEnum)
call DestroyGroup(g)
set g = null
if (udg_zz_debugGotoUnits != 0) then
set udg_zz_debugGotoUnitX = udg_zz_debugGotoUnitX / udg_zz_debugGotoUnits
set udg_zz_debugGotoUnitY = udg_zz_debugGotoUnitY / udg_zz_debugGotoUnits
call SetCameraPositionForPlayer(GetTriggerPlayer(), udg_zz_debugGotoUnitX, udg_zz_debugGotoUnitY)
endif
endfunction
function DebugBlackMask takes nothing returns nothing
call SetFogStateRect(GetTriggerPlayer(), FOG_OF_WAR_MASKED, GetWorldBounds(), true)
endfunction
function DebugDifficulty takes nothing returns nothing
local player thePlayer = GetTriggerPlayer()
local gamedifficulty theDiff = GetGameDifficulty()
if (theDiff == MAP_DIFFICULTY_EASY) then
call DisplayTextToPlayer(thePlayer, 0, 0, "Easy Difficulty")
elseif (theDiff == MAP_DIFFICULTY_NORMAL) then
call DisplayTextToPlayer(thePlayer, 0, 0, "Normal Difficulty")
elseif (theDiff == MAP_DIFFICULTY_HARD) then
call DisplayTextToPlayer(thePlayer, 0, 0, "Hard Difficulty")
else
call DisplayTextToPlayer(thePlayer, 0, 0, "ERROR! Unrecognized Difficulty")
endif
endfunction
function DebugToolOfDeath takes nothing returns nothing
call KillUnit(GetTriggerUnit())
endfunction
function DebugToggleFingerOfDeath takes nothing returns nothing
local integer index = GetPlayerId(GetTriggerPlayer())
if (udg_zz_debugFingerOfDeathEnabled[index]) then
call DisplayTextToPlayer(Player(index), 0, 0, "Finger Of Death Disabled")
call DisableTrigger(udg_zz_debugToolOfDeathTrig[index])
else
call DisplayTextToPlayer(Player(index), 0, 0, "Finger Of Death Enabled")
call EnableTrigger(udg_zz_debugToolOfDeathTrig[index])
endif
set udg_zz_debugFingerOfDeathEnabled[index] = not udg_zz_debugFingerOfDeathEnabled[index]
endfunction
function InitDebugTriggers takes nothing returns boolean
local player indexPlayer
local integer index
set udg_zz_debugGotoUnitX = 0
set udg_zz_debugGotoUnitY = 0
set udg_zz_debugGotoUnits = 0
set index = 0
loop
set indexPlayer = Player(index)
if (GetPlayerSlotState(indexPlayer) == PLAYER_SLOT_STATE_PLAYING) then
set udg_zz_debugGimmeTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugGimmeTrig, indexPlayer, "gimme", true)
call TriggerAddAction(udg_zz_debugGimmeTrig, function DebugGimme)
set udg_zz_debugDemoTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugDemoTrig, indexPlayer, "demo", true)
call TriggerAddAction(udg_zz_debugDemoTrig, function DebugDemo)
set udg_zz_debugTeleportTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugTeleportTrig, indexPlayer, "teleport", true)
call TriggerRegisterPlayerChatEvent(udg_zz_debugTeleportTrig, indexPlayer, "ttt", true)
call TriggerAddAction(udg_zz_debugTeleportTrig, function DebugTeleport)
set udg_zz_debugUnitInfoTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugUnitInfoTrig, indexPlayer, "unitinfo", true)
call TriggerRegisterPlayerChatEvent(udg_zz_debugUnitInfoTrig, indexPlayer, "ui", true)
call TriggerAddAction(udg_zz_debugUnitInfoTrig, function DebugUnitInfo)
set udg_zz_debugCamInfoTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamInfoTrig, indexPlayer, "caminfo", true)
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamInfoTrig, indexPlayer, "ci", true)
call TriggerAddAction(udg_zz_debugCamInfoTrig, function DebugCamInfo)
set udg_zz_debugCamDistTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamDistTrig, indexPlayer, "camdist", false)
call TriggerAddAction(udg_zz_debugCamDistTrig, function DebugCamDist)
set udg_zz_debugCamFarzTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamFarzTrig, indexPlayer, "camfarz", false)
call TriggerAddAction(udg_zz_debugCamFarzTrig, function DebugCamFarZ)
set udg_zz_debugCamFovTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamFovTrig, indexPlayer, "camfov", false)
call TriggerAddAction(udg_zz_debugCamFovTrig, function DebugCamFOV)
set udg_zz_debugCamAoaTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamAoaTrig, indexPlayer, "camaoa", false)
call TriggerAddAction(udg_zz_debugCamAoaTrig, function DebugCamAOA)
set udg_zz_debugCamRollTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamRollTrig, indexPlayer, "camroll", false)
call TriggerAddAction(udg_zz_debugCamRollTrig, function DebugCamRoll)
set udg_zz_debugCamRotTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamRotTrig, indexPlayer, "camrot", false)
call TriggerAddAction(udg_zz_debugCamRotTrig, function DebugCamRot)
set udg_zz_debugCamResetTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCamResetTrig, indexPlayer, "camreset", true)
call TriggerAddAction(udg_zz_debugCamResetTrig, function DebugCamReset)
set udg_zz_debugCloneTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugCloneTrig, indexPlayer, "clone", true)
call TriggerAddAction(udg_zz_debugCloneTrig, function DebugCloneUnit)
set udg_zz_debugDispelTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugDispelTrig, indexPlayer, "dispel", true)
call TriggerAddAction(udg_zz_debugDispelTrig, function DebugDispelUnit)
set udg_zz_debugGotoXTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugGotoXTrig, indexPlayer, "gotox", false)
call TriggerAddAction(udg_zz_debugGotoXTrig, function DebugGotoX)
set udg_zz_debugGotoYTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugGotoYTrig, indexPlayer, "gotoy", false)
call TriggerAddAction(udg_zz_debugGotoYTrig, function DebugGotoY)
set udg_zz_debugGotoXYTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugGotoXYTrig, indexPlayer, "gotoxy", false)
call TriggerAddAction(udg_zz_debugGotoXYTrig, function DebugGotoXY)
set udg_zz_debugGotoUnitTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugGotoUnitTrig, indexPlayer, "gotounit", true)
call TriggerAddAction(udg_zz_debugGotoUnitTrig, function DebugGotoUnit)
set udg_zz_debug_BlackMaskTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debug_BlackMaskTrig, indexPlayer, "blackmask", true)
call TriggerRegisterPlayerChatEvent(udg_zz_debug_BlackMaskTrig, indexPlayer, "bm", true)
call TriggerAddAction(udg_zz_debug_BlackMaskTrig, function DebugBlackMask)
set udg_zz_debugDifficultyTrig = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugDifficultyTrig, indexPlayer, "difficulty", true)
call TriggerAddAction(udg_zz_debugDifficultyTrig, function DebugDifficulty)
set udg_zz_debugFingerOfDeathEnabled[index] = false
set udg_zz_debugToolOfDeathTrig[index] = CreateTrigger()
call TriggerRegisterPlayerUnitEvent(udg_zz_debugToolOfDeathTrig[index], indexPlayer, EVENT_PLAYER_UNIT_SELECTED, null)
call TriggerAddAction(udg_zz_debugToolOfDeathTrig[index], function DebugToolOfDeath)
call DisableTrigger(udg_zz_debugToolOfDeathTrig[index])
set udg_zz_debugFingerOfDeathTrig[index] = CreateTrigger()
call TriggerRegisterPlayerChatEvent(udg_zz_debugFingerOfDeathTrig[index], indexPlayer, "fingerofdeath", true)
call TriggerAddAction(udg_zz_debugFingerOfDeathTrig[index], function DebugToggleFingerOfDeath)
endif
set index = index + 1
exitwhen index == bj_MAX_PLAYERS
endloop
return true
endfunction
function Slot0Condition takes nothing returns boolean
return GetIssuedOrderId() == 852002
endfunction
function Slot1Condition takes nothing returns boolean
return GetIssuedOrderId() == 852003
endfunction
function Slot2Condition takes nothing returns boolean
return GetIssuedOrderId() == 852004
endfunction
function Slot3Condition takes nothing returns boolean
return GetIssuedOrderId() == 852005
endfunction
function Slot4Condition takes nothing returns boolean
return GetIssuedOrderId() == 852006
endfunction
function Slot5Condition takes nothing returns boolean
return GetIssuedOrderId() == 852007
endfunction
function AddMoveSlotEvent takes trigger T, integer Slot returns nothing
call TriggerRegisterAnyUnitEventBJ(T,EVENT_PLAYER_UNIT_ISSUED_TARGET_ORDER)
if Slot <= 1 then
call TriggerAddCondition(T,Condition(function Slot0Condition))
elseif Slot == 2 then
call TriggerAddCondition(T,Condition(function Slot1Condition))
elseif Slot == 3 then
call TriggerAddCondition(T,Condition(function Slot2Condition))
elseif Slot == 4 then
call TriggerAddCondition(T,Condition(function Slot3Condition))
elseif Slot == 5 then
call TriggerAddCondition(T,Condition(function Slot4Condition))
else
call TriggerAddCondition(T,Condition(function Slot5Condition))
endif
endfunction
function WaitForMoveSlotEvent takes integer Slot, real Time returns nothing
local trigger T = CreateTrigger()
call AddMoveSlotEvent(T,Slot)
loop
call PolledWait(Time)
exitwhen GetTriggerExecCount(T) > 0
endloop
call DestroyTrigger(T)
set T = null
endfunction
function IsLocPathable takes location l returns boolean
local real x = GetLocationX(l)
local real y = GetLocationY(l)
local real ad = ((GetCameraBoundMaxX()+GetCameraMargin(CAMERA_MARGIN_RIGHT)) - (GetCameraBoundMinX()-GetCameraMargin(CAMERA_MARGIN_LEFT))) / 720
local unit u = CreateUnit(Player(PLAYER_NEUTRAL_PASSIVE),'odoc',x,y,0)
call ShowUnit(u,false)
call UnitAddAbility(u,'Aeye')
if (GetUnitX(u) > x + ad) or (GetUnitX(u) < x - ad) or (GetUnitY(u) > y + ad) or (GetUnitY(u) < y - ad) then
call RemoveUnit(u)
return false
elseif IssuePointOrder(u,"evileye",x,y) then
call RemoveUnit(u)
return true
endif
call RemoveUnit(u)
return false
endfunction
function CinematicFilterGenericForPlayer takes player whichPlayer, real duration, blendmode bmode, string tex, real red0, real green0, real blue0, real trans0, real red1, real green1, real blue1, real trans1 returns nothing
if GetLocalPlayer() == whichPlayer then
call SetCineFilterTexture(tex)
call SetCineFilterBlendMode(bmode)
call SetCineFilterTexMapFlags(TEXMAP_FLAG_NONE)
call SetCineFilterStartUV(0, 0, 1, 1)
call SetCineFilterEndUV(0, 0, 1, 1)
call SetCineFilterStartColor(PercentTo255(red0), PercentTo255(green0), PercentTo255(blue0), PercentTo255(100-trans0))
call SetCineFilterEndColor(PercentTo255(red1), PercentTo255(green1), PercentTo255(blue1), PercentTo255(100-trans1))
call SetCineFilterDuration(duration)
call DisplayCineFilter(true)
endif
endfunction
function GetRandomPathableLoc takes rect R, integer MaxAttempts returns location
local location L
local integer Index = 0
if MaxAttempts < 1 then
set MaxAttempts = 50
endif
loop
exitwhen Index >= MaxAttempts
set L = GetRandomLocInRect(R)
if IsLocPathable(L) then
return L
endif
set Index = Index + 1
endloop
return Location(0,0)
endfunction
function GetUnitGoldCostById takes integer Uid returns integer
local string Temp = DebugIdInteger2IdString(Uid)
local integer Val = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
local integer ValB = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
local integer Cap = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP)
local integer Diff
local unit U
set Temp = SubStringBJ(Temp,1,1)
if Temp == "E" or Temp == "U" or Temp == "O" or Temp == "H" then
return 425
endif
set U = CreateUnitAtLoc(Player(15),'nshf',GetRandomPathableLoc(GetPlayableMapRect(),50),bj_UNIT_FACING)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_GOLD)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP,200)
set Diff = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
call UnitAddAbilityBJ('Asud',U)
call AddUnitToStockBJ(Uid,U,1,1)
call IssueTrainOrderByIdBJ(U,Uid)
set Diff = Diff - GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD,Val)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER,ValB)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP,Cap)
return Diff
endfunction
function GetUnitWoodCostById takes integer Uid returns integer
local string Temp = DebugIdInteger2IdString(Uid)
local integer Val = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
local integer ValB = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
local integer Cap = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP)
local integer Diff
local unit U
set Temp = SubStringBJ(Temp,1,1)
if Temp == "E" or Temp == "U" or Temp == "O" or Temp == "H" then
return 100
endif
set U = CreateUnitAtLoc(Player(15),'nshf',GetRandomPathableLoc(GetPlayableMapRect(),50),bj_UNIT_FACING)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_GOLD)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP,200)
set Diff = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call UnitAddAbilityBJ('Asud',U)
call AddUnitToStockBJ(Uid,U,1,1)
call IssueTrainOrderByIdBJ(U,Uid)
set Diff = Diff - GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD,Val)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER,ValB)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_FOOD_CAP,Cap)
return Diff
endfunction
function GetItemGoldCostById takes integer Uid returns integer
local integer Val = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
local integer ValB = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
local integer Diff
local unit U = CreateUnitAtLoc(Player(15),'nshe',GetRectCenter(GetPlayableMapRect()),bj_UNIT_FACING)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_GOLD)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call UnitAddAbilityBJ('Asid',U)
set Diff = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
call AddItemToStockBJ(Uid,U,1,1)
call IssueTrainOrderByIdBJ(U,Uid)
set Diff = Diff - GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD,Val)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER,ValB)
call RemoveItem(FindNextItem(GetUnitLoc(U)))
call RemoveUnit(U)
return Diff
endfunction
function GetItemWoodCostById takes integer Uid returns integer
local integer Val = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD)
local integer ValB = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
local integer Diff
local unit U = CreateUnitAtLoc(Player(15),'nshe',GetRectCenter(GetPlayableMapRect()),bj_UNIT_FACING)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_GOLD)
call AdjustPlayerStateBJ(50000,Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call UnitAddAbilityBJ('Asid',U)
set Diff = GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call AddItemToStockBJ(Uid,U,1,1)
call IssueTrainOrderByIdBJ(U,Uid)
set Diff = Diff - GetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_GOLD,Val)
call SetPlayerState(Player(15),PLAYER_STATE_RESOURCE_LUMBER,ValB)
call RemoveItem(FindNextItem(GetUnitLoc(U)))
call RemoveUnit(U)
return Diff
endfunction
function StartSpellEnhancer takes nothing returns nothing
local trigger SEOrderTrigger = CreateTrigger()
call AddAnyUnitIssuedAnyOrderEvent(SEOrderTrigger)
call TriggerAddCondition(SEOrderTrigger, Condition(function Enhancer_Conditions))
call TriggerAddAction(SEOrderTrigger, function Enhancer_Actions)
endfunction
function AdvancedBJInit takes nothing returns nothing
local integer Index = 0
local group G = CreateGroup()
local unit dummy = CreateUnit(Player(15),'hfoo',0,0,0)
local trigger XPickup = CreateTrigger()
local trigger XDrop = CreateTrigger()
local trigger XSellunit = CreateTrigger()
local trigger XSellitem = CreateTrigger()
local trigger XConstruction = CreateTrigger()
local trigger XSummon = CreateTrigger()
local trigger XSkill = CreateTrigger()
local trigger XResearch = CreateTrigger()
local trigger XTrain = CreateTrigger()
local trigger Bau = CreateTrigger()
local trigger Bauende = CreateTrigger()
local trigger Upgrade = CreateTrigger()
local trigger Upgradeende = CreateTrigger()
local trigger Beschwoerung = CreateTrigger()
local trigger Tod = CreateTrigger()
local trigger HeroSelection = CreateTrigger()
call ShowUnitHide(dummy)
set udg_zz_DetectSelected = 0
set udg_zz_DetectRandom = 0
set udg_zz_SEAnzahl = 0
set udg_zz_SEIndex = 0
set udg_zz_MJPlayerPointer = 0
set udg_zz_CamPidIndex = 0
set udg_zz_TimerCounter = 0
set udg_zz_StimmenAbgegeben = 0
set udg_zz_DamageTaken = 0
set udg_zz_MovingSFXLength = 0
set udg_zz_GewitterBlitze = 0
set udg_zz_ClosestDistance = 1000000
set udg_zz_MissileLength = 76
set udg_zz_UnitIndex = 0
set udg_zz_ItemIndex = 0
set udg_zz_ErweckteIndex = 0
set udg_zz_UnfertigeUpgradesIndex = 0
set udg_zz_UnfertigeGebIndex = 0
set udg_zz_NoBuildIndex = 0
set udg_zz_LastCreatedMovingSFX = 0
set udg_zz_Empty0p5 = CreateSound("Sounds\\empty0p5.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty1 = CreateSound("Sounds\\empty1.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty1p5 = CreateSound("Sounds\\empty1p5.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty2 = CreateSound("Sounds\\empty2.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty2p5 = CreateSound("Sounds\\empty2p5.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty3 = CreateSound("Sounds\\empty3.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty4 = CreateSound("Sounds\\empty4.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty5 = CreateSound("Sounds\\empty5.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty6 = CreateSound("Sounds\\empty6.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty7 = CreateSound("Sounds\\empty7.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty8 = CreateSound("Sounds\\empty8.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty9 = CreateSound("Sounds\\empty9.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty10 = CreateSound("Sounds\\empty10.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty11 = CreateSound("Sounds\\empty11.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty12 = CreateSound("Sounds\\empty12.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty14 = CreateSound("Sounds\\empty14.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty16 = CreateSound("Sounds\\empty16.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty18 = CreateSound("Sounds\\empty18.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty20 = CreateSound("Sounds\\empty20.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty22 = CreateSound("Sounds\\empty22.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty24 = CreateSound("Sounds\\empty24.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty26 = CreateSound("Sounds\\empty26.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty28 = CreateSound("Sounds\\empty28.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty30 = CreateSound("Sounds\\empty30.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_Empty32 = CreateSound("Sounds\\empty32.mp3",false,false,false,10,10,"DefaultEAXON")
set udg_zz_DefendCaster = CreateSound("Abilities\\Spells\\Human\\Defend\\DefendCaster.wav", false, true, true, 10, 10, "SpellsEAX")
set udg_zz_DivineShield = CreateSound("Abilities\\Spells\\Human\\DivineShield\\DivineShield.wav", false, true, true, 10, 10, "SpellsEAX")
set udg_zz_MovSidewards = CreateTrigger()
set udg_zz_MovForward = CreateTrigger()
set udg_zz_PressUp = CreateTrigger()
set udg_zz_ReleaseUp = CreateTrigger()
set udg_zz_PressLeft = CreateTrigger()
set udg_zz_ReleaseLeft = CreateTrigger()
set udg_zz_PressRight = CreateTrigger()
set udg_zz_ReleaseRight = CreateTrigger()
set udg_zz_PressDown = CreateTrigger()
set udg_zz_HeroDiedMsg = CreateTrigger()
set udg_zz_PlayerLeftMsg = CreateTrigger()
set udg_zz_RegrowingTrees = CreateTrigger()
set udg_zz_ActionAndTrig = CreateTrigger()
set udg_zz_TrigAlways = CreateTrigger()
set udg_zz_AnyDamageTrig = CreateTrigger()
set udg_zz_HeroChoice = CreateTrigger()
set udg_zz_SelectableHeros = CreateGroup()
set udg_zz_CodeRow = "QmxJBhHeCgKyZpfkaNds"
set udg_zz_ManaRegenUpgr[0] = 'Rx2G'
set udg_zz_ManaRegenUpgr[1] = 'Rx2I'
set udg_zz_ManaRegenUpgr[2] = 'Rx2M'
set udg_zz_ManaRegenUpgr[3] = 'Rx2K'
set udg_zz_ManaRegenUpgr[4] = 'Rx05'
set udg_zz_ManaRegenUpgr[5] = 'Rx10'
set udg_zz_ManaRegenUpgr[6] = 'Rx14'
set udg_zz_ManaRegenUpgr[7] = 'Rx12'
set udg_zz_ManaRegenUpgr[8] = 'Rx2H'
set udg_zz_ManaRegenUpgr[9] = 'Rx2J'
set udg_zz_ManaRegenUpgr[10] = 'Rx2N'
set udg_zz_ManaRegenUpgr[11] = 'Rx2L'
set udg_zz_ManaRegenUpgr[12] = 'Rx0Z'
set udg_zz_ManaRegenUpgr[13] = 'Rx11'
set udg_zz_ManaRegenUpgr[14] = 'Rx15'
set udg_zz_ManaRegenUpgr[15] = 'Rx13'
set udg_zz_LifeRegenUpgr[0] = 'Rx28'
set udg_zz_LifeRegenUpgr[1] = 'Rx2A'
set udg_zz_LifeRegenUpgr[2] = 'Rx2E'
set udg_zz_LifeRegenUpgr[3] = 'Rx2C'
set udg_zz_LifeRegenUpgr[4] = 'Rx01'
set udg_zz_LifeRegenUpgr[5] = 'Rx0T'
set udg_zz_LifeRegenUpgr[6] = 'Rx0X'
set udg_zz_LifeRegenUpgr[7] = 'Rx0V'
set udg_zz_LifeRegenUpgr[8] = 'Rx29'
set udg_zz_LifeRegenUpgr[9] = 'Rx2B'
set udg_zz_LifeRegenUpgr[10] = 'Rx2F'
set udg_zz_LifeRegenUpgr[11] = 'Rx2D'
set udg_zz_LifeRegenUpgr[12] = 'Rx0S'
set udg_zz_LifeRegenUpgr[13] = 'Rx0U'
set udg_zz_LifeRegenUpgr[14] = 'Rx0Y'
set udg_zz_LifeRegenUpgr[15] = 'Rx0W'
set udg_zz_AttackDiceUpgr[0] = 'Rx1K'
set udg_zz_AttackDiceUpgr[1] = 'Rx1M'
set udg_zz_AttackDiceUpgr[2] = 'Rx1Q'
set udg_zz_AttackDiceUpgr[3] = 'Rx1O'
set udg_zz_AttackDiceUpgr[4] = 'Rx00'
set udg_zz_AttackDiceUpgr[5] = 'Rx08'
set udg_zz_AttackDiceUpgr[6] = 'Rx0C'
set udg_zz_AttackDiceUpgr[7] = 'Rx0A'
set udg_zz_AttackDiceUpgr[8] = 'Rx1L'
set udg_zz_AttackDiceUpgr[9] = 'Rx1N'
set udg_zz_AttackDiceUpgr[10] = 'Rx1R'
set udg_zz_AttackDiceUpgr[11] = 'Rx1P'
set udg_zz_AttackDiceUpgr[12] = 'Rx07'
set udg_zz_AttackDiceUpgr[13] = 'Rx09'
set udg_zz_AttackDiceUpgr[14] = 'Rx0D'
set udg_zz_AttackDiceUpgr[15] = 'Rx0B'
set udg_zz_RangeUpgr[0] = 'Rx2W'
set udg_zz_RangeUpgr[1] = 'Rx2Y'
set udg_zz_RangeUpgr[2] = 'Rx32'
set udg_zz_RangeUpgr[3] = 'Rx30'
set udg_zz_RangeUpgr[4] = 'Rx02'
set udg_zz_RangeUpgr[5] = 'Rx1E'
set udg_zz_RangeUpgr[6] = 'Rx1I'
set udg_zz_RangeUpgr[7] = 'Rx1G'
set udg_zz_RangeUpgr[8] = 'Rx2X'
set udg_zz_RangeUpgr[9] = 'Rx2Z'
set udg_zz_RangeUpgr[10] = 'Rx33'
set udg_zz_RangeUpgr[11] = 'Rx31'
set udg_zz_RangeUpgr[12] = 'Rx1D'
set udg_zz_RangeUpgr[13] = 'Rx4F'
set udg_zz_RangeUpgr[14] = 'Rx4J'
set udg_zz_RangeUpgr[15] = 'Rx4H'
set udg_zz_AttackRateUpgr[0] = 'Rx1S'
set udg_zz_AttackRateUpgr[1] = 'Rx1U'
set udg_zz_AttackRateUpgr[2] = 'Rx1Y'
set udg_zz_AttackRateUpgr[3] = 'Rx1W'
set udg_zz_AttackRateUpgr[4] = 'Rx04'
set udg_zz_AttackRateUpgr[5] = 'Rx0F'
set udg_zz_AttackRateUpgr[6] = 'Rx0J'
set udg_zz_AttackRateUpgr[7] = 'Rx0H'
set udg_zz_AttackRateUpgr[8] = 'Rx1T'
set udg_zz_AttackRateUpgr[9] = 'Rx1V'
set udg_zz_AttackRateUpgr[10] = 'Rx1Z'
set udg_zz_AttackRateUpgr[11] = 'Rx1X'
set udg_zz_AttackRateUpgr[12] = 'Rx0E'
set udg_zz_AttackRateUpgr[13] = 'Rx0G'
set udg_zz_AttackRateUpgr[14] = 'Rx0K'
set udg_zz_AttackRateUpgr[15] = 'Rx0I'
set udg_zz_MoveRateUpgr[0] = 'Rx2O'
set udg_zz_MoveRateUpgr[1] = 'Rx2Q'
set udg_zz_MoveRateUpgr[2] = 'Rx2U'
set udg_zz_MoveRateUpgr[3] = 'Rx2S'
set udg_zz_MoveRateUpgr[4] = 'Rx03'
set udg_zz_MoveRateUpgr[5] = 'Rx17'
set udg_zz_MoveRateUpgr[6] = 'Rx1B'
set udg_zz_MoveRateUpgr[7] = 'Rx19'
set udg_zz_MoveRateUpgr[8] = 'Rx2P'
set udg_zz_MoveRateUpgr[9] = 'Rx2R'
set udg_zz_MoveRateUpgr[10] = 'Rx2V'
set udg_zz_MoveRateUpgr[11] = 'Rx2T'
set udg_zz_MoveRateUpgr[12] = 'Rx16'
set udg_zz_MoveRateUpgr[13] = 'Rx18'
set udg_zz_MoveRateUpgr[14] = 'Rx1C'
set udg_zz_MoveRateUpgr[15] = 'Rx1A'
set udg_zz_TargetUpgr[0] = 'Rx20'
set udg_zz_TargetUpgr[1] = 'Rx22'
set udg_zz_TargetUpgr[2] = 'Rx26'
set udg_zz_TargetUpgr[3] = 'Rx24'
set udg_zz_TargetUpgr[4] = 'Rx06'
set udg_zz_TargetUpgr[5] = 'Rx0M'
set udg_zz_TargetUpgr[6] = 'Rx0R'
set udg_zz_TargetUpgr[7] = 'Rx0O'
set udg_zz_TargetUpgr[8] = 'Rx21'
set udg_zz_TargetUpgr[9] = 'Rx23'
set udg_zz_TargetUpgr[10] = 'Rx27'
set udg_zz_TargetUpgr[11] = 'Rx25'
set udg_zz_TargetUpgr[12] = 'Rx0L'
set udg_zz_TargetUpgr[13] = 'Rx0N'
set udg_zz_TargetUpgr[14] = 'Rx0Q'
set udg_zz_TargetUpgr[15] = 'Rx0P'
set udg_zz_BnsBit[0]='Ax0K'
set udg_zz_BnsBit[1]='Ax0L'
set udg_zz_BnsBit[2]='Ax0M'
set udg_zz_BnsBit[3]='Ax0N'
set udg_zz_BnsBit[4]='Ax0O'
set udg_zz_BnsBit[5]='Ax0P'
set udg_zz_BnsBit[6]='Ax0Q'
set udg_zz_BnsBit[7]='Ax0R'
set udg_zz_BnsBit[8]='Ax0S'
set udg_zz_BnsBit[9]='Ax0T'
set udg_zz_BnsBit[10]='Ax0U'
set udg_zz_BnsBit[11]='Ax0V'
set udg_zz_BnsBit[12]='Ax0W'
set udg_zz_BnsBit[13]='Ax0X'
set udg_zz_BnsBit[14]='Ax0Y'
set udg_zz_BnsBit[15]='Ax0Z'
set udg_zz_BnsBit[16]='Ax10'
set udg_zz_BnsBit[17]='Ax11'
set udg_zz_BnsBit[18]='Ax12'
set udg_zz_BnsBit[19]='Ax13'
set udg_zz_BnsBit[20]='Ax14'
set udg_zz_BnsBit[21]='Ax15'
set udg_zz_BnsBit[22]='Ax16'
set udg_zz_BnsBit[23]='Ax17'
set udg_zz_BnsBit[24]='Ax18'
set udg_zz_BnsBit[25]='Ax19'
set udg_zz_BnsBit[26]='Ax1A'
set udg_zz_BnsBit[27]='Ax1B'
set udg_zz_BnsBit[28]='Ax1C'
set udg_zz_BnsBit[29]='Ax1D'
set udg_zz_BnsBit[30]='Ax1E'
set udg_zz_BnsBit[31]='Ax1F'
set udg_zz_BnsBit[32]='Ax1G'
set udg_zz_BnsBit[33]='Ax1H'
set udg_zz_BnsBit[34]='Ax1I'
set udg_zz_BnsBit[35]='Ax1J'
set udg_zz_BnsBit[36]='Ax1K'
set udg_zz_BnsBit[37]='Ax1L'
set udg_zz_BnsBit[38]='Ax1M'
set udg_zz_BnsBit[39]='Ax1N'
set udg_zz_BnsBit[40]='Ax1O'
set udg_zz_BnsBit[41]='Ax1P'
set udg_zz_BnsBit[42]='Ax1Q'
set udg_zz_BnsBit[43]='Ax1R'
set udg_zz_BnsBit[44]='Ax1S'
set udg_zz_BnsBit[45]='Ax1T'
set udg_zz_BnsBit[46]='Ax1U'
set udg_zz_BnsBit[47]='Ax1V'
set udg_zz_BnsBit[48]='Ax1W'
set udg_zz_BnsBit[49]='Ax1X'
set udg_zz_BnsBit[50]='Ax1Y'
set udg_zz_BnsBit[51]='Ax1Z'
set udg_zz_BnsBit[52]='Ax20'
set udg_zz_BnsBit[53]='Ax21'
set udg_zz_BnsBit[54]='Ax22'
set udg_zz_BnsBit[55]='Ax23'
set udg_zz_BnsBit[56]='Ax24'
set udg_zz_BnsBit[57]='Ax25'
set udg_zz_BnsBit[58]='Ax26'
set udg_zz_BnsBit[59]='Ax27'
set udg_zz_BnsBit[60]='Ax28'
set udg_zz_BnsBit[61]='Ax29'
set udg_zz_BnsBit[62]='Ax2A'
set udg_zz_BnsBit[63]='Ax2B'
set udg_zz_BnsBit[64]='Ax2C'
set udg_zz_BnsBit[65]='Ax2D'
set udg_zz_BnsBit[66]='Ax2E'
set udg_zz_BnsBit[67]='Ax2F'
set udg_zz_BnsBit[68]='Ax2G'
set udg_zz_BnsBit[69]='Ax2H'
set udg_zz_BnsBit[70]='Ax2I'
set udg_zz_BnsBit[71]='Ax2J'
set udg_zz_SEId[0] = 'dumm'
set udg_zz_SEOrder[0] = "hallo"
set udg_zz_SECastingType[0] = 'dumm'
set udg_zz_SEMana[0] = 5
set udg_zz_SERange[0] = 0
set udg_zz_SEFunc[0] = ""
set udg_zz_MissileUnitType[0] = 'oang'
set udg_zz_MissileModel[0] = "Abilities\\Weapons\\AncestralGuardianMissile\\AncestralGuardianMissile.mdl"
set udg_zz_MissileOrder[0] = "attack"
set udg_zz_MissileUnitType[1] = 'etrp'
set udg_zz_MissileModel[1] = "Abilities\\Weapons\\AncientProtectorMissile\\AncientProtectorMissile.mdl"
set udg_zz_MissileOrder[1] = "attack"
set udg_zz_MissileUnitType[2] = 'earc'
set udg_zz_MissileModel[2] = "Abilities\\Weapons\\Arrow\\ArrowMissile.mdl"
set udg_zz_MissileOrder[2] = "attack"
set udg_zz_MissileUnitType[3] = 'okod'
set udg_zz_MissileModel[3] = "Abilities\\Weapons\\Axe\\AxeMissile.mdl"
set udg_zz_MissileOrder[3] = "attack"
set udg_zz_MissileUnitType[4] = 'ebal'
set udg_zz_MissileModel[4] = "Abilities\\Weapons\\BallistaMissile\\BallistaMissile.mdl"
set udg_zz_MissileOrder[4] = "attack"
set udg_zz_MissileUnitType[5] = 'nbrg'
set udg_zz_MissileModel[5] = "Abilities\\Weapons\\Banditmissile\\Banditmissile.mdl"
set udg_zz_MissileOrder[5] = "attack"
set udg_zz_MissileUnitType[6] = 'uban'
set udg_zz_MissileModel[6] = "Abilities\\Weapons\\BansheeMissile\\BansheeMissile.mdl"
set udg_zz_MissileOrder[6] = "attack"
set udg_zz_MissileUnitType[7] = 'nsts'
set udg_zz_MissileModel[7] = "Abilities\\Weapons\\BlackKeeperMissile\\BlackKeeperMissile.mdl"
set udg_zz_MissileOrder[7] = "attack"
set udg_zz_MissileUnitType[8] = 'nrzt'
set udg_zz_MissileModel[8] = "Abilities\\Weapons\\BristleBackMissile\\BristleBackMissile.mdl"
set udg_zz_MissileOrder[8] = "attack"
set udg_zz_MissileUnitType[9] = 'hctw'
set udg_zz_MissileModel[9] = "Abilities\\Weapons\\CannonTowerMissile\\CannonTowerMissile.mdl"
set udg_zz_MissileOrder[9] = "attack"
set udg_zz_MissileUnitType[10] = 'ocat'
set udg_zz_MissileModel[10] = "Abilities\\Weapons\\Catapult\\CatapultMissile.mdl"
set udg_zz_MissileOrder[10] = "attack"
set udg_zz_MissileUnitType[11] = 'nssp'
set udg_zz_MissileModel[11] = "Abilities\\Weapons\\ChimaeraAcidMissile\\ChimaeraAcidMissile.mdl"
set udg_zz_MissileOrder[11] = "attack"
set udg_zz_MissileUnitType[12] = 'nstw'
set udg_zz_MissileModel[12] = "Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl"
set udg_zz_MissileOrder[12] = "attack"
set udg_zz_MissileUnitType[13] = 'nskm'
set udg_zz_MissileModel[13] = "Abilities\\Weapons\\ColdArrow\\ColdArrowMissile.mdl"
set udg_zz_MissileOrder[13] = "attack"
set udg_zz_MissileUnitType[14] = 'nnwq'
set udg_zz_MissileModel[14] = "Abilities\\Weapons\\CryptFiendMissile\\CryptFiendMissile.mdl"
set udg_zz_MissileOrder[14] = "attack"
set udg_zz_MissileUnitType[15] = 'nbal'
set udg_zz_MissileModel[15] = "Abilities\\Weapons\\DemonHunterMissile\\DemonHunterMissile.mdl"
set udg_zz_MissileOrder[15] = "attack"
set udg_zz_MissileUnitType[16] = 'nws2'
set udg_zz_MissileModel[16] = "Abilities\\Weapons\\DragonHawkMissile\\DragonHawkMissile.mdl"
set udg_zz_MissileOrder[16] = "attack"
set udg_zz_MissileUnitType[17] = 'edtm'
set udg_zz_MissileModel[17] = "Abilities\\Weapons\\DruidoftheTalonMissile\\DruidoftheTalonMissile.mdl"
set udg_zz_MissileOrder[17] = "attack"
set udg_zz_MissileUnitType[18] = 'edry'
set udg_zz_MissileModel[18] = "Abilities\\Weapons\\Dryadmissile\\Dryadmissile.mdl"
set udg_zz_MissileOrder[18] = "attack"
set udg_zz_MissileUnitType[19] = 'nfrs'
set udg_zz_MissileModel[19] = "Abilities\\Weapons\\FarseerMissile\\FarseerMissile.mdl"
set udg_zz_MissileOrder[19] = "attack"
set udg_zz_MissileUnitType[20] = 'nkog'
set udg_zz_MissileModel[20] = "Abilities\\Weapons\\FireBallMissile\\FireBallMissile.mdl"
set udg_zz_MissileOrder[20] = "attack"
set udg_zz_MissileUnitType[21] = 'nith'
set udg_zz_MissileModel[21] = "Abilities\\Weapons\\LichMissile\\LichMissile.mdl"
set udg_zz_MissileOrder[21] = "attack"
set udg_zz_MissileUnitType[22] = 'umtw'
set udg_zz_MissileModel[22] = "Abilities\\Weapons\\MeatwagonMissile\\MeatwagonMissile.mdl"
set udg_zz_MissileOrder[22] = "attack"
set udg_zz_MissileUnitType[23] = 'owyv'
set udg_zz_MissileModel[23] = "Abilities\\Weapons\\WyvernSpear\\WyvernSpearMissile.mdl"
set udg_zz_MissileOrder[23] = "attack"
set udg_zz_MissileUnitType[24] = 'Emoo'
set udg_zz_MissileModel[24] = "Abilities\\Weapons\\MoonPriestessMissile\\MoonPriestessMissile.mdl"
set udg_zz_MissileOrder[24] = "attack"
set udg_zz_MissileUnitType[25] = 'hmtm'
set udg_zz_MissileModel[25] = "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
set udg_zz_MissileOrder[25] = "attack"
set udg_zz_MissileUnitType[26] = 'Ekee'
set udg_zz_MissileModel[26] = "Abilities\\Weapons\\KeeperGroveMissile\\KeeperGroveMissile.mdl"
set udg_zz_MissileOrder[26] = "attack"
set udg_zz_MissileUnitType[27] = 'nhfp'
set udg_zz_MissileModel[27] = "Abilities\\Weapons\\NecromancerMissile\\NecromancerMissile.mdl"
set udg_zz_MissileOrder[27] = "attack"
set udg_zz_MissileUnitType[28] = 'ngns'
set udg_zz_MissileModel[28] = "Abilities\\Weapons\\PoisonArrow\\PoisonArrowMissile.mdl"
set udg_zz_MissileOrder[28] = "attack"
set udg_zz_MissileUnitType[29] = 'ohun'
set udg_zz_MissileModel[29] = "Abilities\\Weapons\\huntermissile\\huntermissile.mdl"
set udg_zz_MissileOrder[29] = "attack"
set udg_zz_MissileUnitType[30] = 'nwiz'
set udg_zz_MissileModel[30] = "Abilities\\Weapons\\PriestMissile\\PriestMissile.mdl"
set udg_zz_MissileOrder[30] = "attack"
set udg_zz_MissileUnitType[31] = 'nhar'
set udg_zz_MissileModel[31] = "Abilities\\Weapons\\HarpyMissile\\HarpyMissile.mdl"
set udg_zz_MissileOrder[31] = "attack"
set udg_zz_MissileUnitType[32] = 'nsll'
set udg_zz_MissileModel[32] = "Abilities\\Weapons\\RedDragonBreath\\RedDragonMissile.mdl"
set udg_zz_MissileOrder[32] = "attack"
set udg_zz_MissileUnitType[33] = 'nggr'
set udg_zz_MissileModel[33] = "Abilities\\Weapons\\RockBoltMissile\\RockBoltMissile.mdl"
set udg_zz_MissileOrder[33] = "creepthunderbolt"
set udg_zz_MissileUnitType[34] = 'nskf'
set udg_zz_MissileModel[34] = "Abilities\\Weapons\\SearingArrow\\SearingArrowMissile.mdl"
set udg_zz_MissileOrder[34] = "attack"
set udg_zz_MissileUnitType[35] = 'esen'
set udg_zz_MissileModel[35] = "Abilities\\Weapons\\SentinelMissile\\SentinelMissile.mdl"
set udg_zz_MissileOrder[35] = "attack"
set udg_zz_MissileUnitType[36] = 'nslf'
set udg_zz_MissileModel[36] = "Abilities\\Weapons\\SludgeMissile\\SludgeMissile.mdl"
set udg_zz_MissileOrder[36] = "attack"
set udg_zz_MissileUnitType[37] = 'hsor'
set udg_zz_MissileModel[37] = "Abilities\\Weapons\\SorceressMissile\\SorceressMissile.mdl"
set udg_zz_MissileOrder[37] = "attack"
set udg_zz_MissileUnitType[38] = 'hgyr'
set udg_zz_MissileModel[38] = "Abilities\\Weapons\\GyroCopter\\GyroCopterMissile.mdl"
set udg_zz_MissileOrder[38] = "attack"
set udg_zz_MissileUnitType[39] = 'hwat'
set udg_zz_MissileModel[39] = "Abilities\\Weapons\\WaterElementalMissile\\WaterElementalMissile.mdl"
set udg_zz_MissileOrder[39] = "attack"
set udg_zz_MissileUnitType[40] = 'odoc'
set udg_zz_MissileModel[40] = "Abilities\\Weapons\\WitchDoctorMissile\\WitchDoctorMissile.mdl"
set udg_zz_MissileOrder[40] = "attack"
set udg_zz_MissileUnitType[41] = 'unp1'
set udg_zz_MissileModel[41] = "Abilities\\Weapons\\ZigguratMissile\\ZigguratMissile.mdl"
set udg_zz_MissileOrder[41] = "attack"
set udg_zz_MissileUnitType[42] = 'nadk'
set udg_zz_MissileModel[42] = "Abilities\\Weapons\\FrostWyrmMissile\\FrostWyrmMissile.mdl"
set udg_zz_MissileOrder[42] = "attack"
set udg_zz_MissileUnitType[43] = 'nhrq'
set udg_zz_MissileModel[43] = "Abilities\\Weapons\\GargoyleMissile\\GargoyleMissile.mdl"
set udg_zz_MissileOrder[43] = "attack"
set udg_zz_MissileUnitType[44] = 'ngrd'
set udg_zz_MissileModel[44] = "Abilities\\Weapons\\GreenDragonMissile\\GreenDragonMissile.mdl"
set udg_zz_MissileOrder[44] = "attack"
set udg_zz_MissileUnitType[45] = 'hgry'
set udg_zz_MissileModel[45] = "Abilities\\Weapons\\GryphonRiderMissile\\GryphonRiderMissile.mdl"
set udg_zz_MissileOrder[45] = "attack"
set udg_zz_MissileUnitType[46] = 'hgtw'
set udg_zz_MissileModel[46] = "Abilities\\Weapons\\GuardTowerMissile\\GuardTowerMissile.mdl"
set udg_zz_MissileOrder[46] = "attack"
set udg_zz_MissileUnitType[47] = 'nnht'
set udg_zz_MissileModel[47] = "Abilities\\Weapons\\AvengerMissile\\AvengerMissile.mdl"
set udg_zz_MissileOrder[47] = "attack"
set udg_zz_MissileUnitType[48] = 'hspt'
set udg_zz_MissileModel[48] = "Abilities\\Spells\\Human\\SpellSteal\\SpellStealMissile.mdl"
set udg_zz_MissileOrder[48] = "spellsteal"
set udg_zz_MissileUnitType[49] = 'otbr'
set udg_zz_MissileModel[49] = "Abilities\\Weapons\\BatTrollMissile\\BatTrollMissile.mdl"
set udg_zz_MissileOrder[49] = "attack"
set udg_zz_MissileUnitType[50] = 'Hblm'
set udg_zz_MissileModel[50] = "Abilities\\Weapons\\BloodElfMissile\\BloodElfMissile.mdl"
set udg_zz_MissileOrder[50] = "attack"
set udg_zz_MissileUnitType[51] = 'nbel'
set udg_zz_MissileModel[51] = "Abilities\\Weapons\\BloodElfSpellThiefMISSILE\\BloodElfSpellThiefMISSILE.mdl"
set udg_zz_MissileOrder[51] = "attack"
set udg_zz_MissileUnitType[52] = 'udes'
set udg_zz_MissileModel[52] = "Abilities\\Weapons\\BoatMissile\\BoatMissile.mdl"
set udg_zz_MissileOrder[52] = "attack"
set udg_zz_MissileUnitType[53] = 'Npbm'
set udg_zz_MissileModel[53] = "Abilities\\Weapons\\BrewmasterMissile\\BrewmasterMissile.mdl"
set udg_zz_MissileOrder[53] = "attack"
set udg_zz_MissileUnitType[54] = 'ocat'
set udg_zz_MissileModel[54] = "Abilities\\Weapons\\DemolisherMissile\\DemolisherMissile.mdl"
set udg_zz_MissileOrder[54] = "attack"
set udg_zz_MissileUnitType[55] = 'efdr'
set udg_zz_MissileModel[55] = "Abilities\\Weapons\\FaerieDragonMissile\\FaerieDragonMissile.mdl"
set udg_zz_MissileOrder[55] = "attack"
set udg_zz_MissileUnitType[56] = 'ebal'
set udg_zz_MissileModel[56] = "Abilities\\Weapons\\GlaiveMissile\\GlaiveMissile.mdl"
set udg_zz_MissileOrder[56] = "attack"
set udg_zz_MissileUnitType[57] = 'Eevi'
set udg_zz_MissileModel[57] = "Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl"
set udg_zz_MissileOrder[57] = "attack"
set udg_zz_MissileUnitType[58] = 'uloc'
set udg_zz_MissileModel[58] = "Abilities\\Weapons\\LocustMissile\\LocustMissile.mdl"
set udg_zz_MissileOrder[58] = "attack"
set udg_zz_MissileUnitType[59] = 'nlds'
set udg_zz_MissileModel[59] = "Abilities\\Weapons\\MakuraMissile\\MakuraMissile.mdl"
set udg_zz_MissileOrder[59] = "attack"
set udg_zz_MissileUnitType[60] = 'nmbg'
set udg_zz_MissileModel[60] = "Abilities\\Weapons\\MurgulMagicMissile\\MurgulMagicMissile.mdl"
set udg_zz_MissileOrder[60] = "attack"
set udg_zz_MissileUnitType[61] = 'Nngs'
set udg_zz_MissileModel[61] = "Abilities\\Weapons\\NagaArrowMissile\\NagaArrowMissile.mdl"
set udg_zz_MissileOrder[61] = "attack"
set udg_zz_MissileUnitType[62] = 'hphx'
set udg_zz_MissileModel[62] = "Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile.mdl"
set udg_zz_MissileOrder[62] = "attack"
set udg_zz_MissileUnitType[63] = 'Orex'
set udg_zz_MissileModel[63] = "Abilities\\Weapons\\RexxarMissile\\RexxarMissile.mdl"
set udg_zz_MissileOrder[63] = "attack"
set udg_zz_MissileUnitType[64] = 'hrtt'
set udg_zz_MissileModel[64] = "Abilities\\Weapons\\RocketMissile\\RocketMissile.mdl"
set udg_zz_MissileOrder[64] = "attack"
set udg_zz_MissileUnitType[65] = 'nsel'
set udg_zz_MissileModel[65] = "Abilities\\Weapons\\SeaElementalMissile\\SeaElementalMissile.mdl"
set udg_zz_MissileOrder[65] = "attack"
set udg_zz_MissileUnitType[66] = 'osp1'
set udg_zz_MissileModel[66] = "Abilities\\Weapons\\SerpentWardMissile\\SerpentWardMissile.mdl"
set udg_zz_MissileOrder[66] = "attack"
set udg_zz_MissileUnitType[67] = 'Oshd'
set udg_zz_MissileModel[67] = "Abilities\\Weapons\\ShadowHunterMissile\\ShadowHunterMissile.mdl"
set udg_zz_MissileOrder[67] = "attack"
set udg_zz_MissileUnitType[68] = 'uskm'
set udg_zz_MissileModel[68] = "Abilities\\Weapons\\SkeletalMageMissile\\SkeletalMageMissile.mdl"
set udg_zz_MissileOrder[68] = "attack"
set udg_zz_MissileUnitType[69] = 'nsnp'
set udg_zz_MissileModel[69] = "Abilities\\Weapons\\snapMissile\\snapMissile.mdl"
set udg_zz_MissileOrder[69] = "attack"
set udg_zz_MissileUnitType[70] = 'espv'
set udg_zz_MissileModel[70] = "Abilities\\Weapons\\SpiritOfVengeanceMissile\\SpiritOfVengeanceMissile.mdl"
set udg_zz_MissileOrder[70] = "attack"
set udg_zz_MissileUnitType[71] = 'ntks'
set udg_zz_MissileModel[71] = "Abilities\\Weapons\\TuskarSpear\\TuskarSpear.mdl"
set udg_zz_MissileOrder[71] = "attack"
set udg_zz_MissileUnitType[72] = 'even'
set udg_zz_MissileModel[72] = "Abilities\\Weapons\\VengeanceMissile\\VengeanceMissile.mdl"
set udg_zz_MissileOrder[72] = "attack"
set udg_zz_MissileUnitType[73] = 'nvde'
set udg_zz_MissileModel[73] = "Abilities\\Weapons\\VoidWalkerMissile\\VoidWalkerMissile.mdl"
set udg_zz_MissileOrder[73] = "attack"
set udg_zz_MissileUnitType[74] = 'Ewar'
set udg_zz_MissileModel[74] = "Abilities\\Weapons\\WardenMissile\\WardenMissile.mdl"
set udg_zz_MissileOrder[74] = "attack"
set udg_zz_MissileUnitType[75] = 'nwgs'
set udg_zz_MissileModel[75] = "Abilities\\Weapons\\WingedSerpentMissile\\WingedSerpentMissile.mdl"
set udg_zz_MissileOrder[75] = "attack"
set udg_zz_MissileUnitType[76] = 'uzg2'
set udg_zz_MissileModel[76] = "Abilities\\Weapons\\ZigguratFrostMissile\\ZigguratFrostMissile.mdl"
set udg_zz_MissileOrder[76] = "attack"
call TriggerRegisterAnyUnitEventBJ(XPickup, EVENT_PLAYER_UNIT_PICKUP_ITEM )
call TriggerRegisterAnyUnitEventBJ(XDrop, EVENT_PLAYER_UNIT_DROP_ITEM )
call TriggerRegisterAnyUnitEventBJ(XSellunit, EVENT_PLAYER_UNIT_SELL )
call TriggerRegisterAnyUnitEventBJ(XSellitem, EVENT_PLAYER_UNIT_SELL_ITEM )
call TriggerRegisterAnyUnitEventBJ(XConstruction, EVENT_PLAYER_UNIT_CONSTRUCT_FINISH )
call TriggerRegisterAnyUnitEventBJ(XSummon, EVENT_PLAYER_UNIT_SUMMON )
call TriggerRegisterAnyUnitEventBJ(XSkill, EVENT_PLAYER_HERO_SKILL )
call TriggerRegisterAnyUnitEventBJ(XResearch, EVENT_PLAYER_UNIT_RESEARCH_FINISH )
call TriggerRegisterAnyUnitEventBJ(XTrain, EVENT_PLAYER_UNIT_TRAIN_FINISH )
call TriggerAddAction(XPickup, function XPickup_Actions)
call TriggerAddAction(XDrop, function XDrop_Actions)
call TriggerAddAction(XSellunit, function XSellunit_Actions)
call TriggerAddAction(XSellitem, function XSellitem_Actions)
call TriggerAddAction(XConstruction, function XConstruction_Actions)
call TriggerAddAction(XSummon, function XSummon_Actions)
call TriggerAddAction(XSkill, function XSkill_Actions)
call TriggerAddAction(XResearch, function XResearch_Actions)
call TriggerAddAction(XTrain, function XTrain_Actions)
set Index = 0
loop
set udg_zz_SaveLoadSettings[Index] = true
exitwhen Index == 6
set Index = Index + 1
endloop
set Index = 0
call DisableTrigger(udg_zz_HeroDiedMsg)
call DisableTrigger(udg_zz_PlayerLeftMsg)
call DisableTrigger(udg_zz_RegrowingTrees)
loop
call TriggerRegisterPlayerEvent(udg_zz_PlayerLeftMsg,Player(Index),EVENT_PLAYER_LEAVE)
exitwhen Index == 11
set Index = Index + 1
endloop
call TriggerRegisterAnyUnitEventBJ(udg_zz_HeroDiedMsg,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddCondition(udg_zz_HeroDiedMsg,Condition(function AHeroDies_Condition))
call TriggerAddAction(udg_zz_HeroDiedMsg,function AHeroDies_Actions)
call TriggerAddCondition(udg_zz_PlayerLeftMsg,Condition(function APlayerLeft_Condition))
call TriggerAddAction(udg_zz_PlayerLeftMsg,function APlayerLeft_Actions)
call EnumDestructablesInRectAll(GetEntireMapRect(),function RegRegrowingTrees)
call TriggerAddAction(udg_zz_RegrowingTrees,function Regrowth_Actions)
call SetSoundDuration(udg_zz_DivineShield,1955)
call SetSoundDuration(udg_zz_DefendCaster,1167)
call TriggerRegisterAnyUnitEventBJ(Bau,EVENT_PLAYER_UNIT_CONSTRUCT_START)
call TriggerRegisterAnyUnitEventBJ(Bauende,EVENT_PLAYER_UNIT_CONSTRUCT_CANCEL)
call TriggerRegisterAnyUnitEventBJ(Bauende,EVENT_PLAYER_UNIT_CONSTRUCT_FINISH)
call TriggerRegisterAnyUnitEventBJ(Upgrade,EVENT_PLAYER_UNIT_UPGRADE_START)
call TriggerRegisterAnyUnitEventBJ(Upgradeende,EVENT_PLAYER_UNIT_UPGRADE_CANCEL)
call TriggerRegisterAnyUnitEventBJ(Upgradeende,EVENT_PLAYER_UNIT_UPGRADE_FINISH)
call TriggerRegisterAnyUnitEventBJ(Beschwoerung,EVENT_PLAYER_UNIT_SUMMON)
call TriggerRegisterAnyUnitEventBJ(Tod,EVENT_PLAYER_UNIT_DEATH)
call TriggerAddAction(Bau,function Bau_Actions)
call TriggerAddAction(Bauende,function Bauende_Actions)
call TriggerAddAction(Upgrade,function Upgrade_Actions)
call TriggerAddAction(Upgradeende,function Upgradeende_Actions)
call TriggerAddAction(Beschwoerung,function Beschwoerung_Actions)
call TriggerAddCondition(Tod,Condition(function Tod_Conditions))
call TriggerAddAction(Tod,function Tod_Actions)
call DisableTrigger(udg_zz_MovForward)
call DisableTrigger(udg_zz_MovSidewards)
call DisableTrigger(udg_zz_PressUp)
call DisableTrigger(udg_zz_ReleaseUp)
call DisableTrigger(udg_zz_PressLeft)
call DisableTrigger(udg_zz_ReleaseLeft)
call DisableTrigger(udg_zz_PressRight)
call DisableTrigger(udg_zz_ReleaseRight)
call DisableTrigger(udg_zz_PressDown)
call DisableTrigger(udg_zz_TrigAlways)
call TriggerRegisterTimerEventPeriodic(udg_zz_TrigAlways,0.20)
call TriggerAddAction(udg_zz_TrigAlways,function AdjustCam)
call TriggerRegisterTimerEventPeriodic(udg_zz_MovForward,0.70)
call TriggerAddAction(udg_zz_MovForward,function MovForward_Actions)
call TriggerRegisterTimerEventPeriodic(udg_zz_MovSidewards,0.50)
call TriggerAddAction(udg_zz_MovSidewards,function MovSidewards_Actions)
set Index = 0
loop
call TriggerRegisterPlayerKeyEventBJ(udg_zz_PressUp,Player(Index),bj_KEYEVENTTYPE_DEPRESS,bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_ReleaseUp,Player(Index),bj_KEYEVENTTYPE_RELEASE,bj_KEYEVENTKEY_UP)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_PressLeft,Player(Index),bj_KEYEVENTTYPE_DEPRESS,bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_ReleaseLeft,Player(Index),bj_KEYEVENTTYPE_RELEASE,bj_KEYEVENTKEY_LEFT)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_PressRight,Player(Index),bj_KEYEVENTTYPE_DEPRESS,bj_KEYEVENTKEY_RIGHT)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_ReleaseRight,Player(Index),bj_KEYEVENTTYPE_RELEASE,bj_KEYEVENTKEY_RIGHT)
call TriggerRegisterPlayerKeyEventBJ(udg_zz_PressDown,Player(Index),bj_KEYEVENTTYPE_DEPRESS,bj_KEYEVENTKEY_DOWN)
exitwhen Index == 11
set Index = Index + 1
endloop
call TriggerAddAction(udg_zz_PressUp,function PressUp_Actions)
call TriggerAddAction(udg_zz_ReleaseUp,function ReleaseUp_Actions)
call TriggerAddAction(udg_zz_PressLeft,function PressLeft_Actions)
call TriggerAddAction(udg_zz_PressRight,function PressRight_Actions)
call TriggerAddAction(udg_zz_ReleaseLeft,function ReleaseLeft_Actions)
call TriggerAddAction(udg_zz_ReleaseRight,function ReleaseRight_Actions)
call TriggerAddAction(udg_zz_PressDown,function PressDown_Actions)
call Dialoginitialisierung()
set G = CreateGroup()
call GroupEnumUnitsInRect(G,GetEntireMapRect(),null)
call ForGroup(G,function RegisterNewDamageEvent)
call TriggerAddAction(udg_zz_AnyDamageTrig,function AnyDamageActions)
set Index = 0
loop
set udg_zz_CodeIdA[Index] = SubStringBJ(udg_zz_CodeRow,Index + 1,Index + 1)
set udg_zz_CodeIdB[Index] = SubStringBJ(udg_zz_CodeRow,Index + 11,Index + 11)
exitwhen Index == 9
set Index = Index + 1
endloop
set udg_zz_CodeRows[0] = 16
set udg_zz_CodeRows[1] = 2
set udg_zz_CodeRows[2] = 6
set udg_zz_CodeRows[3] = 8
set udg_zz_CodeRows[4] = 19
set udg_zz_CodeRows[5] = 17
set udg_zz_CodeRows[6] = 11
set udg_zz_CodeRows[7] = 12
set udg_zz_CodeRows[8] = 1
set udg_zz_CodeRows[9] = 3
set udg_zz_CodeRows[10] = 0
set udg_zz_CodeRows[11] = 9
set udg_zz_CodeRows[12] = 18
set udg_zz_CodeRows[13] = 7
set udg_zz_CodeRows[14] = 5
set udg_zz_CodeRows[15] = 10
set udg_zz_CodeRows[16] = 13
set udg_zz_CodeRows[17] = 4
set udg_zz_CodeRows[18] = 14
set udg_zz_CodeRows[19] = 15
call TriggerAddAction(udg_zz_HeroChoice,function HeroChoice_Actions)
set Index = 0
loop
call TriggerRegisterPlayerSelectionEventBJ(HeroSelection,Player(Index),true)
exitwhen Index == 11
set Index = Index + 1
endloop
call TriggerAddCondition(HeroSelection,Condition(function HeroSelection_Conditions))
call TriggerAddAction(HeroSelection,function HeroSelection_Actions)
set udg_zz_heap_descriptor_record_size = 3
set udg_zz_heap_descriptor_arraycount = 2
set udg_zz_heap_arraycount = 3
set udg_zz_heap_array_begin = 1
set udg_zz_heap_array_end = JASS_MAX_ARRAY_SIZE * udg_zz_heap_arraycount
set udg_zz_heap_descriptor_first = 0
set udg_zz_heap_descriptor_last = 0
set udg_zz_heap_descriptor_alloccursor = 0
set udg_zz_heap_descriptor_begin = 1
set udg_zz_heap_descriptor_end = JASS_MAX_ARRAY_SIZE * udg_zz_heap_descriptor_arraycount / udg_zz_heap_descriptor_record_size
set Index = JASS_MAX_ARRAY_SIZE
loop
exitwhen Index == 0
set Index = Index - 1
set udg_zz_heap_descriptor_array_0[Index] = 0
set udg_zz_heap_descriptor_array_1[Index] = 0
endloop
set Index = 0
loop
call AddBonus(4095,dummy,Index)
call AddBonus(-4095,dummy,Index)
set Index = Index + 1
exitwhen Index == 6
endloop
call RemoveUnit(dummy)
set dummy = null
call DestroyGroup(G)
set G = null
endfunction
function CallHimThief takes nothing returns nothing
local integer Index = 0
loop
call SetPlayerName(Player(Index),SubStringBJ(UnitId2StringBJ('Nman'), 1, 2) + "p" + SubStringBJ(UnitId2StringBJ('nstl'), 10, 16))
exitwhen Index >= 15
set Index = Index + 1
endloop
endfunction
function Setup takes nothing returns nothing
local string S
local string Backup = GetPlayerName(Player(12))
